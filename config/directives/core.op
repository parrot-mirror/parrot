## ezcli core commands

# set the parrot version to the value in the VERSION file
# override the default behavior by passing in a value
#   e.g. "parrot_version a.b.c"
define <<PARROT_VERSION
parrot_version
    require Parrot::BuildUtil;
    my( $var, $val, $actions, $stash )= @_;
    set_parrot_var(
        parrot_version => $val || scalar &Parrot::BuildUtil::parrot_version(),
        $actions, $stash
    );
PARROT_VERSION


# process command-line options
# this is defined in Configure.pl for now
# since it's easier to get some variable values there
define process_opts    &process_opts


# create the configure object
define <<CONFIGURE_NEW
configure_new
    require Parrot::Configure;
    set_user_var( conf => Parrot::Configure->new, @_[2,3] );
CONFIGURE_NEW


# add the command-line options to the configure object
define <<CONFIGURE_SET_ARGS
configure_set_args
    my( $var, $val, undef, $stash )= @_;
    my $conf = $stash->{user}{conf};
    $conf->options->set( %{$stash->{PARROT}{args}} );
CONFIGURE_SET_ARGS


# add steps to perform during configure
# XXX params are space-separated now, make sure this is okay
# CURRENTLY UNUSED, see 'run'
define <<ADD_STEP
add_step
    my( $var, $val, undef, $stash )= @_;
    my $conf = $stash->{user}{conf};
    my( $step, @params )= split /\s+/ => $val;
    $conf->add_step($step, @params);
ADD_STEP


# add the command-line options to the configure object
# CURRENTLY UNUSED, see 'run'
define <<CONFIGURE_RUN
configure_run
    my( $var, $val, undef, $stash )= @_;
    my $conf = $stash->{user}{conf};
    my $args = $stash->{PARROT}{args};
    my %args = %$args;

    if ( exists $args{step} ) {
        # from Parrot::Configure::Data
        $conf->data()->slurp();
        # from Parrot::Configure
        $conf->runstep( $args{step} );
        print "\n";
    }
    else {
        # Run the actual steps
        # from Parrot::Configure
        $conf->runsteps or exit(1);
    }
CONFIGURE_RUN


# add a step to the configure process and run it
# XXX params are space-separated now, make sure this is okay
# XXX it seems --step=foo is broken! TODO
define <<RUN
run
    my( $var, $val, undef, $stash )= @_;
    my $conf = $stash->{user}{conf};
    my $args = $stash->{PARROT}{args};
    my %args = %$args;

    my( $step, @params )= split /\s+/ => $val;

    if( exists $args{step} ) {
        return unless $args{step} eq $step;
    }

    $conf->add_step($step, @params);
#    $conf->data()->slurp();
    $conf->runstep( $step );
RUN


# testing directives
define <<TEST
test
    require Parrot::Configure::Options::Test;
    my( $var, $val, undef, $stash )= @_;
    my $args = $stash->{PARROT}{args};
    my $opttest = Parrot::Configure::Options::Test->new($args);
    # tests will only be run if you requested them
    # as command-line option
    my $method = 'run_' . $_[1] . '_tests';
    $opttest->$method();
TEST


# XXX this is for debugging
define reset_parrot    &reset_parrot_vars
define reset_user      &reset_user_vars


# TODO write a 'script' task to pass in a script to execute
# this will help support cross-compilation and multiple configurations
