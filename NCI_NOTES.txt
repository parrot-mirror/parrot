These are temporary notes about NCI as they can become confusing when you
start working on multiple implementations!

Current 'Builtin' NCI:

The bytecode calls

    val = dlfunc LIBRARY, FUNCTION, PROTOTYPE

which returns an NCI PMC which can be called just like a normal function.

dlfunc is implemented in core.op which simple does a pmc_new and then calls
set_pointer_keyed_str on it with the prototype and the looked up address
of the function in the library.

All that set_pointer_keyed_str does is remember the function address
(in struct val) and the looked up address (using build_call_func, in
the data field) of the nci wrapper code which can handle that
signature.

When the NCI PMC is invoked, it retrieves the function from the NCI
layer function and calls it with the PMC itself as the argument.

The NCI layer function will then retrieve the call arguments from the
interpreter, put them into C types, and call the library function. The
returned value is converted back to a parrot PMC, and returns.

PMC must store: address of NCI layer function, and library function


'Current' 'ffcall' implementation

The set_pointer_keyed_str sets struct_val to the ultimate function,
and data to malloced data structure which contains the parrot and NCI
signatures.


When the invoke method is called, the main nci ffcall invoke routine
is called mostly makes ffcall calls based on the two signatures.




Suggested unification:

Implement an NCI abstraction which will use vtables. The entries will be:

   nci_new
   nci_clone
   nci_invoke
   nci_free


