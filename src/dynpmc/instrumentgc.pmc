/*
Copyright (C) 2010, Parrot Foundation.
$Id$

=head1 NAME

src/dynpmc/instrumentgc.pmc - Interface to instrument the gc_sys entry of Parrot_Interp.

=head1 DESCRIPTION

C<InstrumentPMC> is a PMC class that provides an interface to
instrument the gc_sys entry of Parrot_Interp.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

#include "pmc_instrument.h"
#include "../gc/gc_private.h"

/* BELOW LIES GENERATED CODE GENERATED BY tools/build/gen_gc_stubs.pl */
typedef struct InstrumentGC_Subsystem {
    /* Common entries taken from GC_Subsystem. */
    /* BEGIN gc struct entries */
gc_sys_type_enum sys_type;
void (*finalize_gc_system) (PARROT_INTERP);
void (*destroy_child_interp)(Interp *dest_interp, Interp *child_interp);
void (*do_gc_mark)(PARROT_INTERP, UINTVAL flags);
void (*compact_string_pool)(PARROT_INTERP);
void (*mark_special)(PARROT_INTERP, PMC *);
void (*pmc_needs_early_collection)(PARROT_INTERP, PMC *);
void (*init_pool)(PARROT_INTERP, struct Fixed_Size_Pool *);
PMC* (*allocate_pmc_header)(PARROT_INTERP, UINTVAL flags);
void (*free_pmc_header)(PARROT_INTERP, PMC *);
STRING* (*allocate_string_header)(PARROT_INTERP, UINTVAL flags);
void (*free_string_header)(PARROT_INTERP, STRING*);
Buffer* (*allocate_bufferlike_header)(PARROT_INTERP, size_t size);
void (*free_bufferlike_header)(PARROT_INTERP, Buffer*, size_t size);
void* (*allocate_pmc_attributes)(PARROT_INTERP, PMC *);
void (*free_pmc_attributes)(PARROT_INTERP, PMC *);
void (*allocate_string_storage)(PARROT_INTERP, STRING *str, size_t size);
void (*reallocate_string_storage)(PARROT_INTERP, STRING *str, size_t size);
void (*allocate_buffer_storage)(PARROT_INTERP, ARGMOD(Buffer *buffer), size_t nsize);
void (*reallocate_buffer_storage)(PARROT_INTERP, ARGMOD(Buffer *buffer), size_t newsize);
void* (*allocate_fixed_size_storage)(PARROT_INTERP, size_t size);
void (*free_fixed_size_storage)(PARROT_INTERP, size_t size, void *);
void* (*allocate_memory_chunk)(PARROT_INTERP, size_t size);
void* (*reallocate_memory_chunk)(PARROT_INTERP, void *data, size_t newsize);
void* (*allocate_memory_chunk_with_interior_pointers)(PARROT_INTERP, size_t size);
void* (*reallocate_memory_chunk_with_interior_pointers)(PARROT_INTERP, void *data,
                                                        size_t oldsize, size_t newsize);
void (*free_memory_chunk)(PARROT_INTERP, void *data);
void (*block_mark)(PARROT_INTERP);
void (*unblock_mark)(PARROT_INTERP);
unsigned int (*is_blocked_mark)(PARROT_INTERP);
void (*block_sweep)(PARROT_INTERP);
void (*unblock_sweep)(PARROT_INTERP);
unsigned int (*is_blocked_sweep)(PARROT_INTERP);
size_t (*get_gc_info)(PARROT_INTERP, Interpinfo_enum);
    /* END gc struct entries */
    /* End of common entries. */

    /* Additional Entries. */
    PMC           *instrument_gc;
    Parrot_Interp  supervisor;
    GC_Subsystem  *original;
} InstrumentGC_Subsystem;
/* END OF GENERATED CODE */

/* Prototypes for helper functions. */
void raise_gc_event(PARROT_INTERP, Parrot_Interp supervised, STRING *group, PMC *data);
void setup_gc_common_hashes(PARROT_INTERP);
void destroy_gc_common_hashes(PARROT_INTERP);
void setup_gc_individual_hashes(PARROT_INTERP, Hash *orig_hash, Hash *instr_hash,
                                GC_Subsystem *gc_orig, InstrumentGC_Subsystem *gc_instr);

/* Globals used internally. */
static INTVAL  gc_first_run   = 1;
static Hash   *gc_registry    = NULL;
static Hash   *gc_name_stubs  = NULL;
static Hash   *gc_group_items = NULL;
static Hash   *gc_item_groups = NULL;

pmclass InstrumentGC auto_attrs dynpmc group instrument_group extends InstrumentStubBase {

/*
=item C<void init_pmc(PMC *instrument)>

Initialises and prepares the supervised interpreter for GC instrumenting.

=cut

*/

    VTABLE void init_pmc(PMC *instrument) {
        Parrot_InstrumentGC_attributes * const attr = PARROT_INSTRUMENTGC(SELF);
        Parrot_Interp supervised;
        InstrumentGC_Subsystem *sub;
        SUPER(instrument);

        GETATTR_Instrument_supervised(INTERP, instrument, supervised);

        /* Initialise the structs */
        sub = mem_gc_allocate_zeroed_typed(INTERP, InstrumentGC_Subsystem);
        attr->original_struct     = supervised->gc_sys;
        attr->instrumented_struct = sub;

        /* Initiliase the instrumented gc_sys with the original values. */
        sub->instrument_gc = SELF;
        sub->supervisor    = INTERP;
        sub->original      = (GC_Subsystem *) attr->original_struct;

        /* Set the gc_sys of the supervised to the instrumented gc_sys. */
        mem_copy_n_typed(attr->instrumented_struct, attr->original_struct, 1, GC_Subsystem);
        supervised->gc_sys = (GC_Subsystem *) attr->instrumented_struct;

        /* Initialise the hashes. */
        setup_gc_common_hashes(INTERP);
        setup_gc_individual_hashes(INTERP, attr->name_original, attr->name_offset,
                                   (GC_Subsystem *) attr->original_struct,
                                   (InstrumentGC_Subsystem *) attr->instrumented_struct);

        /* Update the attributes to point to the static hashes. */
        attr->name_stubs  = gc_name_stubs;
        attr->group_items = gc_group_items;
        attr->item_groups = gc_item_groups;

        /* Register self in the registry. */
        parrot_hash_put(INTERP, gc_registry, SELF, SELF);
    }

/*

=item C<void destroy()>

Performs cleanup for InstrumentGC attributes.

=cut

*/

    VTABLE void destroy() {
        Parrot_InstrumentGC_attributes * const attr = PARROT_INSTRUMENTGC(SELF);
        SUPER();
        parrot_hash_delete(INTERP, gc_registry, SELF);
        destroy_gc_common_hashes(INTERP);
    }
}

/*
 * Helper functions
 */

/*
 * raise_gc_event: Creates a Task of subtype Instrument
 *                 and sets its data to the given data, adding file,
 *                 sub, namespace and line information to the data hash.
 */

void raise_gc_event(PARROT_INTERP, Parrot_Interp supervised, STRING *group, PMC *data) {
    PMC *task, *task_hash, *event;
    STRING *event_str;
    Parrot_Context_info info;
    event_str = VTABLE_get_string_keyed_str(interp, data, CONST_STRING(interp, "type"));

    event = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, event, CONST_STRING(interp, "GC"));
    VTABLE_push_string(interp, event, group);
    VTABLE_push_string(interp, event, event_str);

    Parrot_Context_get_info(interp, CURRENT_CONTEXT(supervised), &info);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "file"),      info.file);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "sub"),       info.subname);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "namespace"), info.nsname);
    VTABLE_set_integer_keyed_str(interp, data, CONST_STRING(interp, "line"),      info.line);
    VTABLE_set_pmc_keyed_str(interp, data, CONST_STRING(interp, "event"), event);

    task_hash = Parrot_pmc_new(interp, enum_class_Hash);
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "type"),
                                CONST_STRING(interp, "event"));
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "subtype"),
                                CONST_STRING(interp, "Instrument"));
    VTABLE_set_pmc_keyed_str(interp, task_hash, CONST_STRING(interp, "data"), data);

    task = Parrot_pmc_new_init(interp, enum_class_Task, task_hash);
    Parrot_cx_schedule_task(interp, task);
}


/* BELOW LIES GENERATED CODE GENERATED BY tools/build/gen_gc_stubs.pl */
/* BEGIN gc prototypes */
void  stub_finalize_gc_system(PARROT_INTERP);
void  stub_destroy_child_interp(Interp* dest_interp, Interp* child_interp);
void  stub_do_gc_mark(PARROT_INTERP, UINTVAL flags);
void  stub_compact_string_pool(PARROT_INTERP);
void  stub_mark_special(PARROT_INTERP, PMC*  stub_var1);
void  stub_pmc_needs_early_collection(PARROT_INTERP, PMC*  stub_var1);
void  stub_init_pool(PARROT_INTERP, struct Fixed_Size_Pool*  stub_var1);
PMC*  stub_allocate_pmc_header(PARROT_INTERP, UINTVAL flags);
void  stub_free_pmc_header(PARROT_INTERP, PMC*  stub_var1);
STRING*  stub_allocate_string_header(PARROT_INTERP, UINTVAL flags);
void  stub_free_string_header(PARROT_INTERP, STRING* stub_var1);
Buffer*  stub_allocate_bufferlike_header(PARROT_INTERP, size_t size);
void  stub_free_bufferlike_header(PARROT_INTERP, Buffer* stub_var1, size_t size);
void*  stub_allocate_pmc_attributes(PARROT_INTERP, PMC*  stub_var1);
void  stub_free_pmc_attributes(PARROT_INTERP, PMC*  stub_var1);
void  stub_allocate_string_storage(PARROT_INTERP, STRING* str, size_t size);
void  stub_reallocate_string_storage(PARROT_INTERP, STRING* str, size_t size);
void  stub_allocate_buffer_storage(PARROT_INTERP, Buffer* buffer, size_t nsize);
void  stub_reallocate_buffer_storage(PARROT_INTERP, Buffer* buffer, size_t newsize);
void*  stub_allocate_fixed_size_storage(PARROT_INTERP, size_t size);
void  stub_free_fixed_size_storage(PARROT_INTERP, size_t size, void*  stub_var1);
void*  stub_allocate_memory_chunk(PARROT_INTERP, size_t size);
void*  stub_reallocate_memory_chunk(PARROT_INTERP, void* data, size_t newsize);
void*  stub_allocate_memory_chunk_with_interior_pointers(PARROT_INTERP, size_t size);
void*  stub_reallocate_memory_chunk_with_interior_pointers(PARROT_INTERP, void* data,
                                                           size_t oldsize, size_t newsize);
void  stub_free_memory_chunk(PARROT_INTERP, void* data);
void  stub_block_mark(PARROT_INTERP);
void  stub_unblock_mark(PARROT_INTERP);
void  stub_block_sweep(PARROT_INTERP);
void  stub_unblock_sweep(PARROT_INTERP);
/* END gc prototypes */

void setup_gc_common_hashes(PARROT_INTERP) {
    PMC *temp;
    if (!gc_first_run) return;

    gc_first_run   = 0;
    gc_registry    = parrot_new_pointer_hash(interp);
    gc_name_stubs  = parrot_new_hash(interp);
    gc_group_items = parrot_new_hash(interp);
    gc_item_groups = parrot_new_hash(interp);

    /* BEGIN gc mapping name stubs */
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "finalize_gc_system"),
        stub_finalize_gc_system);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "destroy_child_interp"),
        stub_destroy_child_interp);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "do_gc_mark"),
        stub_do_gc_mark);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "compact_string_pool"),
        stub_compact_string_pool);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "mark_special"),
        stub_mark_special);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "pmc_needs_early_collection"),
        stub_pmc_needs_early_collection);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "init_pool"),
        stub_init_pool);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_pmc_header"),
        stub_allocate_pmc_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_pmc_header"),
        stub_free_pmc_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_string_header"),
        stub_allocate_string_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_string_header"),
        stub_free_string_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_bufferlike_header"),
        stub_allocate_bufferlike_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_bufferlike_header"),
        stub_free_bufferlike_header);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_pmc_attributes"),
        stub_allocate_pmc_attributes);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_pmc_attributes"),
        stub_free_pmc_attributes);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_string_storage"),
        stub_allocate_string_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "reallocate_string_storage"),
        stub_reallocate_string_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_buffer_storage"),
        stub_allocate_buffer_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "reallocate_buffer_storage"),
        stub_reallocate_buffer_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_fixed_size_storage"),
        stub_allocate_fixed_size_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_fixed_size_storage"),
        stub_free_fixed_size_storage);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_memory_chunk"),
        stub_allocate_memory_chunk);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "reallocate_memory_chunk"),
        stub_reallocate_memory_chunk);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"),
        stub_allocate_memory_chunk_with_interior_pointers);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"),
        stub_reallocate_memory_chunk_with_interior_pointers);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "free_memory_chunk"),
        stub_free_memory_chunk);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "block_mark"),
        stub_block_mark);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "unblock_mark"),
        stub_unblock_mark);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "block_sweep"),
        stub_block_sweep);
    parrot_hash_put(interp, gc_name_stubs,
        CONST_STRING(interp, "unblock_sweep"),
        stub_unblock_sweep);
    /* END gc mapping name stubs */

    /* BEGIN gc mapping group items */
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_pmc_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_string_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_bufferlike_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_pmc_attributes"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_fixed_size_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_memory_chunk"));
    parrot_hash_put(interp, gc_group_items,
                    CONST_STRING(interp, "free"),
                    temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "finalize_gc_system"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "destroy_child_interp"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "do_gc_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "compact_string_pool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "mark_special"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pmc_needs_early_collection"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "init_pool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "block_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unblock_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "block_sweep"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unblock_sweep"));
    parrot_hash_put(interp, gc_group_items,
                    CONST_STRING(interp, "administration"),
                    temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_pmc_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_string_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_bufferlike_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_pmc_attributes"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_string_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_buffer_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_fixed_size_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_memory_chunk"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"));
    parrot_hash_put(interp, gc_group_items,
                    CONST_STRING(interp, "allocate"),
                    temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "finalize_gc_system"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "destroy_child_interp"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "do_gc_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "compact_string_pool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "mark_special"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pmc_needs_early_collection"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "init_pool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_pmc_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_pmc_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_string_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_string_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_bufferlike_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_bufferlike_header"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_pmc_attributes"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_pmc_attributes"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_string_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_string_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_buffer_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_buffer_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_fixed_size_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_fixed_size_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_memory_chunk"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_memory_chunk"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free_memory_chunk"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "block_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unblock_mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "block_sweep"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unblock_sweep"));
    parrot_hash_put(interp, gc_group_items,
                    CONST_STRING(interp, "all"),
                    temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_string_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_buffer_storage"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_memory_chunk"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"));
    parrot_hash_put(interp, gc_group_items,
                    CONST_STRING(interp, "reallocate"),
                    temp);
    /* END gc mapping group items */

    /* BEGIN gc mapping item groups */
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "finalize_gc_system"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "destroy_child_interp"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "do_gc_mark"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "compact_string_pool"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "mark_special"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "pmc_needs_early_collection"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "init_pool"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_pmc_header"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_pmc_header"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_string_header"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_string_header"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_bufferlike_header"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_bufferlike_header"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_pmc_attributes"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_pmc_attributes"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_string_storage"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "reallocate_string_storage"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_buffer_storage"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "reallocate_buffer_storage"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_fixed_size_storage"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_fixed_size_storage"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_memory_chunk"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "reallocate_memory_chunk"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "allocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "reallocate"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "free"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "free_memory_chunk"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "block_mark"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "unblock_mark"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "block_sweep"),
        temp);
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "administration"));
    parrot_hash_put(interp, gc_item_groups,
        CONST_STRING(interp, "unblock_sweep"),
        temp);
    /* END gc mapping item groups */
}

void destroy_gc_common_hashes(PARROT_INTERP) {
    if (parrot_hash_size(interp, gc_registry) == 0) {
        parrot_hash_destroy(interp, gc_registry);
        parrot_hash_destroy(interp, gc_name_stubs);
        parrot_hash_destroy(interp, gc_group_items);
        parrot_hash_destroy(interp, gc_item_groups);

        gc_first_run = 1;
    }
}

void setup_gc_individual_hashes(PARROT_INTERP, Hash *orig_hash, Hash *instr_hash,
                                GC_Subsystem *gc_orig, InstrumentGC_Subsystem *gc_instr) {
    /* BEGIN gc mapping name offset */
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "finalize_gc_system"),
        &(gc_instr->finalize_gc_system));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "destroy_child_interp"),
        &(gc_instr->destroy_child_interp));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "do_gc_mark"),
        &(gc_instr->do_gc_mark));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "compact_string_pool"),
        &(gc_instr->compact_string_pool));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "mark_special"),
        &(gc_instr->mark_special));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "pmc_needs_early_collection"),
        &(gc_instr->pmc_needs_early_collection));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "init_pool"),
        &(gc_instr->init_pool));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_pmc_header"),
        &(gc_instr->allocate_pmc_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_pmc_header"),
        &(gc_instr->free_pmc_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_string_header"),
        &(gc_instr->allocate_string_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_string_header"),
        &(gc_instr->free_string_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_bufferlike_header"),
        &(gc_instr->allocate_bufferlike_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_bufferlike_header"),
        &(gc_instr->free_bufferlike_header));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_pmc_attributes"),
        &(gc_instr->allocate_pmc_attributes));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_pmc_attributes"),
        &(gc_instr->free_pmc_attributes));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_string_storage"),
        &(gc_instr->allocate_string_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_string_storage"),
        &(gc_instr->reallocate_string_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_buffer_storage"),
        &(gc_instr->allocate_buffer_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_buffer_storage"),
        &(gc_instr->reallocate_buffer_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_fixed_size_storage"),
        &(gc_instr->allocate_fixed_size_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_fixed_size_storage"),
        &(gc_instr->free_fixed_size_storage));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_memory_chunk"),
        &(gc_instr->allocate_memory_chunk));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_memory_chunk"),
        &(gc_instr->reallocate_memory_chunk));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"),
        &(gc_instr->allocate_memory_chunk_with_interior_pointers));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"),
        &(gc_instr->reallocate_memory_chunk_with_interior_pointers));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_memory_chunk"),
        &(gc_instr->free_memory_chunk));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "block_mark"),
        &(gc_instr->block_mark));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unblock_mark"),
        &(gc_instr->unblock_mark));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "block_sweep"),
        &(gc_instr->block_sweep));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unblock_sweep"),
        &(gc_instr->unblock_sweep));
    /* END gc mapping name offset */

    /* BEGIN gc mapping name original */
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "finalize_gc_system"),
        gc_orig->finalize_gc_system);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "destroy_child_interp"),
        gc_orig->destroy_child_interp);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "do_gc_mark"),
        gc_orig->do_gc_mark);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "compact_string_pool"),
        gc_orig->compact_string_pool);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "mark_special"),
        gc_orig->mark_special);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "pmc_needs_early_collection"),
        gc_orig->pmc_needs_early_collection);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "init_pool"),
        gc_orig->init_pool);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_pmc_header"),
        gc_orig->allocate_pmc_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_pmc_header"),
        gc_orig->free_pmc_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_string_header"),
        gc_orig->allocate_string_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_string_header"),
        gc_orig->free_string_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_bufferlike_header"),
        gc_orig->allocate_bufferlike_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_bufferlike_header"),
        gc_orig->free_bufferlike_header);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_pmc_attributes"),
        gc_orig->allocate_pmc_attributes);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_pmc_attributes"),
        gc_orig->free_pmc_attributes);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_string_storage"),
        gc_orig->allocate_string_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_string_storage"),
        gc_orig->reallocate_string_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_buffer_storage"),
        gc_orig->allocate_buffer_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_buffer_storage"),
        gc_orig->reallocate_buffer_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_fixed_size_storage"),
        gc_orig->allocate_fixed_size_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_fixed_size_storage"),
        gc_orig->free_fixed_size_storage);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_memory_chunk"),
        gc_orig->allocate_memory_chunk);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_memory_chunk"),
        gc_orig->reallocate_memory_chunk);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"),
        gc_orig->allocate_memory_chunk_with_interior_pointers);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"),
        gc_orig->reallocate_memory_chunk_with_interior_pointers);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_memory_chunk"),
        gc_orig->free_memory_chunk);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "block_mark"),
        gc_orig->block_mark);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unblock_mark"),
        gc_orig->unblock_mark);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "block_sweep"),
        gc_orig->block_sweep);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unblock_sweep"),
        gc_orig->unblock_sweep);
    /* END gc mapping name original */
}

/* BEGIN gc stubs */
void  stub_finalize_gc_system(Parrot_Interp interp) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->finalize_gc_system(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "finalize_gc_system"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_destroy_child_interp(Interp* interp, Interp* child_interp) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->destroy_child_interp(interp, child_interp);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, child_interp);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "destroy_child_interp"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_do_gc_mark(Parrot_Interp interp, UINTVAL flags) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->do_gc_mark(interp, flags);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, flags);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "do_gc_mark"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_compact_string_pool(Parrot_Interp interp) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->compact_string_pool(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "compact_string_pool"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_mark_special(Parrot_Interp interp, PMC* stub_var1) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->mark_special(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "mark_special"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_pmc_needs_early_collection(Parrot_Interp interp, PMC* stub_var1) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->pmc_needs_early_collection(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "pmc_needs_early_collection"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_init_pool(Parrot_Interp interp, struct Fixed_Size_Pool* stub_var1) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->init_pool(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "init_pool"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

PMC*  stub_allocate_pmc_header(Parrot_Interp interp, UINTVAL flags) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    PMC*  ret;


    ret = gc_orig->allocate_pmc_header(interp, flags);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, flags);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_pmc_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              sizeof (PMC));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void  stub_free_pmc_header(Parrot_Interp interp, PMC* stub_var1) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->free_pmc_header(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_pmc_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

STRING*  stub_allocate_string_header(Parrot_Interp interp, UINTVAL flags) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    STRING*  ret;


    ret = gc_orig->allocate_string_header(interp, flags);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, flags);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_string_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              sizeof (STRING));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void  stub_free_string_header(Parrot_Interp interp, STRING* stub_var1) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->free_string_header(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_string_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

Buffer*  stub_allocate_bufferlike_header(Parrot_Interp interp, size_t size) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    Buffer*  ret;


    ret = gc_orig->allocate_bufferlike_header(interp, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_bufferlike_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              sizeof (Buffer));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void  stub_free_bufferlike_header(Parrot_Interp interp, Buffer* stub_var1, size_t size) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->free_bufferlike_header(interp, stub_var1, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_bufferlike_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

void*  stub_allocate_pmc_attributes(Parrot_Interp interp, PMC* stub_var1) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;


    ret = gc_orig->allocate_pmc_attributes(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_pmc_attributes"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              VTABLE_get_pmc_keyed_int(supervisor, params, 0)->vtable->attr_size);
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void  stub_free_pmc_attributes(Parrot_Interp interp, PMC* stub_var1) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->free_pmc_attributes(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_pmc_attributes"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

void  stub_allocate_string_storage(Parrot_Interp interp, STRING* str, size_t size) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->allocate_string_storage(interp, str, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, str);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_string_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              size);
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return;
}

void  stub_reallocate_string_storage(Parrot_Interp interp, STRING* str, size_t size) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->reallocate_string_storage(interp, str, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, str);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "reallocate_string_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              size);
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "reallocate"), event_data);

    return;
}

void  stub_allocate_buffer_storage(Parrot_Interp interp, Buffer* buffer, size_t nsize) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->allocate_buffer_storage(interp, buffer, nsize);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, buffer);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, nsize);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_buffer_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              nsize);
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return;
}

void  stub_reallocate_buffer_storage(Parrot_Interp interp, Buffer* buffer, size_t newsize) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->reallocate_buffer_storage(interp, buffer, newsize);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, buffer);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, newsize);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "reallocate_buffer_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              newsize);
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "reallocate"), event_data);

    return;
}

void*  stub_allocate_fixed_size_storage(Parrot_Interp interp, size_t size) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;


    ret = gc_orig->allocate_fixed_size_storage(interp, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_fixed_size_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              size);
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void  stub_free_fixed_size_storage(Parrot_Interp interp, size_t size, void* stub_var1) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->free_fixed_size_storage(interp, size, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_fixed_size_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

void*  stub_allocate_memory_chunk(Parrot_Interp interp, size_t size) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;


    ret = gc_orig->allocate_memory_chunk(interp, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_memory_chunk"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              size);
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void*  stub_reallocate_memory_chunk(Parrot_Interp interp, void* data, size_t newsize) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;


    ret = gc_orig->reallocate_memory_chunk(interp, data, newsize);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, data);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, newsize);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "reallocate_memory_chunk"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              newsize);
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "reallocate"), event_data);

    return ret;
}

void*  stub_allocate_memory_chunk_with_interior_pointers(Parrot_Interp interp, size_t size) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;


    ret = gc_orig->allocate_memory_chunk_with_interior_pointers(interp, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_memory_chunk_with_interior_pointers"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              size);
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void*  stub_reallocate_memory_chunk_with_interior_pointers(Parrot_Interp interp, void* data,
                                                           size_t oldsize, size_t newsize) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;


    ret = gc_orig->reallocate_memory_chunk_with_interior_pointers(interp, data, oldsize, newsize);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, data);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, oldsize);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, newsize);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "reallocate_memory_chunk_with_interior_pointers"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp,
                              newsize);
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
                            CONST_STRING(supervisor, "size"),
                            temp);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "reallocate"), event_data);

    return ret;
}

void  stub_free_memory_chunk(Parrot_Interp interp, void* data) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->free_memory_chunk(interp, data);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, data);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_memory_chunk"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

void  stub_block_mark(Parrot_Interp interp) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->block_mark(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "block_mark"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_unblock_mark(Parrot_Interp interp) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->unblock_mark(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "unblock_mark"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_block_sweep(Parrot_Interp interp) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->block_sweep(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "block_sweep"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_unblock_sweep(Parrot_Interp interp) {
    GC_Subsystem *gc_orig    = ((InstrumentGC_Subsystem *) interp->gc_sys)->original;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;

    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);


    gc_orig->unblock_sweep(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "unblock_sweep"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

/* END gc stubs */

/* END OF GENERATED CODE */

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
