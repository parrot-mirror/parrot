/*
Copyright (C) 2010, Parrot Foundation.
$Id$

=head1 NAME

src/dynpmc/instrumentgc.pmc - Interface to instrument the gc_sys entry of Parrot_Interp.

=head1 DESCRIPTION

C<InstrumentPMC> is a PMC class that provides an interface to
instrument the gc_sys entry of Parrot_Interp.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

#include "pmc_instrument.h"
#include "../gc/gc_private.h"

typedef struct InstrumentGC_Subsystem {
    /* Common entries taken from GC_Subsystem. */
    gc_sys_type_enum sys_type;
    void (*finalize_gc_system) (PARROT_INTERP);
    void (*destroy_child_interp)(Interp *dest_interp, Interp *child_interp);
    void (*do_gc_mark)(PARROT_INTERP, UINTVAL flags);
    void (*compact_string_pool)(PARROT_INTERP);
    void (*mark_special)(PARROT_INTERP, PMC *);
    void (*pmc_needs_early_collection)(PARROT_INTERP, PMC *);
    void (*init_pool)(PARROT_INTERP, struct Fixed_Size_Pool *);
    PMC* (*allocate_pmc_header)(PARROT_INTERP, UINTVAL flags);
    void (*free_pmc_header)(PARROT_INTERP, PMC *);
    STRING* (*allocate_string_header)(PARROT_INTERP, UINTVAL flags);
    void (*free_string_header)(PARROT_INTERP, STRING*);
    Buffer* (*allocate_bufferlike_header)(PARROT_INTERP, size_t size);
    void (*free_bufferlike_header)(PARROT_INTERP, Buffer*, size_t size);
    void* (*allocate_pmc_attributes)(PARROT_INTERP, PMC *);
    void (*free_pmc_attributes)(PARROT_INTERP, PMC *);
    void (*allocate_string_storage)(PARROT_INTERP, STRING *str, size_t size);
    void (*reallocate_string_storage)(PARROT_INTERP, STRING *str, size_t size);
    void (*allocate_buffer_storage)(PARROT_INTERP, ARGMOD(Buffer *buffer), size_t nsize);
    void (*reallocate_buffer_storage)(PARROT_INTERP, ARGMOD(Buffer *buffer), size_t newsize);
    void* (*allocate_fixed_size_storage)(PARROT_INTERP, size_t size);
    void (*free_fixed_size_storage)(PARROT_INTERP, size_t size, void *);
    void* (*allocate_memory_chunk)(PARROT_INTERP, size_t size);
    void* (*reallocate_memory_chunk)(PARROT_INTERP, void *data, size_t newsize);
    void* (*allocate_memory_chunk_with_interior_pointers)(PARROT_INTERP, size_t size);
    void* (*reallocate_memory_chunk_with_interior_pointers)(PARROT_INTERP, void *data,
            size_t oldsize, size_t newsize);
    void (*free_memory_chunk)(PARROT_INTERP, void *data);
    void (*block_mark)(PARROT_INTERP);
    void (*unblock_mark)(PARROT_INTERP);
    unsigned int (*is_blocked_mark)(PARROT_INTERP);
    void (*block_sweep)(PARROT_INTERP);
    void (*unblock_sweep)(PARROT_INTERP);
    unsigned int (*is_blocked_sweep)(PARROT_INTERP);
    size_t (*get_gc_info)(PARROT_INTERP, Interpinfo_enum);
    /* End of common entries. */

    /* Additional Entries. */
    PMC           *instrument_gc;
    Parrot_Interp  supervisor;
} InstrumentGC_Subsystem;

/* Prototypes for stub functions. */
/* BEGIN gc prototypes */
void  stub_finalize_gc_system(PARROT_INTERP);
void  stub_destroy_child_interp(Interp* dest_interp, Interp* child_interp);
void  stub_do_gc_mark(PARROT_INTERP, UINTVAL flags);
void  stub_compact_string_pool(PARROT_INTERP);
void  stub_mark_special(PARROT_INTERP, PMC*  stub_var1);
void  stub_pmc_needs_early_collection(PARROT_INTERP, PMC*  stub_var1);
void  stub_init_pool(PARROT_INTERP, struct Fixed_Size_Pool*  stub_var1);
PMC*  stub_allocate_pmc_header(PARROT_INTERP, UINTVAL flags);
void  stub_free_pmc_header(PARROT_INTERP, PMC*  stub_var1);
STRING*  stub_allocate_string_header(PARROT_INTERP, UINTVAL flags);
void  stub_free_string_header(PARROT_INTERP, STRING* stub_var1);
Buffer*  stub_allocate_bufferlike_header(PARROT_INTERP, size_t size);
void  stub_free_bufferlike_header(PARROT_INTERP, Buffer* stub_var1, size_t size);
void*  stub_allocate_pmc_attributes(PARROT_INTERP, PMC*  stub_var1);
void  stub_free_pmc_attributes(PARROT_INTERP, PMC*  stub_var1);
void  stub_allocate_string_storage(PARROT_INTERP, STRING* str, size_t size);
void  stub_reallocate_string_storage(PARROT_INTERP, STRING* str, size_t size);
void  stub_allocate_buffer_storage(PARROT_INTERP, Buffer* buffer, size_t nsize);
void  stub_reallocate_buffer_storage(PARROT_INTERP, Buffer* buffer, size_t newsize);
void*  stub_allocate_fixed_size_storage(PARROT_INTERP, size_t size);
void  stub_free_fixed_size_storage(PARROT_INTERP, size_t size, void*  stub_var1);
void*  stub_allocate_memory_chunk(PARROT_INTERP, size_t size);
void*  stub_reallocate_memory_chunk(PARROT_INTERP, void* data, size_t newsize);
void*  stub_allocate_memory_chunk_with_interior_pointers(PARROT_INTERP, size_t size);
void*  stub_reallocate_memory_chunk_with_interior_pointers(PARROT_INTERP, void* data,
                                                           size_t oldsize, size_t newsize);
void  stub_free_memory_chunk(PARROT_INTERP, void* data);
void  stub_block_mark(PARROT_INTERP);
void  stub_unblock_mark(PARROT_INTERP);
void  stub_block_sweep(PARROT_INTERP);
void  stub_unblock_sweep(PARROT_INTERP);

/* END gc prototypes */

/* Prototypes for helper functions. */
void raise_gc_event(PARROT_INTERP, Parrot_Interp supervised, STRING *group, PMC *data);
PMC *get_gc_funcs(PARROT_INTERP, STRING *name);
void build_gc_func_hash(PARROT_INTERP, Hash *instr_hash, Hash *orig_hash, Hash *entry_hash,
                        InstrumentGC_Subsystem *gc_instr, GC_Subsystem *gc_orig);

pmclass InstrumentGC auto_attrs dynpmc group instrument_group  {
    ATTR PMC                           *instrument;
    ATTR struct GC_Subsystem           *gc_original;
    ATTR struct InstrumentGC_Subsystem *gc_instrumented;
    ATTR Hash                          *stub_hash;
    ATTR Hash                          *original_hash;
    ATTR Hash                          *entry_hash;
    ATTR PMC                           *hook_count;

/*

=item C<void init()>

Throws an exception. InstrumentGC must init with an Instrument pmc.

=cut

*/

    VTABLE void init() {
        /* Not supposed to be init on its own. */
        Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                    "InstrumentGC should be instantiated with initpmc instead.");
    }

/*

=item C<void init_pmc(PMC *instrument)>

Initialises and prepares the supervised interpreter for GC instrumenting.

=cut

*/

    VTABLE void init_pmc(PMC *instrument) {
        Parrot_InstrumentGC_attributes * const attr = PARROT_INSTRUMENTGC(SELF);
        Parrot_Interp supervised;

        GETATTR_Instrument_supervised(INTERP, instrument, supervised);

        attr->instrument      = instrument;
        attr->gc_original     = supervised->gc_sys;
        attr->gc_instrumented = mem_gc_allocate_zeroed_typed(INTERP, InstrumentGC_Subsystem);
        attr->hook_count      = Parrot_pmc_new(INTERP, enum_class_Hash);

        /* Initiliase the instrumented gc_sys with the original values. */
        attr->gc_instrumented->instrument_gc = SELF;
        attr->gc_instrumented->supervisor    = INTERP;

        /* Set the gc_sys of the supervised to the instrumented gc_sys. */
        mem_copy_n_typed(attr->gc_instrumented, attr->gc_original, 1, GC_Subsystem);
        supervised->gc_sys = (GC_Subsystem *) attr->gc_instrumented;

        /* Initialise the hashes. */
        attr->stub_hash     = parrot_new_hash(INTERP);
        attr->original_hash = parrot_new_hash(INTERP);
        attr->entry_hash    = parrot_new_hash(INTERP);
        build_gc_func_hash(INTERP, attr->stub_hash, attr->original_hash, attr->entry_hash,
                           attr->gc_instrumented, attr->gc_original);

        PObj_custom_destroy_SET(SELF);
    }

/*

=item C<void destroy()>

Performs cleanup for InstrumentGC attributes.

=cut

*/

    VTABLE void destroy() {
        Parrot_InstrumentGC_attributes * const attr = PARROT_INSTRUMENTGC(SELF);

        /* Free the hashes. */
        parrot_hash_destroy(INTERP, attr->stub_hash);
        parrot_hash_destroy(INTERP, attr->original_hash);
        parrot_hash_destroy(INTERP, attr->entry_hash);

        /* Free gc_original. gc_instrumented will be freed when
           supervised is killed. */
        mem_gc_free(INTERP, attr->gc_original);
    }

/*

=item C<void insert_gc_hook(STRING *name)>

Inserts the stub function for the given GC entry given by name.
If name denotes a group (allocate, reallocate, free, administration),
inserts stubs for all functions in that group.

=cut

*/

    METHOD insert_gc_hook(STRING *name) {
        Parrot_InstrumentGC_attributes * const attr = PARROT_INSTRUMENTGC(SELF);
        PMC *list;
        PMC *iter;
        (PMC *list) = PCCINVOKE(INTERP, SELF, "get_hook_list", STRING *name);

        iter = VTABLE_get_iter(INTERP, list);
        while (VTABLE_get_bool(INTERP, iter)) {
            INTVAL count;
            PMC *item_pmc = VTABLE_shift_pmc(INTERP, iter);
            STRING *item  = VTABLE_get_string(INTERP, item_pmc);
            size_t **entry, *func;

            /* Check if the entry has already been instrumented. */
            count = VTABLE_get_integer_keyed_str(INTERP, attr->hook_count, item);
            if (count == 0) {
                /* Replace the entry with the stub. */
                entry = (size_t **) parrot_hash_get(INTERP, attr->entry_hash, item);
                func  = (size_t *)  parrot_hash_get(INTERP, attr->stub_hash, item);
                if (entry == NULL || func == NULL) {
                    Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                                "Unknown GC function: %Ss", item);
                }
                *entry = func;
            }

            /* Update the count. */
            count++;
            VTABLE_set_integer_keyed_str(INTERP, attr->hook_count, item, count);
        }
    }

/*

=item C<void remove_gc_hook(STRING *name)>

Removes the stub function for the given GC entry given by name.
If name denotes a group (allocate, reallocate, free, administration),
removes stubs for all functions in that group.

=cut

*/

    METHOD remove_gc_hook(STRING *name) {
        Parrot_InstrumentGC_attributes * const attr = PARROT_INSTRUMENTGC(SELF);
        PMC *list;
        PMC *iter;
        GC_Subsystem           *orig  = attr->gc_original;
        InstrumentGC_Subsystem *instr = attr->gc_instrumented;
        (PMC *list) = PCCINVOKE(INTERP, SELF, "get_hook_list", STRING *name);

        iter = VTABLE_get_iter(INTERP, list);
        while (VTABLE_get_bool(INTERP, iter)) {
            INTVAL count;
            PMC *item_pmc = VTABLE_shift_pmc(INTERP, iter);
            STRING *item  = VTABLE_get_string(INTERP, item_pmc);
            size_t **entry, *func;

            /* Only remove the stub if request count == 1 => Last request. */
            count = VTABLE_get_integer_keyed_str(INTERP, attr->hook_count, item);
            if (count <= 0) {
                /* Tried to remove 1 time too many. */
                Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                            "GC function %Ss is not instrumented.", item);
            }
            else if (count == 1) {
                /* Simply replace the stub with the original entry. */
                entry = (size_t **) parrot_hash_get(INTERP, attr->entry_hash, item);
                func  = (size_t *)  parrot_hash_get(INTERP, attr->original_hash, item);
                if (entry == NULL || func == NULL) {
                    Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                                "Unknown GC function: %Ss", item);
                }
                *entry = func;
            }

            /* Update the count. */
            count--;
            VTABLE_set_integer_keyed_str(INTERP, attr->hook_count, item, count);
        }
    }

/*

=item C<PMC* get_instrumented_list()>

Returns a ResizableStringArray PMC filled with
the names of the gc entries that has been instrumented.

=cut

*/

    METHOD get_instrumented_list() {
        PMC *ret = Parrot_pmc_new(INTERP, enum_class_ResizableStringArray);
        PMC *iter, *hook_hash;

        GETATTR_InstrumentGC_hook_count(INTERP, SELF, hook_hash);
        iter = VTABLE_get_iter(INTERP, hook_hash);

        while (VTABLE_get_bool(INTERP, iter)) {
            PMC *key     = VTABLE_shift_pmc(INTERP, iter);
            INTVAL count = VTABLE_get_integer_keyed(INTERP, hook_hash, key);
            if (count > 0) {
                VTABLE_push_pmc(INTERP, ret, key);
            }
        }

        RETURN(PMC *ret);
    }

/*

=item C<PMC* get_hook_list(STRING *name)>

Returns a ResizableStringArray PMC filled with
the names of the gc entries to instrument.

=cut

*/

    METHOD get_hook_list(STRING *name) {
        PMC *list;

        list = Parrot_pmc_new(INTERP, enum_class_ResizableStringArray);

        /* BEGIN gc groupings */
        if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "free"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "free_pmc_header"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "free_string_header"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "free_bufferlike_header"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "free_pmc_attributes"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "free_fixed_size_storage"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "free_memory_chunk"));
        }
        else if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "administration"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "finalize_gc_system"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "destroy_child_interp"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "do_gc_mark"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "compact_string_pool"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "mark_special"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "pmc_needs_early_collection"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "init_pool"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "block_mark"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "unblock_mark"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "block_sweep"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "unblock_sweep"));
        }
        else if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "allocate"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "allocate_pmc_header"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "allocate_string_header"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "allocate_bufferlike_header"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "allocate_pmc_attributes"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "allocate_string_storage"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "allocate_buffer_storage"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "allocate_fixed_size_storage"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "allocate_memory_chunk"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "allocate_memory_chunk_with_interior_pointers"));
        }
        else if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "reallocate"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "reallocate_string_storage"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "reallocate_buffer_storage"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "reallocate_memory_chunk"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "reallocate_memory_chunk_with_interior_pointers"));
        }

        /* END gc groupings */
        else {
            /* Ensure that name is the name of a hook before pushing it in. */
            size_t *check;
            Hash *stub_hash;

            GETATTR_InstrumentGC_stub_hash(INTERP, SELF, stub_hash);
            check = (size_t *) parrot_hash_get(INTERP, stub_hash, name);
            if (check == NULL) {
                Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                            "Unknown GC function: %Ss", name);
            }

            VTABLE_push_string(INTERP, list, name);
        }

        RETURN(PMC *list);
    }

}

/*
 * Stub Functions
 * The following stub functions map to the corresponding GC functions.
 * It will:
 * 1. Call the GC function.
 * 2. Gather the data for raising the event.
 * 3. Raise an event denoting that the function has been accessed.
 */

/* BEGIN gc stubs */
void  stub_finalize_gc_system(Parrot_Interp interp) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->finalize_gc_system(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "finalize_gc_system"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_destroy_child_interp(Interp* interp, Interp* child_interp) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->destroy_child_interp(interp, child_interp);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, child_interp);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "destroy_child_interp"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_do_gc_mark(Parrot_Interp interp, UINTVAL flags) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->do_gc_mark(interp, flags);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, flags);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "do_gc_mark"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_compact_string_pool(Parrot_Interp interp) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->compact_string_pool(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "compact_string_pool"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_mark_special(Parrot_Interp interp, PMC* stub_var1) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->mark_special(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "mark_special"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_pmc_needs_early_collection(Parrot_Interp interp, PMC* stub_var1) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->pmc_needs_early_collection(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "pmc_needs_early_collection"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_init_pool(Parrot_Interp interp, struct Fixed_Size_Pool* stub_var1) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->init_pool(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "init_pool"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

PMC*  stub_allocate_pmc_header(Parrot_Interp interp, UINTVAL flags) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    PMC*  ret;

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    ret = gc_orig->allocate_pmc_header(interp, flags);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, flags);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_pmc_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void  stub_free_pmc_header(Parrot_Interp interp, PMC* stub_var1) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->free_pmc_header(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_pmc_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

STRING*  stub_allocate_string_header(Parrot_Interp interp, UINTVAL flags) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    STRING*  ret;

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    ret = gc_orig->allocate_string_header(interp, flags);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, flags);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_string_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void  stub_free_string_header(Parrot_Interp interp, STRING* stub_var1) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->free_string_header(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_string_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

Buffer*  stub_allocate_bufferlike_header(Parrot_Interp interp, size_t size) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    Buffer*  ret;

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    ret = gc_orig->allocate_bufferlike_header(interp, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_bufferlike_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void  stub_free_bufferlike_header(Parrot_Interp interp, Buffer* stub_var1, size_t size) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->free_bufferlike_header(interp, stub_var1, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_bufferlike_header"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

void*  stub_allocate_pmc_attributes(Parrot_Interp interp, PMC* stub_var1) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    ret = gc_orig->allocate_pmc_attributes(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_pmc_attributes"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void  stub_free_pmc_attributes(Parrot_Interp interp, PMC* stub_var1) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->free_pmc_attributes(interp, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_pmc_attributes"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

void  stub_allocate_string_storage(Parrot_Interp interp, STRING* str, size_t size) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->allocate_string_storage(interp, str, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, str);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_string_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return;
}

void  stub_reallocate_string_storage(Parrot_Interp interp, STRING* str, size_t size) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->reallocate_string_storage(interp, str, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, str);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "reallocate_string_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "reallocate"), event_data);

    return;
}

void  stub_allocate_buffer_storage(Parrot_Interp interp, Buffer* buffer, size_t nsize) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->allocate_buffer_storage(interp, buffer, nsize);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, buffer);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, nsize);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_buffer_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return;
}

void  stub_reallocate_buffer_storage(Parrot_Interp interp, Buffer* buffer, size_t newsize) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->reallocate_buffer_storage(interp, buffer, newsize);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, buffer);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, newsize);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "reallocate_buffer_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "reallocate"), event_data);

    return;
}

void*  stub_allocate_fixed_size_storage(Parrot_Interp interp, size_t size) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    ret = gc_orig->allocate_fixed_size_storage(interp, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_fixed_size_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void  stub_free_fixed_size_storage(Parrot_Interp interp, size_t size, void* stub_var1) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->free_fixed_size_storage(interp, size, stub_var1);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, stub_var1);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_fixed_size_storage"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

void*  stub_allocate_memory_chunk(Parrot_Interp interp, size_t size) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    ret = gc_orig->allocate_memory_chunk(interp, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_memory_chunk"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void*  stub_reallocate_memory_chunk(Parrot_Interp interp, void* data, size_t newsize) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    ret = gc_orig->reallocate_memory_chunk(interp, data, newsize);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, data);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, newsize);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "reallocate_memory_chunk"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "reallocate"), event_data);

    return ret;
}

void*  stub_allocate_memory_chunk_with_interior_pointers(Parrot_Interp interp, size_t size) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    ret = gc_orig->allocate_memory_chunk_with_interior_pointers(interp, size);

    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, size);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "allocate_memory_chunk_with_interior_pointers"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "allocate"), event_data);

    return ret;
}

void*  stub_reallocate_memory_chunk_with_interior_pointers(Parrot_Interp interp, void* data,
                                                           size_t oldsize, size_t newsize) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    void*  ret;

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    ret = gc_orig->reallocate_memory_chunk_with_interior_pointers(interp, data, oldsize, newsize);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, data);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, oldsize);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, newsize);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "reallocate_memory_chunk_with_interior_pointers"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "reallocate"), event_data);

    return ret;
}

void  stub_free_memory_chunk(Parrot_Interp interp, void* data) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->free_memory_chunk(interp, data);

    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, data);
    VTABLE_push_pmc(supervisor, params, temp);

    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "free_memory_chunk"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "free"), event_data);

    return;
}

void  stub_block_mark(Parrot_Interp interp) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->block_mark(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "block_mark"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_unblock_mark(Parrot_Interp interp) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->unblock_mark(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "unblock_mark"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_block_sweep(Parrot_Interp interp) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->block_sweep(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "block_sweep"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}

void  stub_unblock_sweep(Parrot_Interp interp) {
    PMC *instr_gc            = ((InstrumentGC_Subsystem *) interp->gc_sys)->instrument_gc;
    Parrot_Interp supervisor = ((InstrumentGC_Subsystem *) interp->gc_sys)->supervisor;
    GC_Subsystem *gc_orig;
    PMC *event_data;
    PMC *temp;
    PMC *params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);

    GETATTR_InstrumentGC_gc_original(supervisor, instr_gc, gc_orig);
    gc_orig->unblock_sweep(interp);


    event_data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_string_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "type"),
        CONST_STRING(supervisor, "unblock_sweep"));
    VTABLE_set_pmc_keyed_str(supervisor, event_data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_gc_event(supervisor, interp, CONST_STRING(supervisor, "administration"), event_data);

    return;
}


/* END gc stubs */

/*
 * Helper functions
 */

/*
 * raise_gc_event: Creates a Task of subtype Instrument::Event::GC::<*>
 *                 and sets its data to the given data, adding file,
 *                 sub, namespace and line information to the data hash.
 */

void raise_gc_event(PARROT_INTERP, Parrot_Interp supervised, STRING *group, PMC *data) {
    PMC *task, *task_hash, *event;
    STRING *event_str;
    Parrot_Context_info info;
    event_str = VTABLE_get_string_keyed_str(interp, data, CONST_STRING(interp, "type"));

    event = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, event, CONST_STRING(interp, "GC"));
    VTABLE_push_string(interp, event, group);
    VTABLE_push_string(interp, event, event_str);

    Parrot_Context_get_info(interp, CURRENT_CONTEXT(supervised), &info);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "file"),      info.file);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "sub"),       info.subname);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "namespace"), info.nsname);
    VTABLE_set_integer_keyed_str(interp, data, CONST_STRING(interp, "line"),      info.line);
    VTABLE_set_pmc_keyed_str(interp, data, CONST_STRING(interp, "event"), event);

    task_hash = Parrot_pmc_new(interp, enum_class_Hash);
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "type"),
                                CONST_STRING(interp, "event"));
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "subtype"),
                                CONST_STRING(interp, "Instrument"));
    VTABLE_set_pmc_keyed_str(interp, task_hash, CONST_STRING(interp, "data"), data);

    task = Parrot_pmc_new_init(interp, enum_class_Task, task_hash);
    Parrot_cx_schedule_task(interp, task);
}

/*
 * build_gc_func_hash: Insert the appropriate values into the given 3 hashes.
 *                     1. instr_hash: name => stub function.
 *                     2. orig_hash : name => original gc function.
 *                     3. entry_hash: name => pointer address in InstrumentGC_Subsystem.
 */

void build_gc_func_hash(PARROT_INTERP,
                        Hash *instr_hash, Hash *orig_hash, Hash *entry_hash,
                        InstrumentGC_Subsystem *gc_instr, GC_Subsystem *gc_orig) {
    /* BEGIN gc mappings */
    /* Build the pointer hash to the stubs. */
        parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "finalize_gc_system"),
        stub_finalize_gc_system);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "destroy_child_interp"),
        stub_destroy_child_interp);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "do_gc_mark"),
        stub_do_gc_mark);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "compact_string_pool"),
        stub_compact_string_pool);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "mark_special"),
        stub_mark_special);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "pmc_needs_early_collection"),
        stub_pmc_needs_early_collection);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "init_pool"),
        stub_init_pool);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_pmc_header"),
        stub_allocate_pmc_header);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_pmc_header"),
        stub_free_pmc_header);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_string_header"),
        stub_allocate_string_header);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_string_header"),
        stub_free_string_header);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_bufferlike_header"),
        stub_allocate_bufferlike_header);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_bufferlike_header"),
        stub_free_bufferlike_header);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_pmc_attributes"),
        stub_allocate_pmc_attributes);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_pmc_attributes"),
        stub_free_pmc_attributes);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_string_storage"),
        stub_allocate_string_storage);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_string_storage"),
        stub_reallocate_string_storage);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_buffer_storage"),
        stub_allocate_buffer_storage);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_buffer_storage"),
        stub_reallocate_buffer_storage);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_fixed_size_storage"),
        stub_allocate_fixed_size_storage);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_fixed_size_storage"),
        stub_free_fixed_size_storage);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_memory_chunk"),
        stub_allocate_memory_chunk);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_memory_chunk"),
        stub_reallocate_memory_chunk);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"),
        stub_allocate_memory_chunk_with_interior_pointers);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"),
        stub_reallocate_memory_chunk_with_interior_pointers);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "free_memory_chunk"),
        stub_free_memory_chunk);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "block_mark"),
        stub_block_mark);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unblock_mark"),
        stub_unblock_mark);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "block_sweep"),
        stub_block_sweep);
     parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unblock_sweep"),
        stub_unblock_sweep);


    /* Build the pointer hash to the original. */
        parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "finalize_gc_system"),
        gc_orig->finalize_gc_system);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "destroy_child_interp"),
        gc_orig->destroy_child_interp);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "do_gc_mark"),
        gc_orig->do_gc_mark);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "compact_string_pool"),
        gc_orig->compact_string_pool);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "mark_special"),
        gc_orig->mark_special);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "pmc_needs_early_collection"),
        gc_orig->pmc_needs_early_collection);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "init_pool"),
        gc_orig->init_pool);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_pmc_header"),
        gc_orig->allocate_pmc_header);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_pmc_header"),
        gc_orig->free_pmc_header);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_string_header"),
        gc_orig->allocate_string_header);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_string_header"),
        gc_orig->free_string_header);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_bufferlike_header"),
        gc_orig->allocate_bufferlike_header);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_bufferlike_header"),
        gc_orig->free_bufferlike_header);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_pmc_attributes"),
        gc_orig->allocate_pmc_attributes);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_pmc_attributes"),
        gc_orig->free_pmc_attributes);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_string_storage"),
        gc_orig->allocate_string_storage);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_string_storage"),
        gc_orig->reallocate_string_storage);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_buffer_storage"),
        gc_orig->allocate_buffer_storage);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_buffer_storage"),
        gc_orig->reallocate_buffer_storage);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_fixed_size_storage"),
        gc_orig->allocate_fixed_size_storage);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_fixed_size_storage"),
        gc_orig->free_fixed_size_storage);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_memory_chunk"),
        gc_orig->allocate_memory_chunk);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_memory_chunk"),
        gc_orig->reallocate_memory_chunk);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"),
        gc_orig->allocate_memory_chunk_with_interior_pointers);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"),
        gc_orig->reallocate_memory_chunk_with_interior_pointers);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "free_memory_chunk"),
        gc_orig->free_memory_chunk);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "block_mark"),
        gc_orig->block_mark);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unblock_mark"),
        gc_orig->unblock_mark);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "block_sweep"),
        gc_orig->block_sweep);
     parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unblock_sweep"),
        gc_orig->unblock_sweep);


    /* Build the pointer hash for name to InstrumentGC_Subsystem entry. */
        parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "finalize_gc_system"),
        &(gc_instr->finalize_gc_system));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "destroy_child_interp"),
        &(gc_instr->destroy_child_interp));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "do_gc_mark"),
        &(gc_instr->do_gc_mark));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "compact_string_pool"),
        &(gc_instr->compact_string_pool));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "mark_special"),
        &(gc_instr->mark_special));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "pmc_needs_early_collection"),
        &(gc_instr->pmc_needs_early_collection));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "init_pool"),
        &(gc_instr->init_pool));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "allocate_pmc_header"),
        &(gc_instr->allocate_pmc_header));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "free_pmc_header"),
        &(gc_instr->free_pmc_header));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "allocate_string_header"),
        &(gc_instr->allocate_string_header));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "free_string_header"),
        &(gc_instr->free_string_header));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "allocate_bufferlike_header"),
        &(gc_instr->allocate_bufferlike_header));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "free_bufferlike_header"),
        &(gc_instr->free_bufferlike_header));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "allocate_pmc_attributes"),
        &(gc_instr->allocate_pmc_attributes));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "free_pmc_attributes"),
        &(gc_instr->free_pmc_attributes));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "allocate_string_storage"),
        &(gc_instr->allocate_string_storage));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "reallocate_string_storage"),
        &(gc_instr->reallocate_string_storage));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "allocate_buffer_storage"),
        &(gc_instr->allocate_buffer_storage));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "reallocate_buffer_storage"),
        &(gc_instr->reallocate_buffer_storage));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "allocate_fixed_size_storage"),
        &(gc_instr->allocate_fixed_size_storage));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "free_fixed_size_storage"),
        &(gc_instr->free_fixed_size_storage));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "allocate_memory_chunk"),
        &(gc_instr->allocate_memory_chunk));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "reallocate_memory_chunk"),
        &(gc_instr->reallocate_memory_chunk));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "allocate_memory_chunk_with_interior_pointers"),
        &(gc_instr->allocate_memory_chunk_with_interior_pointers));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "reallocate_memory_chunk_with_interior_pointers"),
        &(gc_instr->reallocate_memory_chunk_with_interior_pointers));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "free_memory_chunk"),
        &(gc_instr->free_memory_chunk));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "block_mark"),
        &(gc_instr->block_mark));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "unblock_mark"),
        &(gc_instr->unblock_mark));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "block_sweep"),
        &(gc_instr->block_sweep));
     parrot_hash_put(interp, entry_hash,
        CONST_STRING(interp, "unblock_sweep"),
        &(gc_instr->unblock_sweep));


    /* END gc mappings */
}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
