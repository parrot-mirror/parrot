/*
Copyright (C) 2010, Parrot Foundation.
$Id$

=head1 NAME

src/dynpmc/instrumentpmc.pmc - Interface to instrument a PMC's vtable.

=head1 DESCRIPTION

C<InstrumentPMC> is a PMC class that provides an interface to
instrument a PMC.

=head2 Methods


=cut

*/

#include "parrot/parrot.h"

#include "pmc_instrument.h"

/* Stub Prototypes */
static PMC* stub_vtable_absolute(PARROT_INTERP, PMC* pmc, PMC* dest);
static PMC* stub_vtable_add(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static void stub_vtable_add_attribute(PARROT_INTERP, PMC* pmc, STRING* name, PMC* type);
static PMC* stub_vtable_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static PMC* stub_vtable_add_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static void stub_vtable_add_method(PARROT_INTERP, PMC* pmc, STRING* method_name, PMC* sub_pmc);
static void stub_vtable_add_parent(PARROT_INTERP, PMC* pmc, PMC* parent);
static void stub_vtable_add_role(PARROT_INTERP, PMC* pmc, PMC* role);
static void stub_vtable_add_vtable_override(PARROT_INTERP, PMC* pmc,
                                            STRING* vtable_name, PMC* sub_pmc);
static void stub_vtable_assign_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_assign_string_native(PARROT_INTERP, PMC* pmc, STRING* value);
static INTVAL stub_vtable_can(PARROT_INTERP, PMC* pmc, STRING* method);
static PMC* stub_vtable_clone(PARROT_INTERP, PMC* pmc);
static PMC* stub_vtable_clone_pmc(PARROT_INTERP, PMC* pmc, PMC* args);
static INTVAL stub_vtable_cmp(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_vtable_cmp_num(PARROT_INTERP, PMC* pmc, PMC* value);
static PMC* stub_vtable_cmp_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_vtable_cmp_string(PARROT_INTERP, PMC* pmc, PMC* value);
static PMC* stub_vtable_concatenate(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_vtable_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value, PMC* dest);
static void stub_vtable_decrement(PARROT_INTERP, PMC* pmc);
static INTVAL stub_vtable_defined(PARROT_INTERP, PMC* pmc);
static INTVAL stub_vtable_defined_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static INTVAL stub_vtable_defined_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static INTVAL stub_vtable_defined_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static void stub_vtable_delete_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static void stub_vtable_delete_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static void stub_vtable_delete_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static void stub_vtable_delprop(PARROT_INTERP, PMC* pmc, STRING* key);
static void stub_vtable_destroy(PARROT_INTERP, PMC* pmc);
static PMC* stub_vtable_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_vtable_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static PMC* stub_vtable_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static INTVAL stub_vtable_does(PARROT_INTERP, PMC* pmc, STRING* role);
static INTVAL stub_vtable_does_pmc(PARROT_INTERP, PMC* pmc, PMC* role);
static INTVAL stub_vtable_elements(PARROT_INTERP, PMC* pmc);
static INTVAL stub_vtable_exists_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static INTVAL stub_vtable_exists_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static INTVAL stub_vtable_exists_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static PMC* stub_vtable_find_method(PARROT_INTERP, PMC* pmc, STRING* method_name);
static PMC* stub_vtable_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_vtable_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static PMC* stub_vtable_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static void stub_vtable_freeze(PARROT_INTERP, PMC* pmc, PMC* info);
static PMC* stub_vtable_get_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx);
static PMC* stub_vtable_get_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx);
static INTVAL stub_vtable_get_bool(PARROT_INTERP, PMC* pmc);
static PMC* stub_vtable_get_class(PARROT_INTERP, PMC* pmc);
static INTVAL stub_vtable_get_integer(PARROT_INTERP, PMC* pmc);
static INTVAL stub_vtable_get_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static INTVAL stub_vtable_get_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static INTVAL stub_vtable_get_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static PMC* stub_vtable_get_iter(PARROT_INTERP, PMC* pmc);
static PMC* stub_vtable_get_namespace(PARROT_INTERP, PMC* pmc);
static FLOATVAL stub_vtable_get_number(PARROT_INTERP, PMC* pmc);
static FLOATVAL stub_vtable_get_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static FLOATVAL stub_vtable_get_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static FLOATVAL stub_vtable_get_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static PMC* stub_vtable_get_pmc(PARROT_INTERP, PMC* pmc);
static PMC* stub_vtable_get_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static PMC* stub_vtable_get_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static PMC* stub_vtable_get_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static void* stub_vtable_get_pointer(PARROT_INTERP, PMC* pmc);
static void* stub_vtable_get_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static void* stub_vtable_get_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static void* stub_vtable_get_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static STRING* stub_vtable_get_repr(PARROT_INTERP, PMC* pmc);
static STRING* stub_vtable_get_string(PARROT_INTERP, PMC* pmc);
static STRING* stub_vtable_get_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static STRING* stub_vtable_get_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static STRING* stub_vtable_get_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static PMC* stub_vtable_getprop(PARROT_INTERP, PMC* pmc, STRING* key);
static PMC* stub_vtable_getprops(PARROT_INTERP, PMC* pmc);
static INTVAL stub_vtable_hashvalue(PARROT_INTERP, PMC* pmc);
static void stub_vtable_i_absolute(PARROT_INTERP, PMC* pmc);
static void stub_vtable_i_add(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_i_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_vtable_i_add_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_vtable_i_concatenate(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_i_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_vtable_i_divide(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_i_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_vtable_i_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_vtable_i_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_i_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_vtable_i_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_vtable_i_logical_not(PARROT_INTERP, PMC* pmc);
static void stub_vtable_i_modulus(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_i_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_vtable_i_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_vtable_i_multiply(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_i_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_vtable_i_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_vtable_i_neg(PARROT_INTERP, PMC* pmc);
static void stub_vtable_i_repeat(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_i_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_vtable_i_subtract(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_i_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_vtable_i_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_vtable_increment(PARROT_INTERP, PMC* pmc);
static void stub_vtable_init(PARROT_INTERP, PMC* pmc);
static void stub_vtable_init_int(PARROT_INTERP, PMC* pmc, INTVAL initializer);
static void stub_vtable_init_pmc(PARROT_INTERP, PMC* pmc, PMC* initializer);
static PMC* stub_vtable_inspect(PARROT_INTERP, PMC* pmc);
static PMC* stub_vtable_inspect_str(PARROT_INTERP, PMC* pmc, STRING* what);
static PMC* stub_vtable_instantiate(PARROT_INTERP, PMC* pmc, PMC* sig);
static opcode_t* stub_vtable_invoke(PARROT_INTERP, PMC* pmc, void* next);
static INTVAL stub_vtable_is_equal(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_vtable_is_equal_num(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_vtable_is_equal_string(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_vtable_is_same(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_vtable_isa(PARROT_INTERP, PMC* pmc, STRING* _class);
static INTVAL stub_vtable_isa_pmc(PARROT_INTERP, PMC* pmc, PMC* _class);
static PMC* stub_vtable_logical_and(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_vtable_logical_not(PARROT_INTERP, PMC* pmc, PMC* dest);
static PMC* stub_vtable_logical_or(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_vtable_logical_xor(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static void stub_vtable_mark(PARROT_INTERP, PMC* pmc);
static PMC* stub_vtable_modulus(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_vtable_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static PMC* stub_vtable_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static void stub_vtable_morph(PARROT_INTERP, PMC* pmc, PMC* type);
static PMC* stub_vtable_multiply(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_vtable_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static PMC* stub_vtable_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static STRING* stub_vtable_name(PARROT_INTERP, PMC* pmc);
static PMC* stub_vtable_neg(PARROT_INTERP, PMC* pmc, PMC* dest);
static FLOATVAL stub_vtable_pop_float(PARROT_INTERP, PMC* pmc);
static INTVAL stub_vtable_pop_integer(PARROT_INTERP, PMC* pmc);
static PMC* stub_vtable_pop_pmc(PARROT_INTERP, PMC* pmc);
static STRING* stub_vtable_pop_string(PARROT_INTERP, PMC* pmc);
static void stub_vtable_push_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_vtable_push_integer(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_vtable_push_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_push_string(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_vtable_remove_attribute(PARROT_INTERP, PMC* pmc, STRING* name);
static void stub_vtable_remove_method(PARROT_INTERP, PMC* pmc, STRING* method_name);
static void stub_vtable_remove_parent(PARROT_INTERP, PMC* pmc, PMC* parent);
static void stub_vtable_remove_role(PARROT_INTERP, PMC* pmc, PMC* role);
static void stub_vtable_remove_vtable_override(PARROT_INTERP, PMC* pmc, STRING* vtable_name);
static PMC* stub_vtable_repeat(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_vtable_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static void stub_vtable_set_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx, PMC* value);
static void stub_vtable_set_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx, PMC* value);
static void stub_vtable_set_bool(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_vtable_set_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, INTVAL value);
static void stub_vtable_set_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, INTVAL value);
static void stub_vtable_set_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, INTVAL value);
static void stub_vtable_set_integer_native(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_vtable_set_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key, FLOATVAL value);
static void stub_vtable_set_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, FLOATVAL value);
static void stub_vtable_set_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, FLOATVAL value);
static void stub_vtable_set_number_native(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_vtable_set_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_set_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key, PMC* value);
static void stub_vtable_set_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, PMC* value);
static void stub_vtable_set_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value);
static void stub_vtable_set_pointer(PARROT_INTERP, PMC* pmc, void* value);
static void stub_vtable_set_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, void* value);
static void stub_vtable_set_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, void* value);
static void stub_vtable_set_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, void* value);
static void stub_vtable_set_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* value);
static void stub_vtable_set_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, STRING* value);
static void stub_vtable_set_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, STRING* value);
static void stub_vtable_set_string_native(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_vtable_setprop(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value);
static void stub_vtable_share(PARROT_INTERP, PMC* pmc);
static PMC* stub_vtable_share_ro(PARROT_INTERP, PMC* pmc);
static FLOATVAL stub_vtable_shift_float(PARROT_INTERP, PMC* pmc);
static INTVAL stub_vtable_shift_integer(PARROT_INTERP, PMC* pmc);
static PMC* stub_vtable_shift_pmc(PARROT_INTERP, PMC* pmc);
static STRING* stub_vtable_shift_string(PARROT_INTERP, PMC* pmc);
static void stub_vtable_splice(PARROT_INTERP, PMC* pmc, PMC* value, INTVAL offset, INTVAL count);
static void stub_vtable_substr(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length, PMC* dest);
static STRING* stub_vtable_substr_str(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length);
static PMC* stub_vtable_subtract(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_vtable_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static PMC* stub_vtable_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static void stub_vtable_thaw(PARROT_INTERP, PMC* pmc, PMC* info);
static void stub_vtable_thawfinish(PARROT_INTERP, PMC* pmc, PMC* info);
static INTVAL stub_vtable_type(PARROT_INTERP, PMC* pmc);
static void stub_vtable_unshift_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_vtable_unshift_integer(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_vtable_unshift_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_vtable_unshift_string(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_vtable_visit(PARROT_INTERP, PMC* pmc, PMC* info);

/* Helper Prototypes. */
void raise_vtable_event(PARROT_INTERP, Parrot_Interp supervised, PMC *pmc, PMC *data, STRING *type);
void build_vtable_hashes(PARROT_INTERP, Hash *orig, Hash *instr, Hash *stub,
                         _vtable *vtable, _vtable *instr_vtable);

/* Test */
static Hash *Instrument_Vtable_Entries = NULL;
static Hash *Instrument_Vtable_Stubs   = NULL;

pmclass InstrumentVtable auto_attrs dynpmc group instrument_group {
    ATTR Parrot_Interp   supervisor;
    ATTR PMC            *instrument;
    ATTR INTVAL          class_index;
    ATTR struct _vtable *original_vtable;
    ATTR struct _vtable *instrumented_vtable;
    ATTR Hash           *original_hash;
    ATTR Hash           *instrumented_hash;

    VTABLE void init() {
        /* Not supposed to be init on its own. */
        Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                   "InstrumentVtable should be instantiated with initpmc instead.");
    }

    VTABLE void init_pmc(PMC *instrument) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);

        attr->supervisor          = INTERP;
        attr->instrument          = instrument;
        attr->original_vtable     = NULL;
        attr->instrumented_vtable = NULL;
        attr->original_hash        = parrot_new_pointer_hash(INTERP);
        attr->instrumented_hash   = parrot_new_pointer_hash(INTERP);

        /* Initialise the Instrumented Vtable registry if needed. */
        if (Instrument_Vtable_Entries == NULL) {
            Instrument_Vtable_Entries = parrot_new_pointer_hash(INTERP);
            Instrument_Vtable_Stubs   = parrot_new_pointer_hash(INTERP);
        }

        PObj_custom_destroy_SET(SELF);
    }

    VTABLE void destroy() {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);

        /* Remove entry from Instrument_Vtable_Entries. */
        parrot_hash_delete(INTERP, Instrument_Vtable_Entries, attr->instrumented_vtable);

        /* Delete the hash if the size is 0. */
        if (parrot_hash_size(INTERP, Instrument_Vtable_Entries) == 0) {
            parrot_hash_destroy(INTERP, Instrument_Vtable_Entries);
            parrot_hash_destroy(INTERP, Instrument_Vtable_Stubs);
            Instrument_Vtable_Entries = NULL;
            Instrument_Vtable_Stubs   = NULL;
        }
    }

    METHOD attach_to_class(STRING *classname) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        Parrot_Interp supervised;

        GETATTR_Instrument_supervised(INTERP, attr->instrument, supervised);

        attr->class_index     = Parrot_pmc_get_type_str(supervised, classname);
        attr->original_vtable = supervised->vtables[attr->class_index];

        /* Prepare the class's vtable for instrumentation. */
        attr->instrumented_vtable = mem_gc_allocate_zeroed_typed(supervised, _vtable);
        mem_copy_n_typed(attr->instrumented_vtable, attr->original_vtable, 1, _vtable);
        supervised->vtables[attr->class_index] = attr->instrumented_vtable;

        /* Register the instrumented vtable to SELF. */
        parrot_hash_put(INTERP, Instrument_Vtable_Entries, attr->instrumented_vtable, SELF);

        /* Build the vtable hashes, passing a sample vtable to build the offsets. */
        build_vtable_hashes(INTERP,
                            attr->original_hash, attr->instrumented_hash,
                            Instrument_Vtable_Stubs,
                            attr->original_vtable, attr->instrumented_vtable);
    }

    METHOD insert_vtable_hook(STRING *vtable_str) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        STRING *key;
        char *con_string;
        size_t **instr, *stub;

        /* Convert vtable_str to a constant STRING so that it can be used as a key. */
        con_string = Parrot_str_to_cstring(INTERP, vtable_str);
        key        = CONST_STRING(INTERP, con_string);
        Parrot_free_cstring(con_string);

        /* Modify the entry. */
        instr  = (size_t **) parrot_hash_get(INTERP, attr->instrumented_hash, key);
        stub   = (size_t *)  parrot_hash_get(INTERP, Instrument_Vtable_Stubs, key);
        if (instr == NULL || stub ==  NULL) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                        "Unknown VTABLE entry: %Ss", vtable_str);
        }
        *instr = stub;
    }

}

/*
 * Helpers
 */

void raise_vtable_event(PARROT_INTERP, Parrot_Interp supervised,
                        PMC *pmc, PMC *data, STRING *type) {
    Parrot_Context_info info;
    PMC *task_hash, *task;

    /* Get the current context info. */
    Parrot_Context_get_info(interp, CURRENT_CONTEXT(supervised), &info);

    /* Populate data with common items. */
    VTABLE_set_string_keyed_str(interp, data,
                                CONST_STRING(interp, "event_category"),
                                CONST_STRING(interp, "Class"));
    VTABLE_set_string_keyed_str(interp, data,
                                CONST_STRING(interp, "event_subtype"),
                                VTABLE_name(supervised, pmc));
    VTABLE_set_string_keyed_str(interp, data,
                                CONST_STRING(interp, "event_fulltype"),
                                type);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "file"),      info.file);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "sub"),       info.subname);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "namespace"), info.nsname);
    VTABLE_set_integer_keyed_str(interp, data, CONST_STRING(interp, "line"),      info.line);

    /* Raise the event. */
    task_hash = Parrot_pmc_new(interp, enum_class_Hash);
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "type"),
                                CONST_STRING(interp, "event"));
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "subtype"),
                                CONST_STRING(interp, "Instrument"));
    VTABLE_set_pmc_keyed_str(interp, task_hash, CONST_STRING(interp, "data"), data);

    task = Parrot_pmc_new_init(interp, enum_class_Task, task_hash);
    Parrot_cx_schedule_task(interp, task);
}

void build_vtable_hashes(PARROT_INTERP, Hash *orig, Hash *instr, Hash *stub,
                         _vtable *orig_vtable, _vtable *instr_vtable) {
    /* Build mappings for name -> original function.vtable entry */
    parrot_hash_put(interp, orig, CONST_STRING(interp, "absolute"),
                    orig_vtable->absolute);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "add"),
                    orig_vtable->add);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "add_attribute"),
                    orig_vtable->add_attribute);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "add_float"),
                    orig_vtable->add_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "add_int"),
                    orig_vtable->add_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "add_method"),
                    orig_vtable->add_method);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "add_parent"),
                    orig_vtable->add_parent);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "add_role"),
                    orig_vtable->add_role);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "add_vtable_override"),
                    orig_vtable->add_vtable_override);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "assign_pmc"),
                    orig_vtable->assign_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "assign_string_native"),
                    orig_vtable->assign_string_native);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "can"),
                    orig_vtable->can);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "clone"),
                    orig_vtable->clone);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "clone_pmc"),
                    orig_vtable->clone_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "cmp"),
                    orig_vtable->cmp);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "cmp_num"),
                    orig_vtable->cmp_num);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "cmp_pmc"),
                    orig_vtable->cmp_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "cmp_string"),
                    orig_vtable->cmp_string);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "concatenate"),
                    orig_vtable->concatenate);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "concatenate_str"),
                    orig_vtable->concatenate_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "decrement"),
                    orig_vtable->decrement);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "defined"),
                    orig_vtable->defined);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "defined_keyed"),
                    orig_vtable->defined_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "defined_keyed_int"),
                    orig_vtable->defined_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "defined_keyed_str"),
                    orig_vtable->defined_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "delete_keyed"),
                    orig_vtable->delete_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "delete_keyed_int"),
                    orig_vtable->delete_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "delete_keyed_str"),
                    orig_vtable->delete_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "delprop"),
                    orig_vtable->delprop);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "destroy"),
                    orig_vtable->destroy);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "divide"),
                    orig_vtable->divide);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "divide_float"),
                    orig_vtable->divide_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "divide_int"),
                    orig_vtable->divide_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "does"),
                    orig_vtable->does);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "does_pmc"),
                    orig_vtable->does_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "elements"),
                    orig_vtable->elements);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "exists_keyed"),
                    orig_vtable->exists_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "exists_keyed_int"),
                    orig_vtable->exists_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "exists_keyed_str"),
                    orig_vtable->exists_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "find_method"),
                    orig_vtable->find_method);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "floor_divide"),
                    orig_vtable->floor_divide);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "floor_divide_float"),
                    orig_vtable->floor_divide_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "floor_divide_int"),
                    orig_vtable->floor_divide_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "freeze"),
                    orig_vtable->freeze);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_attr_keyed"),
                    orig_vtable->get_attr_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_attr_str"),
                    orig_vtable->get_attr_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_bool"),
                    orig_vtable->get_bool);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_class"),
                    orig_vtable->get_class);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_integer"),
                    orig_vtable->get_integer);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_integer_keyed"),
                    orig_vtable->get_integer_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_integer_keyed_int"),
                    orig_vtable->get_integer_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_integer_keyed_str"),
                    orig_vtable->get_integer_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_iter"),
                    orig_vtable->get_iter);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_namespace"),
                    orig_vtable->get_namespace);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_number"),
                    orig_vtable->get_number);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_number_keyed"),
                    orig_vtable->get_number_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_number_keyed_int"),
                    orig_vtable->get_number_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_number_keyed_str"),
                    orig_vtable->get_number_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pmc"),
                    orig_vtable->get_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pmc_keyed"),
                    orig_vtable->get_pmc_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pmc_keyed_int"),
                    orig_vtable->get_pmc_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pmc_keyed_str"),
                    orig_vtable->get_pmc_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pointer"),
                    orig_vtable->get_pointer);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pointer_keyed"),
                    orig_vtable->get_pointer_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pointer_keyed_int"),
                    orig_vtable->get_pointer_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pointer_keyed_str"),
                    orig_vtable->get_pointer_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_repr"),
                    orig_vtable->get_repr);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_string"),
                    orig_vtable->get_string);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_string_keyed"),
                    orig_vtable->get_string_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_string_keyed_int"),
                    orig_vtable->get_string_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "get_string_keyed_str"),
                    orig_vtable->get_string_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "getprop"),
                    orig_vtable->getprop);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "getprops"),
                    orig_vtable->getprops);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "hashvalue"),
                    orig_vtable->hashvalue);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_absolute"),
                    orig_vtable->i_absolute);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_add"),
                    orig_vtable->i_add);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_add_float"),
                    orig_vtable->i_add_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_add_int"),
                    orig_vtable->i_add_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_concatenate"),
                    orig_vtable->i_concatenate);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_concatenate_str"),
                    orig_vtable->i_concatenate_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_divide"),
                    orig_vtable->i_divide);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_divide_float"),
                    orig_vtable->i_divide_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_divide_int"),
                    orig_vtable->i_divide_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_floor_divide"),
                    orig_vtable->i_floor_divide);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_floor_divide_float"),
                    orig_vtable->i_floor_divide_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_floor_divide_int"),
                    orig_vtable->i_floor_divide_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_logical_not"),
                    orig_vtable->i_logical_not);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_modulus"),
                    orig_vtable->i_modulus);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_modulus_float"),
                    orig_vtable->i_modulus_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_modulus_int"),
                    orig_vtable->i_modulus_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_multiply"),
                    orig_vtable->i_multiply);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_multiply_float"),
                    orig_vtable->i_multiply_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_multiply_int"),
                    orig_vtable->i_multiply_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_neg"),
                    orig_vtable->i_neg);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_repeat"),
                    orig_vtable->i_repeat);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_repeat_int"),
                    orig_vtable->i_repeat_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_subtract"),
                    orig_vtable->i_subtract);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_subtract_float"),
                    orig_vtable->i_subtract_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "i_subtract_int"),
                    orig_vtable->i_subtract_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "increment"),
                    orig_vtable->increment);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "init"),
                    orig_vtable->init);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "init_int"),
                    orig_vtable->init_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "init_pmc"),
                    orig_vtable->init_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "inspect"),
                    orig_vtable->inspect);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "inspect_str"),
                    orig_vtable->inspect_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "instantiate"),
                    orig_vtable->instantiate);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "invoke"),
                    orig_vtable->invoke);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "is_equal"),
                    orig_vtable->is_equal);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "is_equal_num"),
                    orig_vtable->is_equal_num);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "is_equal_string"),
                    orig_vtable->is_equal_string);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "is_same"),
                    orig_vtable->is_same);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "isa"),
                    orig_vtable->isa);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "isa_pmc"),
                    orig_vtable->isa_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "logical_and"),
                    orig_vtable->logical_and);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "logical_not"),
                    orig_vtable->logical_not);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "logical_or"),
                    orig_vtable->logical_or);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "logical_xor"),
                    orig_vtable->logical_xor);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "mark"),
                    orig_vtable->mark);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "modulus"),
                    orig_vtable->modulus);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "modulus_float"),
                    orig_vtable->modulus_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "modulus_int"),
                    orig_vtable->modulus_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "morph"),
                    orig_vtable->morph);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "multiply"),
                    orig_vtable->multiply);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "multiply_float"),
                    orig_vtable->multiply_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "multiply_int"),
                    orig_vtable->multiply_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "name"),
                    orig_vtable->name);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "neg"),
                    orig_vtable->neg);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "pop_float"),
                    orig_vtable->pop_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "pop_integer"),
                    orig_vtable->pop_integer);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "pop_pmc"),
                    orig_vtable->pop_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "pop_string"),
                    orig_vtable->pop_string);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "push_float"),
                    orig_vtable->push_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "push_integer"),
                    orig_vtable->push_integer);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "push_pmc"),
                    orig_vtable->push_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "push_string"),
                    orig_vtable->push_string);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "remove_attribute"),
                    orig_vtable->remove_attribute);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "remove_method"),
                    orig_vtable->remove_method);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "remove_parent"),
                    orig_vtable->remove_parent);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "remove_role"),
                    orig_vtable->remove_role);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "remove_vtable_override"),
                    orig_vtable->remove_vtable_override);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "repeat"),
                    orig_vtable->repeat);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "repeat_int"),
                    orig_vtable->repeat_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_attr_keyed"),
                    orig_vtable->set_attr_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_attr_str"),
                    orig_vtable->set_attr_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_bool"),
                    orig_vtable->set_bool);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_integer_keyed"),
                    orig_vtable->set_integer_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_integer_keyed_int"),
                    orig_vtable->set_integer_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_integer_keyed_str"),
                    orig_vtable->set_integer_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_integer_native"),
                    orig_vtable->set_integer_native);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_number_keyed"),
                    orig_vtable->set_number_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_number_keyed_int"),
                    orig_vtable->set_number_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_number_keyed_str"),
                    orig_vtable->set_number_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_number_native"),
                    orig_vtable->set_number_native);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pmc"),
                    orig_vtable->set_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pmc_keyed"),
                    orig_vtable->set_pmc_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pmc_keyed_int"),
                    orig_vtable->set_pmc_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pmc_keyed_str"),
                    orig_vtable->set_pmc_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pointer"),
                    orig_vtable->set_pointer);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pointer_keyed"),
                    orig_vtable->set_pointer_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pointer_keyed_int"),
                    orig_vtable->set_pointer_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pointer_keyed_str"),
                    orig_vtable->set_pointer_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_string_keyed"),
                    orig_vtable->set_string_keyed);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_string_keyed_int"),
                    orig_vtable->set_string_keyed_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_string_keyed_str"),
                    orig_vtable->set_string_keyed_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "set_string_native"),
                    orig_vtable->set_string_native);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "setprop"),
                    orig_vtable->setprop);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "share"),
                    orig_vtable->share);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "share_ro"),
                    orig_vtable->share_ro);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "shift_float"),
                    orig_vtable->shift_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "shift_integer"),
                    orig_vtable->shift_integer);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "shift_pmc"),
                    orig_vtable->shift_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "shift_string"),
                    orig_vtable->shift_string);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "splice"),
                    orig_vtable->splice);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "substr"),
                    orig_vtable->substr);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "substr_str"),
                    orig_vtable->substr_str);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "subtract"),
                    orig_vtable->subtract);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "subtract_float"),
                    orig_vtable->subtract_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "subtract_int"),
                    orig_vtable->subtract_int);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "thaw"),
                    orig_vtable->thaw);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "thawfinish"),
                    orig_vtable->thawfinish);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "type"),
                    orig_vtable->type);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "unshift_float"),
                    orig_vtable->unshift_float);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "unshift_integer"),
                    orig_vtable->unshift_integer);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "unshift_pmc"),
                    orig_vtable->unshift_pmc);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "unshift_string"),
                    orig_vtable->unshift_string);
    parrot_hash_put(interp, orig, CONST_STRING(interp, "visit"),
                    orig_vtable->visit);

    /* Build mappings for name -> instrumented function.vtable entry. */
    parrot_hash_put(interp, instr, CONST_STRING(interp, "absolute"),
                    &(instr_vtable->absolute));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "add"),
                    &(instr_vtable->add));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "add_attribute"),
                    &(instr_vtable->add_attribute));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "add_float"),
                    &(instr_vtable->add_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "add_int"),
                    &(instr_vtable->add_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "add_method"),
                    &(instr_vtable->add_method));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "add_parent"),
                    &(instr_vtable->add_parent));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "add_role"),
                    &(instr_vtable->add_role));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "add_vtable_override"),
                    &(instr_vtable->add_vtable_override));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "assign_pmc"),
                    &(instr_vtable->assign_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "assign_string_native"),
                    &(instr_vtable->assign_string_native));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "can"),
                    &(instr_vtable->can));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "clone"),
                    &(instr_vtable->clone));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "clone_pmc"),
                    &(instr_vtable->clone_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "cmp"),
                    &(instr_vtable->cmp));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "cmp_num"),
                    &(instr_vtable->cmp_num));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "cmp_pmc"),
                    &(instr_vtable->cmp_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "cmp_string"),
                    &(instr_vtable->cmp_string));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "concatenate"),
                    &(instr_vtable->concatenate));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "concatenate_str"),
                    &(instr_vtable->concatenate_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "decrement"),
                    &(instr_vtable->decrement));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "defined"),
                    &(instr_vtable->defined));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "defined_keyed"),
                    &(instr_vtable->defined_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "defined_keyed_int"),
                    &(instr_vtable->defined_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "defined_keyed_str"),
                    &(instr_vtable->defined_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "delete_keyed"),
                    &(instr_vtable->delete_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "delete_keyed_int"),
                    &(instr_vtable->delete_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "delete_keyed_str"),
                    &(instr_vtable->delete_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "delprop"),
                    &(instr_vtable->delprop));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "destroy"),
                    &(instr_vtable->destroy));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "divide"),
                    &(instr_vtable->divide));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "divide_float"),
                    &(instr_vtable->divide_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "divide_int"),
                    &(instr_vtable->divide_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "does"),
                    &(instr_vtable->does));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "does_pmc"),
                    &(instr_vtable->does_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "elements"),
                    &(instr_vtable->elements));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "exists_keyed"),
                    &(instr_vtable->exists_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "exists_keyed_int"),
                    &(instr_vtable->exists_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "exists_keyed_str"),
                    &(instr_vtable->exists_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "find_method"),
                    &(instr_vtable->find_method));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "floor_divide"),
                    &(instr_vtable->floor_divide));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "floor_divide_float"),
                    &(instr_vtable->floor_divide_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "floor_divide_int"),
                    &(instr_vtable->floor_divide_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "freeze"),
                    &(instr_vtable->freeze));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_attr_keyed"),
                    &(instr_vtable->get_attr_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_attr_str"),
                    &(instr_vtable->get_attr_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_bool"),
                    &(instr_vtable->get_bool));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_class"),
                    &(instr_vtable->get_class));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_integer"),
                    &(instr_vtable->get_integer));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_integer_keyed"),
                    &(instr_vtable->get_integer_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_integer_keyed_int"),
                    &(instr_vtable->get_integer_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_integer_keyed_str"),
                    &(instr_vtable->get_integer_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_iter"),
                    &(instr_vtable->get_iter));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_namespace"),
                    &(instr_vtable->get_namespace));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_number"),
                    &(instr_vtable->get_number));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_number_keyed"),
                    &(instr_vtable->get_number_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_number_keyed_int"),
                    &(instr_vtable->get_number_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_number_keyed_str"),
                    &(instr_vtable->get_number_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pmc"),
                    &(instr_vtable->get_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pmc_keyed"),
                    &(instr_vtable->get_pmc_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pmc_keyed_int"),
                    &(instr_vtable->get_pmc_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pmc_keyed_str"),
                    &(instr_vtable->get_pmc_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pointer"),
                    &(instr_vtable->get_pointer));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pointer_keyed"),
                    &(instr_vtable->get_pointer_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pointer_keyed_int"),
                    &(instr_vtable->get_pointer_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pointer_keyed_str"),
                    &(instr_vtable->get_pointer_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_repr"),
                    &(instr_vtable->get_repr));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_string"),
                    &(instr_vtable->get_string));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_string_keyed"),
                    &(instr_vtable->get_string_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_string_keyed_int"),
                    &(instr_vtable->get_string_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "get_string_keyed_str"),
                    &(instr_vtable->get_string_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "getprop"),
                    &(instr_vtable->getprop));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "getprops"),
                    &(instr_vtable->getprops));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "hashvalue"),
                    &(instr_vtable->hashvalue));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_absolute"),
                    &(instr_vtable->i_absolute));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_add"),
                    &(instr_vtable->i_add));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_add_float"),
                    &(instr_vtable->i_add_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_add_int"),
                    &(instr_vtable->i_add_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_concatenate"),
                    &(instr_vtable->i_concatenate));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_concatenate_str"),
                    &(instr_vtable->i_concatenate_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_divide"),
                    &(instr_vtable->i_divide));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_divide_float"),
                    &(instr_vtable->i_divide_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_divide_int"),
                    &(instr_vtable->i_divide_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_floor_divide"),
                    &(instr_vtable->i_floor_divide));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_floor_divide_float"),
                    &(instr_vtable->i_floor_divide_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_floor_divide_int"),
                    &(instr_vtable->i_floor_divide_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_logical_not"),
                    &(instr_vtable->i_logical_not));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_modulus"),
                    &(instr_vtable->i_modulus));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_modulus_float"),
                    &(instr_vtable->i_modulus_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_modulus_int"),
                    &(instr_vtable->i_modulus_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_multiply"),
                    &(instr_vtable->i_multiply));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_multiply_float"),
                    &(instr_vtable->i_multiply_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_multiply_int"),
                    &(instr_vtable->i_multiply_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_neg"),
                    &(instr_vtable->i_neg));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_repeat"),
                    &(instr_vtable->i_repeat));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_repeat_int"),
                    &(instr_vtable->i_repeat_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_subtract"),
                    &(instr_vtable->i_subtract));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_subtract_float"),
                    &(instr_vtable->i_subtract_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "i_subtract_int"),
                    &(instr_vtable->i_subtract_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "increment"),
                    &(instr_vtable->increment));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "init"),
                    &(instr_vtable->init));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "init_int"),
                    &(instr_vtable->init_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "init_pmc"),
                    &(instr_vtable->init_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "inspect"),
                    &(instr_vtable->inspect));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "inspect_str"),
                    &(instr_vtable->inspect_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "instantiate"),
                    &(instr_vtable->instantiate));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "invoke"),
                    &(instr_vtable->invoke));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "is_equal"),
                    &(instr_vtable->is_equal));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "is_equal_num"),
                    &(instr_vtable->is_equal_num));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "is_equal_string"),
                    &(instr_vtable->is_equal_string));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "is_same"),
                    &(instr_vtable->is_same));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "isa"),
                    &(instr_vtable->isa));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "isa_pmc"),
                    &(instr_vtable->isa_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "logical_and"),
                    &(instr_vtable->logical_and));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "logical_not"),
                    &(instr_vtable->logical_not));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "logical_or"),
                    &(instr_vtable->logical_or));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "logical_xor"),
                    &(instr_vtable->logical_xor));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "mark"),
                    &(instr_vtable->mark));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "modulus"),
                    &(instr_vtable->modulus));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "modulus_float"),
                    &(instr_vtable->modulus_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "modulus_int"),
                    &(instr_vtable->modulus_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "morph"),
                    &(instr_vtable->morph));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "multiply"),
                    &(instr_vtable->multiply));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "multiply_float"),
                    &(instr_vtable->multiply_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "multiply_int"),
                    &(instr_vtable->multiply_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "name"),
                    &(instr_vtable->name));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "neg"),
                    &(instr_vtable->neg));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "pop_float"),
                    &(instr_vtable->pop_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "pop_integer"),
                    &(instr_vtable->pop_integer));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "pop_pmc"),
                    &(instr_vtable->pop_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "pop_string"),
                    &(instr_vtable->pop_string));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "push_float"),
                    &(instr_vtable->push_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "push_integer"),
                    &(instr_vtable->push_integer));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "push_pmc"),
                    &(instr_vtable->push_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "push_string"),
                    &(instr_vtable->push_string));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "remove_attribute"),
                    &(instr_vtable->remove_attribute));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "remove_method"),
                    &(instr_vtable->remove_method));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "remove_parent"),
                    &(instr_vtable->remove_parent));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "remove_role"),
                    &(instr_vtable->remove_role));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "remove_vtable_override"),
                    &(instr_vtable->remove_vtable_override));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "repeat"),
                    &(instr_vtable->repeat));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "repeat_int"),
                    &(instr_vtable->repeat_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_attr_keyed"),
                    &(instr_vtable->set_attr_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_attr_str"),
                    &(instr_vtable->set_attr_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_bool"),
                    &(instr_vtable->set_bool));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_integer_keyed"),
                    &(instr_vtable->set_integer_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_integer_keyed_int"),
                    &(instr_vtable->set_integer_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_integer_keyed_str"),
                    &(instr_vtable->set_integer_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_integer_native"),
                    &(instr_vtable->set_integer_native));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_number_keyed"),
                    &(instr_vtable->set_number_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_number_keyed_int"),
                    &(instr_vtable->set_number_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_number_keyed_str"),
                    &(instr_vtable->set_number_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_number_native"),
                    &(instr_vtable->set_number_native));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pmc"),
                    &(instr_vtable->set_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pmc_keyed"),
                    &(instr_vtable->set_pmc_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pmc_keyed_int"),
                    &(instr_vtable->set_pmc_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pmc_keyed_str"),
                    &(instr_vtable->set_pmc_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pointer"),
                    &(instr_vtable->set_pointer));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pointer_keyed"),
                    &(instr_vtable->set_pointer_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pointer_keyed_int"),
                    &(instr_vtable->set_pointer_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pointer_keyed_str"),
                    &(instr_vtable->set_pointer_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_string_keyed"),
                    &(instr_vtable->set_string_keyed));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_string_keyed_int"),
                    &(instr_vtable->set_string_keyed_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_string_keyed_str"),
                    &(instr_vtable->set_string_keyed_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "set_string_native"),
                    &(instr_vtable->set_string_native));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "setprop"),
                    &(instr_vtable->setprop));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "share"),
                    &(instr_vtable->share));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "share_ro"),
                    &(instr_vtable->share_ro));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "shift_float"),
                    &(instr_vtable->shift_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "shift_integer"),
                    &(instr_vtable->shift_integer));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "shift_pmc"),
                    &(instr_vtable->shift_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "shift_string"),
                    &(instr_vtable->shift_string));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "splice"),
                    &(instr_vtable->splice));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "substr"),
                    &(instr_vtable->substr));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "substr_str"),
                    &(instr_vtable->substr_str));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "subtract"),
                    &(instr_vtable->subtract));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "subtract_float"),
                    &(instr_vtable->subtract_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "subtract_int"),
                    &(instr_vtable->subtract_int));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "thaw"),
                    &(instr_vtable->thaw));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "thawfinish"),
                    &(instr_vtable->thawfinish));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "type"),
                    &(instr_vtable->type));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "unshift_float"),
                    &(instr_vtable->unshift_float));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "unshift_integer"),
                    &(instr_vtable->unshift_integer));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "unshift_pmc"),
                    &(instr_vtable->unshift_pmc));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "unshift_string"),
                    &(instr_vtable->unshift_string));
    parrot_hash_put(interp, instr, CONST_STRING(interp, "visit"),
                    &(instr_vtable->visit));

    /* Build mappings for name -> stub_function if it wasn't done already. */
    if (parrot_hash_size(interp, stub) == 0) {
        parrot_hash_put(interp, stub, CONST_STRING(interp, "absolute"),
                        stub_vtable_absolute);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "add"),
                        stub_vtable_add);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "add_attribute"),
                        stub_vtable_add_attribute);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "add_float"),
                        stub_vtable_add_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "add_int"),
                        stub_vtable_add_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "add_method"),
                        stub_vtable_add_method);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "add_parent"),
                        stub_vtable_add_parent);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "add_role"),
                        stub_vtable_add_role);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "add_vtable_override"),
                        stub_vtable_add_vtable_override);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "assign_pmc"),
                        stub_vtable_assign_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "assign_string_native"),
                        stub_vtable_assign_string_native);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "can"),
                        stub_vtable_can);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "clone"),
                        stub_vtable_clone);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "clone_pmc"),
                        stub_vtable_clone_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "cmp"),
                        stub_vtable_cmp);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "cmp_num"),
                        stub_vtable_cmp_num);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "cmp_pmc"),
                        stub_vtable_cmp_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "cmp_string"),
                        stub_vtable_cmp_string);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "concatenate"),
                        stub_vtable_concatenate);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "concatenate_str"),
                        stub_vtable_concatenate_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "decrement"),
                        stub_vtable_decrement);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "defined"),
                        stub_vtable_defined);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "defined_keyed"),
                        stub_vtable_defined_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "defined_keyed_int"),
                        stub_vtable_defined_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "defined_keyed_str"),
                        stub_vtable_defined_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "delete_keyed"),
                        stub_vtable_delete_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "delete_keyed_int"),
                        stub_vtable_delete_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "delete_keyed_str"),
                        stub_vtable_delete_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "delprop"),
                        stub_vtable_delprop);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "destroy"),
                        stub_vtable_destroy);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "divide"),
                        stub_vtable_divide);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "divide_float"),
                        stub_vtable_divide_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "divide_int"),
                        stub_vtable_divide_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "does"),
                        stub_vtable_does);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "does_pmc"),
                        stub_vtable_does_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "elements"),
                        stub_vtable_elements);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "exists_keyed"),
                        stub_vtable_exists_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "exists_keyed_int"),
                        stub_vtable_exists_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "exists_keyed_str"),
                        stub_vtable_exists_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "find_method"),
                        stub_vtable_find_method);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "floor_divide"),
                        stub_vtable_floor_divide);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "floor_divide_float"),
                        stub_vtable_floor_divide_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "floor_divide_int"),
                        stub_vtable_floor_divide_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "freeze"),
                        stub_vtable_freeze);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_attr_keyed"),
                        stub_vtable_get_attr_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_attr_str"),
                        stub_vtable_get_attr_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_bool"),
                        stub_vtable_get_bool);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_class"),
                        stub_vtable_get_class);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_integer"),
                        stub_vtable_get_integer);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_integer_keyed"),
                        stub_vtable_get_integer_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_integer_keyed_int"),
                        stub_vtable_get_integer_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_integer_keyed_str"),
                        stub_vtable_get_integer_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_iter"),
                        stub_vtable_get_iter);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_namespace"),
                        stub_vtable_get_namespace);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_number"),
                        stub_vtable_get_number);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_number_keyed"),
                        stub_vtable_get_number_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_number_keyed_int"),
                        stub_vtable_get_number_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_number_keyed_str"),
                        stub_vtable_get_number_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pmc"),
                        stub_vtable_get_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pmc_keyed"),
                        stub_vtable_get_pmc_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pmc_keyed_int"),
                        stub_vtable_get_pmc_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pmc_keyed_str"),
                        stub_vtable_get_pmc_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pointer"),
                        stub_vtable_get_pointer);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pointer_keyed"),
                        stub_vtable_get_pointer_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pointer_keyed_int"),
                        stub_vtable_get_pointer_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pointer_keyed_str"),
                        stub_vtable_get_pointer_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_repr"),
                        stub_vtable_get_repr);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_string"),
                        stub_vtable_get_string);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_string_keyed"),
                        stub_vtable_get_string_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_string_keyed_int"),
                        stub_vtable_get_string_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "get_string_keyed_str"),
                        stub_vtable_get_string_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "getprop"),
                        stub_vtable_getprop);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "getprops"),
                        stub_vtable_getprops);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "hashvalue"),
                        stub_vtable_hashvalue);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_absolute"),
                        stub_vtable_i_absolute);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_add"),
                        stub_vtable_i_add);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_add_float"),
                        stub_vtable_i_add_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_add_int"),
                        stub_vtable_i_add_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_concatenate"),
                        stub_vtable_i_concatenate);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_concatenate_str"),
                        stub_vtable_i_concatenate_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_divide"),
                        stub_vtable_i_divide);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_divide_float"),
                        stub_vtable_i_divide_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_divide_int"),
                        stub_vtable_i_divide_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_floor_divide"),
                        stub_vtable_i_floor_divide);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_floor_divide_float"),
                        stub_vtable_i_floor_divide_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_floor_divide_int"),
                        stub_vtable_i_floor_divide_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_logical_not"),
                        stub_vtable_i_logical_not);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_modulus"),
                        stub_vtable_i_modulus);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_modulus_float"),
                        stub_vtable_i_modulus_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_modulus_int"),
                        stub_vtable_i_modulus_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_multiply"),
                        stub_vtable_i_multiply);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_multiply_float"),
                        stub_vtable_i_multiply_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_multiply_int"),
                        stub_vtable_i_multiply_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_neg"),
                        stub_vtable_i_neg);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_repeat"),
                        stub_vtable_i_repeat);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_repeat_int"),
                        stub_vtable_i_repeat_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_subtract"),
                        stub_vtable_i_subtract);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_subtract_float"),
                        stub_vtable_i_subtract_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "i_subtract_int"),
                        stub_vtable_i_subtract_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "increment"),
                        stub_vtable_increment);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "init"),
                        stub_vtable_init);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "init_int"),
                        stub_vtable_init_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "init_pmc"),
                        stub_vtable_init_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "inspect"),
                        stub_vtable_inspect);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "inspect_str"),
                        stub_vtable_inspect_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "instantiate"),
                        stub_vtable_instantiate);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "invoke"),
                        stub_vtable_invoke);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "is_equal"),
                        stub_vtable_is_equal);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "is_equal_num"),
                        stub_vtable_is_equal_num);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "is_equal_string"),
                        stub_vtable_is_equal_string);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "is_same"),
                        stub_vtable_is_same);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "isa"),
                        stub_vtable_isa);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "isa_pmc"),
                        stub_vtable_isa_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "logical_and"),
                        stub_vtable_logical_and);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "logical_not"),
                        stub_vtable_logical_not);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "logical_or"),
                        stub_vtable_logical_or);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "logical_xor"),
                        stub_vtable_logical_xor);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "mark"),
                        stub_vtable_mark);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "modulus"),
                        stub_vtable_modulus);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "modulus_float"),
                        stub_vtable_modulus_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "modulus_int"),
                        stub_vtable_modulus_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "morph"),
                        stub_vtable_morph);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "multiply"),
                        stub_vtable_multiply);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "multiply_float"),
                        stub_vtable_multiply_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "multiply_int"),
                        stub_vtable_multiply_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "name"),
                        stub_vtable_name);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "neg"),
                        stub_vtable_neg);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "pop_float"),
                        stub_vtable_pop_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "pop_integer"),
                        stub_vtable_pop_integer);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "pop_pmc"),
                        stub_vtable_pop_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "pop_string"),
                        stub_vtable_pop_string);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "push_float"),
                        stub_vtable_push_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "push_integer"),
                        stub_vtable_push_integer);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "push_pmc"),
                        stub_vtable_push_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "push_string"),
                        stub_vtable_push_string);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "remove_attribute"),
                        stub_vtable_remove_attribute);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "remove_method"),
                        stub_vtable_remove_method);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "remove_parent"),
                        stub_vtable_remove_parent);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "remove_role"),
                        stub_vtable_remove_role);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "remove_vtable_override"),
                        stub_vtable_remove_vtable_override);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "repeat"),
                        stub_vtable_repeat);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "repeat_int"),
                        stub_vtable_repeat_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_attr_keyed"),
                        stub_vtable_set_attr_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_attr_str"),
                        stub_vtable_set_attr_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_bool"),
                        stub_vtable_set_bool);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_integer_keyed"),
                        stub_vtable_set_integer_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_integer_keyed_int"),
                        stub_vtable_set_integer_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_integer_keyed_str"),
                        stub_vtable_set_integer_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_integer_native"),
                        stub_vtable_set_integer_native);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_number_keyed"),
                        stub_vtable_set_number_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_number_keyed_int"),
                        stub_vtable_set_number_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_number_keyed_str"),
                        stub_vtable_set_number_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_number_native"),
                        stub_vtable_set_number_native);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pmc"),
                        stub_vtable_set_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pmc_keyed"),
                        stub_vtable_set_pmc_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pmc_keyed_int"),
                        stub_vtable_set_pmc_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pmc_keyed_str"),
                        stub_vtable_set_pmc_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pointer"),
                        stub_vtable_set_pointer);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pointer_keyed"),
                        stub_vtable_set_pointer_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pointer_keyed_int"),
                        stub_vtable_set_pointer_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pointer_keyed_str"),
                        stub_vtable_set_pointer_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_string_keyed"),
                        stub_vtable_set_string_keyed);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_string_keyed_int"),
                        stub_vtable_set_string_keyed_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_string_keyed_str"),
                        stub_vtable_set_string_keyed_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "set_string_native"),
                        stub_vtable_set_string_native);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "setprop"),
                        stub_vtable_setprop);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "share"),
                        stub_vtable_share);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "share_ro"),
                        stub_vtable_share_ro);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "shift_float"),
                        stub_vtable_shift_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "shift_integer"),
                        stub_vtable_shift_integer);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "shift_pmc"),
                        stub_vtable_shift_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "shift_string"),
                        stub_vtable_shift_string);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "splice"),
                        stub_vtable_splice);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "substr"),
                        stub_vtable_substr);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "substr_str"),
                        stub_vtable_substr_str);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "subtract"),
                        stub_vtable_subtract);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "subtract_float"),
                        stub_vtable_subtract_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "subtract_int"),
                        stub_vtable_subtract_int);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "thaw"),
                        stub_vtable_thaw);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "thawfinish"),
                        stub_vtable_thawfinish);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "type"),
                        stub_vtable_type);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "unshift_float"),
                        stub_vtable_unshift_float);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "unshift_integer"),
                        stub_vtable_unshift_integer);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "unshift_pmc"),
                        stub_vtable_unshift_pmc);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "unshift_string"),
                        stub_vtable_unshift_string);
        parrot_hash_put(interp, stub, CONST_STRING(interp, "visit"),
                        stub_vtable_visit);
    }
}

/*
 * Stubs
 */

static
PMC* stub_vtable_absolute(PARROT_INTERP, PMC* pmc, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->absolute(interp, pmc, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "absolute"));

    return ret;
}

static
PMC* stub_vtable_add(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->add(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "add"));

    return ret;
}

static
void stub_vtable_add_attribute(PARROT_INTERP, PMC* pmc, STRING* name, PMC* type) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->add_attribute(interp, pmc, name, type);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "add_attribute"));

    return;
}

static
PMC* stub_vtable_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->add_float(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "add_float"));

    return ret;
}

static
PMC* stub_vtable_add_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->add_int(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "add_int"));

    return ret;
}

static
void stub_vtable_add_method(PARROT_INTERP, PMC* pmc, STRING* method_name, PMC* sub_pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->add_method(interp, pmc, method_name, sub_pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "add_method"));

    return;
}

static
void stub_vtable_add_parent(PARROT_INTERP, PMC* pmc, PMC* parent) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->add_parent(interp, pmc, parent);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "add_parent"));

    return;
}

static
void stub_vtable_add_role(PARROT_INTERP, PMC* pmc, PMC* role) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->add_role(interp, pmc, role);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "add_role"));

    return;
}

static
void stub_vtable_add_vtable_override(PARROT_INTERP, PMC* pmc, STRING* vtable_name, PMC* sub_pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->add_vtable_override(interp, pmc, vtable_name, sub_pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "add_vtable_override"));

    return;
}

static
void stub_vtable_assign_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->assign_pmc(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "assign_pmc"));

    return;
}

static
void stub_vtable_assign_string_native(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->assign_string_native(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "assign_string_native"));

    return;
}

static
INTVAL stub_vtable_can(PARROT_INTERP, PMC* pmc, STRING* method) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->can(interp, pmc, method);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "can"));

    return ret;
}

static
PMC* stub_vtable_clone(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->clone(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "clone"));

    return ret;
}

static
PMC* stub_vtable_clone_pmc(PARROT_INTERP, PMC* pmc, PMC* args) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->clone_pmc(interp, pmc, args);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "clone_pmc"));

    return ret;
}

static
INTVAL stub_vtable_cmp(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->cmp(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "cmp"));

    return ret;
}

static
INTVAL stub_vtable_cmp_num(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->cmp_num(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "cmp_num"));

    return ret;
}

static
PMC* stub_vtable_cmp_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->cmp_pmc(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "cmp_pmc"));

    return ret;
}

static
INTVAL stub_vtable_cmp_string(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->cmp_string(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "cmp_string"));

    return ret;
}

static
PMC* stub_vtable_concatenate(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->concatenate(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "concatenate"));

    return ret;
}

static
PMC* stub_vtable_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->concatenate_str(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "concatenate_str"));

    return ret;
}

static
void stub_vtable_decrement(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->decrement(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "decrement"));

    return;
}

static
INTVAL stub_vtable_defined(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->defined(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "defined"));

    return ret;
}

static
INTVAL stub_vtable_defined_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->defined_keyed(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "defined_keyed"));

    return ret;
}

static
INTVAL stub_vtable_defined_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->defined_keyed_int(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "defined_keyed_int"));

    return ret;
}

static
INTVAL stub_vtable_defined_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->defined_keyed_str(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "defined_keyed_str"));

    return ret;
}

static
void stub_vtable_delete_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->delete_keyed(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "delete_keyed"));

    return;
}

static
void stub_vtable_delete_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->delete_keyed_int(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "delete_keyed_int"));

    return;
}

static
void stub_vtable_delete_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->delete_keyed_str(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "delete_keyed_str"));

    return;
}

static
void stub_vtable_delprop(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->delprop(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "delprop"));

    return;
}

static
void stub_vtable_destroy(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->destroy(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "destroy"));

    return;
}

static
PMC* stub_vtable_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->divide(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "divide"));

    return ret;
}

static
PMC* stub_vtable_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->divide_float(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "divide_float"));

    return ret;
}

static
PMC* stub_vtable_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->divide_int(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "divide_int"));

    return ret;
}

static
INTVAL stub_vtable_does(PARROT_INTERP, PMC* pmc, STRING* role) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->does(interp, pmc, role);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "does"));

    return ret;
}

static
INTVAL stub_vtable_does_pmc(PARROT_INTERP, PMC* pmc, PMC* role) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->does_pmc(interp, pmc, role);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "does_pmc"));

    return ret;
}

static
INTVAL stub_vtable_elements(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->elements(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "elements"));

    return ret;
}

static
INTVAL stub_vtable_exists_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->exists_keyed(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "exists_keyed"));

    return ret;
}

static
INTVAL stub_vtable_exists_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->exists_keyed_int(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "exists_keyed_int"));

    return ret;
}

static
INTVAL stub_vtable_exists_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->exists_keyed_str(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "exists_keyed_str"));

    return ret;
}

static
PMC* stub_vtable_find_method(PARROT_INTERP, PMC* pmc, STRING* method_name) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->find_method(interp, pmc, method_name);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "find_method"));

    return ret;
}

static
PMC* stub_vtable_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->floor_divide(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "floor_divide"));

    return ret;
}

static
PMC* stub_vtable_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->floor_divide_float(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "floor_divide_float"));

    return ret;
}

static
PMC* stub_vtable_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->floor_divide_int(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "floor_divide_int"));

    return ret;
}

static
void stub_vtable_freeze(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->freeze(interp, pmc, info);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "freeze"));

    return;
}

static
PMC* stub_vtable_get_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_attr_keyed(interp, pmc, key, idx);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_attr_keyed"));

    return ret;
}

static
PMC* stub_vtable_get_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_attr_str(interp, pmc, idx);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_attr_str"));

    return ret;
}

static
INTVAL stub_vtable_get_bool(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_bool(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_bool"));

    return ret;
}

static
PMC* stub_vtable_get_class(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_class(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_class"));

    return ret;
}

static
INTVAL stub_vtable_get_integer(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_integer(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_integer"));

    return ret;
}

static
INTVAL stub_vtable_get_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_integer_keyed(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_integer_keyed"));

    return ret;
}

static
INTVAL stub_vtable_get_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_integer_keyed_int(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_integer_keyed_int"));

    return ret;
}

static
INTVAL stub_vtable_get_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_integer_keyed_str(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_integer_keyed_str"));

    return ret;
}

static
PMC* stub_vtable_get_iter(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_iter(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_iter"));

    return ret;
}

static
PMC* stub_vtable_get_namespace(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_namespace(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_namespace"));

    return ret;
}

static
FLOATVAL stub_vtable_get_number(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_number(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_number"));

    return ret;
}

static
FLOATVAL stub_vtable_get_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_number_keyed(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_number_keyed"));

    return ret;
}

static
FLOATVAL stub_vtable_get_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_number_keyed_int(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_number_keyed_int"));

    return ret;
}

static
FLOATVAL stub_vtable_get_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_number_keyed_str(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_number_keyed_str"));

    return ret;
}

static
PMC* stub_vtable_get_pmc(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pmc(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_pmc"));

    return ret;
}

static
PMC* stub_vtable_get_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pmc_keyed(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_pmc_keyed"));

    return ret;
}

static
PMC* stub_vtable_get_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pmc_keyed_int(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_pmc_keyed_int"));

    return ret;
}

static
PMC* stub_vtable_get_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pmc_keyed_str(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_pmc_keyed_str"));

    return ret;
}

static
void* stub_vtable_get_pointer(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    void* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pointer(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_pointer"));

    return ret;
}

static
void* stub_vtable_get_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    void* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pointer_keyed(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_pointer_keyed"));

    return ret;
}

static
void* stub_vtable_get_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    void* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pointer_keyed_int(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_pointer_keyed_int"));

    return ret;
}

static
void* stub_vtable_get_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    void* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pointer_keyed_str(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_pointer_keyed_str"));

    return ret;
}

static
STRING* stub_vtable_get_repr(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_repr(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_repr"));

    return ret;
}

static
STRING* stub_vtable_get_string(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_string(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_string"));

    return ret;
}

static
STRING* stub_vtable_get_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_string_keyed(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_string_keyed"));

    return ret;
}

static
STRING* stub_vtable_get_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_string_keyed_int(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_string_keyed_int"));

    return ret;
}

static
STRING* stub_vtable_get_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_string_keyed_str(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "get_string_keyed_str"));

    return ret;
}

static
PMC* stub_vtable_getprop(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->getprop(interp, pmc, key);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "getprop"));

    return ret;
}

static
PMC* stub_vtable_getprops(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->getprops(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "getprops"));

    return ret;
}

static
INTVAL stub_vtable_hashvalue(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->hashvalue(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "hashvalue"));

    return ret;
}

static
void stub_vtable_i_absolute(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_absolute(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_absolute"));

    return;
}

static
void stub_vtable_i_add(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_add(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_add"));

    return;
}

static
void stub_vtable_i_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_add_float(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_add_float"));

    return;
}

static
void stub_vtable_i_add_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_add_int(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_add_int"));

    return;
}

static
void stub_vtable_i_concatenate(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_concatenate(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_concatenate"));

    return;
}

static
void stub_vtable_i_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_concatenate_str(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_concatenate_str"));

    return;
}

static
void stub_vtable_i_divide(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_divide(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_divide"));

    return;
}

static
void stub_vtable_i_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_divide_float(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_divide_float"));

    return;
}

static
void stub_vtable_i_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_divide_int(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_divide_int"));

    return;
}

static
void stub_vtable_i_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_floor_divide(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_floor_divide"));

    return;
}

static
void stub_vtable_i_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_floor_divide_float(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_floor_divide_float"));

    return;
}

static
void stub_vtable_i_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_floor_divide_int(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_floor_divide_int"));

    return;
}

static
void stub_vtable_i_logical_not(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_logical_not(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_logical_not"));

    return;
}

static
void stub_vtable_i_modulus(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_modulus(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_modulus"));

    return;
}

static
void stub_vtable_i_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_modulus_float(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_modulus_float"));

    return;
}

static
void stub_vtable_i_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_modulus_int(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_modulus_int"));

    return;
}

static
void stub_vtable_i_multiply(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_multiply(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_multiply"));

    return;
}

static
void stub_vtable_i_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_multiply_float(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_multiply_float"));

    return;
}

static
void stub_vtable_i_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_multiply_int(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_multiply_int"));

    return;
}

static
void stub_vtable_i_neg(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_neg(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_neg"));

    return;
}

static
void stub_vtable_i_repeat(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_repeat(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_repeat"));

    return;
}

static
void stub_vtable_i_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_repeat_int(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_repeat_int"));

    return;
}

static
void stub_vtable_i_subtract(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_subtract(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_subtract"));

    return;
}

static
void stub_vtable_i_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_subtract_float(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_subtract_float"));

    return;
}

static
void stub_vtable_i_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_subtract_int(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "i_subtract_int"));

    return;
}

static
void stub_vtable_increment(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->increment(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "increment"));

    return;
}

static
void stub_vtable_init(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->init(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "init"));

    return;
}

static
void stub_vtable_init_int(PARROT_INTERP, PMC* pmc, INTVAL initializer) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->init_int(interp, pmc, initializer);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "init_int"));

    return;
}

static
void stub_vtable_init_pmc(PARROT_INTERP, PMC* pmc, PMC* initializer) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->init_pmc(interp, pmc, initializer);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "init_pmc"));

    return;
}

static
PMC* stub_vtable_inspect(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->inspect(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "inspect"));

    return ret;
}

static
PMC* stub_vtable_inspect_str(PARROT_INTERP, PMC* pmc, STRING* what) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->inspect_str(interp, pmc, what);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "inspect_str"));

    return ret;
}

static
PMC* stub_vtable_instantiate(PARROT_INTERP, PMC* pmc, PMC* sig) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->instantiate(interp, pmc, sig);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "instantiate"));

    return ret;
}

static
opcode_t* stub_vtable_invoke(PARROT_INTERP, PMC* pmc, void* next) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    opcode_t* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->invoke(interp, pmc, next);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "invoke"));

    return ret;
}

static
INTVAL stub_vtable_is_equal(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->is_equal(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "is_equal"));

    return ret;
}

static
INTVAL stub_vtable_is_equal_num(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->is_equal_num(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "is_equal_num"));

    return ret;
}

static
INTVAL stub_vtable_is_equal_string(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->is_equal_string(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "is_equal_string"));

    return ret;
}

static
INTVAL stub_vtable_is_same(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->is_same(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "is_same"));

    return ret;
}

static
INTVAL stub_vtable_isa(PARROT_INTERP, PMC* pmc, STRING* _class) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->isa(interp, pmc, _class);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "isa"));

    return ret;
}

static
INTVAL stub_vtable_isa_pmc(PARROT_INTERP, PMC* pmc, PMC* _class) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->isa_pmc(interp, pmc, _class);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "isa_pmc"));

    return ret;
}

static
PMC* stub_vtable_logical_and(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->logical_and(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "logical_and"));

    return ret;
}

static
PMC* stub_vtable_logical_not(PARROT_INTERP, PMC* pmc, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->logical_not(interp, pmc, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "logical_not"));

    return ret;
}

static
PMC* stub_vtable_logical_or(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->logical_or(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "logical_or"));

    return ret;
}

static
PMC* stub_vtable_logical_xor(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->logical_xor(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "logical_xor"));

    return ret;
}

static
void stub_vtable_mark(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->mark(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "mark"));

    return;
}

static
PMC* stub_vtable_modulus(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->modulus(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "modulus"));

    return ret;
}

static
PMC* stub_vtable_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->modulus_float(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "modulus_float"));

    return ret;
}

static
PMC* stub_vtable_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->modulus_int(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "modulus_int"));

    return ret;
}

static
void stub_vtable_morph(PARROT_INTERP, PMC* pmc, PMC* type) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->morph(interp, pmc, type);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "morph"));

    return;
}

static
PMC* stub_vtable_multiply(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->multiply(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "multiply"));

    return ret;
}

static
PMC* stub_vtable_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->multiply_float(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "multiply_float"));

    return ret;
}

static
PMC* stub_vtable_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->multiply_int(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "multiply_int"));

    return ret;
}

static
STRING* stub_vtable_name(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->name(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "name"));

    return ret;
}

static
PMC* stub_vtable_neg(PARROT_INTERP, PMC* pmc, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->neg(interp, pmc, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "neg"));

    return ret;
}

static
FLOATVAL stub_vtable_pop_float(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->pop_float(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "pop_float"));

    return ret;
}

static
INTVAL stub_vtable_pop_integer(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->pop_integer(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "pop_integer"));

    return ret;
}

static
PMC* stub_vtable_pop_pmc(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->pop_pmc(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "pop_pmc"));

    return ret;
}

static
STRING* stub_vtable_pop_string(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->pop_string(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "pop_string"));

    return ret;
}

static
void stub_vtable_push_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->push_float(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "push_float"));

    return;
}

static
void stub_vtable_push_integer(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->push_integer(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "push_integer"));

    return;
}

static
void stub_vtable_push_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->push_pmc(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "push_pmc"));

    return;
}

static
void stub_vtable_push_string(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->push_string(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "push_string"));

    return;
}

static
void stub_vtable_remove_attribute(PARROT_INTERP, PMC* pmc, STRING* name) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->remove_attribute(interp, pmc, name);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "remove_attribute"));

    return;
}

static
void stub_vtable_remove_method(PARROT_INTERP, PMC* pmc, STRING* method_name) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->remove_method(interp, pmc, method_name);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "remove_method"));

    return;
}

static
void stub_vtable_remove_parent(PARROT_INTERP, PMC* pmc, PMC* parent) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->remove_parent(interp, pmc, parent);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "remove_parent"));

    return;
}

static
void stub_vtable_remove_role(PARROT_INTERP, PMC* pmc, PMC* role) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->remove_role(interp, pmc, role);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "remove_role"));

    return;
}

static
void stub_vtable_remove_vtable_override(PARROT_INTERP, PMC* pmc, STRING* vtable_name) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->remove_vtable_override(interp, pmc, vtable_name);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "remove_vtable_override"));

    return;
}

static
PMC* stub_vtable_repeat(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->repeat(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "repeat"));

    return ret;
}

static
PMC* stub_vtable_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->repeat_int(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "repeat_int"));

    return ret;
}

static
void stub_vtable_set_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_attr_keyed(interp, pmc, key, idx, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_attr_keyed"));

    return;
}

static
void stub_vtable_set_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_attr_str(interp, pmc, idx, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_attr_str"));

    return;
}

static
void stub_vtable_set_bool(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_bool(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_bool"));

    return;
}

static
void stub_vtable_set_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_integer_keyed(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_integer_keyed"));

    return;
}

static
void stub_vtable_set_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_integer_keyed_int(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_integer_keyed_int"));

    return;
}

static
void stub_vtable_set_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_integer_keyed_str(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_integer_keyed_str"));

    return;
}

static
void stub_vtable_set_integer_native(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_integer_native(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_integer_native"));

    return;
}

static
void stub_vtable_set_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_number_keyed(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_number_keyed"));

    return;
}

static
void stub_vtable_set_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_number_keyed_int(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_number_keyed_int"));

    return;
}

static
void stub_vtable_set_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_number_keyed_str(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_number_keyed_str"));

    return;
}

static
void stub_vtable_set_number_native(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_number_native(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_number_native"));

    return;
}

static
void stub_vtable_set_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pmc(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_pmc"));

    return;
}

static
void stub_vtable_set_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pmc_keyed(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_pmc_keyed"));

    return;
}

static
void stub_vtable_set_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pmc_keyed_int(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_pmc_keyed_int"));

    return;
}

static
void stub_vtable_set_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pmc_keyed_str(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_pmc_keyed_str"));

    return;
}

static
void stub_vtable_set_pointer(PARROT_INTERP, PMC* pmc, void* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pointer(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_pointer"));

    return;
}

static
void stub_vtable_set_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, void* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pointer_keyed(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_pointer_keyed"));

    return;
}

static
void stub_vtable_set_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, void* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pointer_keyed_int(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_pointer_keyed_int"));

    return;
}

static
void stub_vtable_set_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, void* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pointer_keyed_str(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_pointer_keyed_str"));

    return;
}

static
void stub_vtable_set_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_string_keyed(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_string_keyed"));

    return;
}

static
void stub_vtable_set_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_string_keyed_int(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_string_keyed_int"));

    return;
}

static
void stub_vtable_set_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_string_keyed_str(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_string_keyed_str"));

    return;
}

static
void stub_vtable_set_string_native(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_string_native(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "set_string_native"));

    return;
}

static
void stub_vtable_setprop(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->setprop(interp, pmc, key, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "setprop"));

    return;
}

static
void stub_vtable_share(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->share(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "share"));

    return;
}

static
PMC* stub_vtable_share_ro(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->share_ro(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "share_ro"));

    return ret;
}

static
FLOATVAL stub_vtable_shift_float(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->shift_float(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "shift_float"));

    return ret;
}

static
INTVAL stub_vtable_shift_integer(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->shift_integer(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "shift_integer"));

    return ret;
}

static
PMC* stub_vtable_shift_pmc(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->shift_pmc(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "shift_pmc"));

    return ret;
}

static
STRING* stub_vtable_shift_string(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->shift_string(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "shift_string"));

    return ret;
}

static
void stub_vtable_splice(PARROT_INTERP, PMC* pmc, PMC* value, INTVAL offset, INTVAL count) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->splice(interp, pmc, value, offset, count);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "splice"));

    return;
}

static
void stub_vtable_substr(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->substr(interp, pmc, offset, length, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "substr"));

    return;
}

static
STRING* stub_vtable_substr_str(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->substr_str(interp, pmc, offset, length);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "substr_str"));

    return ret;
}

static
PMC* stub_vtable_subtract(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->subtract(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "subtract"));

    return ret;
}

static
PMC* stub_vtable_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->subtract_float(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "subtract_float"));

    return ret;
}

static
PMC* stub_vtable_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->subtract_int(interp, pmc, value, dest);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "subtract_int"));

    return ret;
}

static
void stub_vtable_thaw(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->thaw(interp, pmc, info);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "thaw"));

    return;
}

static
void stub_vtable_thawfinish(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->thawfinish(interp, pmc, info);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "thawfinish"));

    return;
}

static
INTVAL stub_vtable_type(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->type(interp, pmc);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "type"));

    return ret;
}

static
void stub_vtable_unshift_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->unshift_float(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "unshift_float"));

    return;
}

static
void stub_vtable_unshift_integer(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->unshift_integer(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "unshift_integer"));

    return;
}

static
void stub_vtable_unshift_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->unshift_pmc(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "unshift_pmc"));

    return;
}

static
void stub_vtable_unshift_string(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->unshift_string(interp, pmc, value);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "unshift_string"));

    return;
}

static
void stub_vtable_visit(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->visit(interp, pmc, info);

    data = Parrot_pmc_new(supervisor, enum_class_Hash);

    raise_vtable_event(supervisor, interp, pmc, data,
                       CONST_STRING(supervisor, "visit"));

    return;
}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
