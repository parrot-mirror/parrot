/*
Copyright (C) 2010, Parrot Foundation.
$Id$

=head1 NAME

src/dynpmc/instrumentpmc.pmc - Interface to instrument a PMC's vtable.

=head1 DESCRIPTION

C<InstrumentPMC> is a PMC class that provides an interface to
instrument a PMC.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

#include "pmc_instrument.h"

/* Helper Prototypes. */
void raise_vtable_event(PARROT_INTERP, Parrot_Interp supervised, PMC *pmc,
                        PMC *data, STRING *group, STRING *type);
void setup_vtable_common_hashes(PARROT_INTERP);
void destroy_vtable_common_hashes(PARROT_INTERP);
void setup_vtable_individual_hashes(PARROT_INTERP, Hash *orig_hash, Hash *instr_hash,
                                    _vtable *vt_orig, _vtable *vt_instr);

/* Globals used internally. */
static INTVAL  vtable_first_run   = 1;
static Hash   *vtable_registry    = NULL;
static Hash   *vtable_name_stubs  = NULL;
static Hash   *vtable_group_items = NULL;
static Hash   *vtable_item_groups = NULL;

pmclass InstrumentVtable auto_attrs dynpmc group instrument_group extends InstrumentStubBase {
    ATTR size_t        class_index;
    ATTR Parrot_Interp supervisor;

/*

=item C<void init_pmc(PMC *instrument)>

Perform a partial initialization. The remaining attributes are initialised
upon calling 'attach_to_class'.

=cut

*/

    VTABLE void init_pmc(PMC *instrument) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        SUPER(instrument);

        /* Initialise the attributes.
           Other attributes are deferred to after attaching to a class. */
        attr->supervisor = INTERP;

        /* Initialise the static hashes. */
        setup_vtable_common_hashes(INTERP);

        /* Update the attributes to point to the static hashes. */
        attr->name_stubs  = vtable_name_stubs;
        attr->group_items = vtable_group_items;
        attr->item_groups = vtable_item_groups;
    }

/*

=item C<void destroy()>

Cleanup internal data structures.

=cut

*/

    VTABLE void destroy() {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        SUPER();
        if (attr->instrumented_struct != NULL) {
            parrot_hash_delete(INTERP, vtable_registry, attr->instrumented_struct);
        }
        destroy_vtable_common_hashes(INTERP);
    }

/*

=item C<void attach_to_class(STRING *classname)>

Prepare the given class' vtable for instrumentation.
If class is not found, throw an exception.

=cut

*/

    METHOD attach_to_class(STRING *classname) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        Parrot_Interp supervised;

        GETATTR_Instrument_supervised(INTERP, attr->instrument, supervised);

        /* Find the class. */
        attr->class_index     = Parrot_pmc_get_type_str(supervised, classname);

        /* class_index must not be 0. (0 = default). */
        if (attr->class_index == 0) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                        "%Ss : Class not found, '%Ss'",
                                        VTABLE_name(INTERP, SELF), classname);
        }
        attr->original_struct = supervised->vtables[attr->class_index];

        /* Prepare the class's vtable for instrumentation. */
        attr->instrumented_struct = mem_gc_allocate_zeroed_typed(supervised, _vtable);
        mem_copy_n_typed(attr->instrumented_struct, attr->original_struct, 1, _vtable);
        supervised->vtables[attr->class_index] = (_vtable *) attr->instrumented_struct;

        /* Register the instrumented vtable to SELF. */
        parrot_hash_put(INTERP, vtable_registry, attr->instrumented_struct, SELF);

        /* Build the vtable hashes, passing a sample vtable to build the offsets. */
        setup_vtable_individual_hashes(INTERP, attr->name_original, attr->name_offset,
                                       (_vtable *) attr->original_struct,
                                       (_vtable *) attr->instrumented_struct);
    }
}

/*
 * Helpers
 */

void raise_vtable_event(PARROT_INTERP, Parrot_Interp supervised,
                        PMC *pmc, PMC *data, STRING *group, STRING *type) {
    Parrot_Context_info info;
    PMC *task_hash, *task;
    PMC *event_arr;

    /* Get the current context info. */
    Parrot_Context_get_info(interp, CURRENT_CONTEXT(supervised), &info);

    /* Set the event type. */
    event_arr = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, event_arr, CONST_STRING(interp, "Class"));
    VTABLE_push_string(interp, event_arr, pmc->vtable->whoami);
    VTABLE_push_string(interp, event_arr, CONST_STRING(interp, "vtable"));
    VTABLE_push_string(interp, event_arr, group);
    VTABLE_push_string(interp, event_arr, type);

    /* Populate data with common items. */
    VTABLE_set_pmc_keyed_str(interp, data,
                                CONST_STRING(interp, "event"),
                                event_arr);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "file"),      info.file);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "sub"),       info.subname);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "namespace"), info.nsname);
    VTABLE_set_integer_keyed_str(interp, data, CONST_STRING(interp, "line"),      info.line);

    /* Raise the event. */
    task_hash = Parrot_pmc_new(interp, enum_class_Hash);
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "type"),
                                CONST_STRING(interp, "event"));
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "subtype"),
                                CONST_STRING(interp, "Instrument"));
    VTABLE_set_pmc_keyed_str(interp, task_hash, CONST_STRING(interp, "data"), data);

    task = Parrot_pmc_new_init(interp, enum_class_Task, task_hash);
    Parrot_cx_schedule_task(interp, task);
}


/* BELOW LIES GENERATED CODE GENERATED BY tools/build/gen_vtable_stubs.pl */
/* Stub Prototypes */
/* BEGIN vtable prototypes */
static void stub_init(PARROT_INTERP, PMC* pmc);
static void stub_init_pmc(PARROT_INTERP, PMC* pmc, PMC* initializer);
static PMC* stub_instantiate(PARROT_INTERP, PMC* pmc, PMC* sig);
static void stub_morph(PARROT_INTERP, PMC* pmc, PMC* type);
static void stub_mark(PARROT_INTERP, PMC* pmc);
static void stub_destroy(PARROT_INTERP, PMC* pmc);
static PMC* stub_get_namespace(PARROT_INTERP, PMC* pmc);
static PMC* stub_getprop(PARROT_INTERP, PMC* pmc, STRING* key);
static void stub_setprop(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value);
static void stub_delprop(PARROT_INTERP, PMC* pmc, STRING* key);
static PMC* stub_getprops(PARROT_INTERP, PMC* pmc);
static INTVAL stub_type(PARROT_INTERP, PMC* pmc);
static STRING* stub_name(PARROT_INTERP, PMC* pmc);
static PMC* stub_clone(PARROT_INTERP, PMC* pmc);
static PMC* stub_clone_pmc(PARROT_INTERP, PMC* pmc, PMC* args);
static PMC* stub_find_method(PARROT_INTERP, PMC* pmc, STRING* method_name);
static INTVAL stub_get_integer(PARROT_INTERP, PMC* pmc);
static INTVAL stub_get_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static INTVAL stub_get_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static INTVAL stub_get_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static FLOATVAL stub_get_number(PARROT_INTERP, PMC* pmc);
static FLOATVAL stub_get_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static FLOATVAL stub_get_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static FLOATVAL stub_get_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static STRING* stub_get_string(PARROT_INTERP, PMC* pmc);
static STRING* stub_get_repr(PARROT_INTERP, PMC* pmc);
static STRING* stub_get_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static STRING* stub_get_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static STRING* stub_get_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static INTVAL stub_get_bool(PARROT_INTERP, PMC* pmc);
static PMC* stub_get_pmc(PARROT_INTERP, PMC* pmc);
static PMC* stub_get_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static PMC* stub_get_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static PMC* stub_get_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static void* stub_get_pointer(PARROT_INTERP, PMC* pmc);
static void* stub_get_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static void* stub_get_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static void* stub_get_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static void stub_set_integer_native(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_set_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, INTVAL value);
static void stub_set_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, INTVAL value);
static void stub_set_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, INTVAL value);
static void stub_set_number_native(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_set_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key, FLOATVAL value);
static void stub_set_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, FLOATVAL value);
static void stub_set_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, FLOATVAL value);
static void stub_set_string_native(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_assign_string_native(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_set_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* value);
static void stub_set_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, STRING* value);
static void stub_set_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, STRING* value);
static void stub_set_bool(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_set_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_assign_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_set_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key, PMC* value);
static void stub_set_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, PMC* value);
static void stub_set_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value);
static void stub_set_pointer(PARROT_INTERP, PMC* pmc, void* value);
static void stub_set_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, void* value);
static void stub_set_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, void* value);
static void stub_set_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, void* value);
static INTVAL stub_elements(PARROT_INTERP, PMC* pmc);
static INTVAL stub_pop_integer(PARROT_INTERP, PMC* pmc);
static FLOATVAL stub_pop_float(PARROT_INTERP, PMC* pmc);
static STRING* stub_pop_string(PARROT_INTERP, PMC* pmc);
static PMC* stub_pop_pmc(PARROT_INTERP, PMC* pmc);
static void stub_push_integer(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_push_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_push_string(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_push_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_shift_integer(PARROT_INTERP, PMC* pmc);
static FLOATVAL stub_shift_float(PARROT_INTERP, PMC* pmc);
static STRING* stub_shift_string(PARROT_INTERP, PMC* pmc);
static PMC* stub_shift_pmc(PARROT_INTERP, PMC* pmc);
static void stub_unshift_integer(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_unshift_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_unshift_string(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_unshift_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_splice(PARROT_INTERP, PMC* pmc, PMC* value, INTVAL offset, INTVAL count);
static PMC* stub_add(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_add_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_add(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_add_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static PMC* stub_subtract(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_subtract(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static PMC* stub_multiply(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_multiply(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static PMC* stub_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_divide(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static PMC* stub_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static PMC* stub_modulus(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_modulus(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_increment(PARROT_INTERP, PMC* pmc);
static void stub_decrement(PARROT_INTERP, PMC* pmc);
static PMC* stub_absolute(PARROT_INTERP, PMC* pmc, PMC* dest);
static void stub_i_absolute(PARROT_INTERP, PMC* pmc);
static PMC* stub_neg(PARROT_INTERP, PMC* pmc, PMC* dest);
static void stub_i_neg(PARROT_INTERP, PMC* pmc);
static INTVAL stub_is_equal(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_is_equal_num(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_is_equal_string(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_is_same(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_cmp(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_cmp_num(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_cmp_string(PARROT_INTERP, PMC* pmc, PMC* value);
static PMC* stub_cmp_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static PMC* stub_logical_or(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_logical_and(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_logical_xor(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_logical_not(PARROT_INTERP, PMC* pmc, PMC* dest);
static void stub_i_logical_not(PARROT_INTERP, PMC* pmc);
static PMC* stub_concatenate(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value, PMC* dest);
static void stub_i_concatenate(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value);
static PMC* stub_repeat(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static void stub_i_repeat(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_substr(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length, PMC* dest);
static STRING* stub_substr_str(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length);
static INTVAL stub_exists_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static INTVAL stub_exists_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static INTVAL stub_exists_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static INTVAL stub_defined(PARROT_INTERP, PMC* pmc);
static INTVAL stub_defined_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static INTVAL stub_defined_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static INTVAL stub_defined_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static void stub_delete_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static void stub_delete_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static void stub_delete_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static PMC* stub_get_iter(PARROT_INTERP, PMC* pmc);
static INTVAL stub_hashvalue(PARROT_INTERP, PMC* pmc);
static opcode_t* stub_invoke(PARROT_INTERP, PMC* pmc, void* next);
static INTVAL stub_can(PARROT_INTERP, PMC* pmc, STRING* method);
static INTVAL stub_does_pmc(PARROT_INTERP, PMC* pmc, PMC* role);
static INTVAL stub_does(PARROT_INTERP, PMC* pmc, STRING* role);
static INTVAL stub_isa_pmc(PARROT_INTERP, PMC* pmc, PMC* _class);
static INTVAL stub_isa(PARROT_INTERP, PMC* pmc, STRING* _class);
static PMC* stub_get_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx);
static PMC* stub_get_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx);
static void stub_set_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx, PMC* value);
static void stub_set_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx, PMC* value);
static PMC* stub_get_class(PARROT_INTERP, PMC* pmc);
static void stub_add_parent(PARROT_INTERP, PMC* pmc, PMC* parent);
static void stub_remove_parent(PARROT_INTERP, PMC* pmc, PMC* parent);
static void stub_add_role(PARROT_INTERP, PMC* pmc, PMC* role);
static void stub_remove_role(PARROT_INTERP, PMC* pmc, PMC* role);
static void stub_add_attribute(PARROT_INTERP, PMC* pmc, STRING* name, PMC* type);
static void stub_remove_attribute(PARROT_INTERP, PMC* pmc, STRING* name);
static void stub_add_method(PARROT_INTERP, PMC* pmc, STRING* method_name, PMC* sub_pmc);
static void stub_remove_method(PARROT_INTERP, PMC* pmc, STRING* method_name);
static void stub_add_vtable_override(PARROT_INTERP, PMC* pmc, STRING* vtable_name, PMC* sub_pmc);
static void stub_remove_vtable_override(PARROT_INTERP, PMC* pmc, STRING* vtable_name);
static PMC* stub_inspect(PARROT_INTERP, PMC* pmc);
static PMC* stub_inspect_str(PARROT_INTERP, PMC* pmc, STRING* what);
static void stub_freeze(PARROT_INTERP, PMC* pmc, PMC* info);
static void stub_thaw(PARROT_INTERP, PMC* pmc, PMC* info);
static void stub_thawfinish(PARROT_INTERP, PMC* pmc, PMC* info);
static void stub_visit(PARROT_INTERP, PMC* pmc, PMC* info);
static void stub_share(PARROT_INTERP, PMC* pmc);
static PMC* stub_share_ro(PARROT_INTERP, PMC* pmc);
static void stub_init_int(PARROT_INTERP, PMC* pmc, INTVAL initializer);
/* END vtable prototypes */

void setup_vtable_common_hashes(PARROT_INTERP) {
    PMC *temp;
    if (!vtable_first_run) return;

    vtable_first_run   = 0;
    vtable_registry    = parrot_new_pointer_hash(interp);
    vtable_name_stubs  = parrot_new_hash(interp);
    vtable_group_items = parrot_new_hash(interp);
    vtable_item_groups = parrot_new_hash(interp);

    /* BEGIN vtable mapping name stubs */
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "init"),
        stub_init);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "init_pmc"),
        stub_init_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "instantiate"),
        stub_instantiate);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "morph"),
        stub_morph);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "mark"),
        stub_mark);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "destroy"),
        stub_destroy);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_namespace"),
        stub_get_namespace);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "getprop"),
        stub_getprop);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "setprop"),
        stub_setprop);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "delprop"),
        stub_delprop);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "getprops"),
        stub_getprops);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "type"),
        stub_type);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "name"),
        stub_name);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "clone"),
        stub_clone);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "clone_pmc"),
        stub_clone_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "find_method"),
        stub_find_method);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_integer"),
        stub_get_integer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_integer_keyed"),
        stub_get_integer_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_integer_keyed_int"),
        stub_get_integer_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_integer_keyed_str"),
        stub_get_integer_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_number"),
        stub_get_number);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_number_keyed"),
        stub_get_number_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_number_keyed_int"),
        stub_get_number_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_number_keyed_str"),
        stub_get_number_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_string"),
        stub_get_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_repr"),
        stub_get_repr);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_string_keyed"),
        stub_get_string_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_string_keyed_int"),
        stub_get_string_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_string_keyed_str"),
        stub_get_string_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_bool"),
        stub_get_bool);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pmc"),
        stub_get_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pmc_keyed"),
        stub_get_pmc_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pmc_keyed_int"),
        stub_get_pmc_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pmc_keyed_str"),
        stub_get_pmc_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pointer"),
        stub_get_pointer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pointer_keyed"),
        stub_get_pointer_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pointer_keyed_int"),
        stub_get_pointer_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pointer_keyed_str"),
        stub_get_pointer_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_integer_native"),
        stub_set_integer_native);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_integer_keyed"),
        stub_set_integer_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_integer_keyed_int"),
        stub_set_integer_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_integer_keyed_str"),
        stub_set_integer_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_number_native"),
        stub_set_number_native);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_number_keyed"),
        stub_set_number_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_number_keyed_int"),
        stub_set_number_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_number_keyed_str"),
        stub_set_number_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_string_native"),
        stub_set_string_native);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "assign_string_native"),
        stub_assign_string_native);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_string_keyed"),
        stub_set_string_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_string_keyed_int"),
        stub_set_string_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_string_keyed_str"),
        stub_set_string_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_bool"),
        stub_set_bool);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pmc"),
        stub_set_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "assign_pmc"),
        stub_assign_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pmc_keyed"),
        stub_set_pmc_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pmc_keyed_int"),
        stub_set_pmc_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pmc_keyed_str"),
        stub_set_pmc_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pointer"),
        stub_set_pointer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pointer_keyed"),
        stub_set_pointer_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pointer_keyed_int"),
        stub_set_pointer_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pointer_keyed_str"),
        stub_set_pointer_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "elements"),
        stub_elements);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "pop_integer"),
        stub_pop_integer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "pop_float"),
        stub_pop_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "pop_string"),
        stub_pop_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "pop_pmc"),
        stub_pop_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "push_integer"),
        stub_push_integer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "push_float"),
        stub_push_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "push_string"),
        stub_push_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "push_pmc"),
        stub_push_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "shift_integer"),
        stub_shift_integer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "shift_float"),
        stub_shift_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "shift_string"),
        stub_shift_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "shift_pmc"),
        stub_shift_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "unshift_integer"),
        stub_unshift_integer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "unshift_float"),
        stub_unshift_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "unshift_string"),
        stub_unshift_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "unshift_pmc"),
        stub_unshift_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "splice"),
        stub_splice);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add"),
        stub_add);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_int"),
        stub_add_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_float"),
        stub_add_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_add"),
        stub_i_add);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_add_int"),
        stub_i_add_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_add_float"),
        stub_i_add_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "subtract"),
        stub_subtract);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "subtract_int"),
        stub_subtract_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "subtract_float"),
        stub_subtract_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_subtract"),
        stub_i_subtract);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_subtract_int"),
        stub_i_subtract_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_subtract_float"),
        stub_i_subtract_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "multiply"),
        stub_multiply);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "multiply_int"),
        stub_multiply_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "multiply_float"),
        stub_multiply_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_multiply"),
        stub_i_multiply);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_multiply_int"),
        stub_i_multiply_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_multiply_float"),
        stub_i_multiply_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "divide"),
        stub_divide);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "divide_int"),
        stub_divide_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "divide_float"),
        stub_divide_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_divide"),
        stub_i_divide);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_divide_int"),
        stub_i_divide_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_divide_float"),
        stub_i_divide_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "floor_divide"),
        stub_floor_divide);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "floor_divide_int"),
        stub_floor_divide_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "floor_divide_float"),
        stub_floor_divide_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_floor_divide"),
        stub_i_floor_divide);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_floor_divide_int"),
        stub_i_floor_divide_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_floor_divide_float"),
        stub_i_floor_divide_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "modulus"),
        stub_modulus);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "modulus_int"),
        stub_modulus_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "modulus_float"),
        stub_modulus_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_modulus"),
        stub_i_modulus);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_modulus_int"),
        stub_i_modulus_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_modulus_float"),
        stub_i_modulus_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "increment"),
        stub_increment);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "decrement"),
        stub_decrement);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "absolute"),
        stub_absolute);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_absolute"),
        stub_i_absolute);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "neg"),
        stub_neg);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_neg"),
        stub_i_neg);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "is_equal"),
        stub_is_equal);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "is_equal_num"),
        stub_is_equal_num);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "is_equal_string"),
        stub_is_equal_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "is_same"),
        stub_is_same);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "cmp"),
        stub_cmp);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "cmp_num"),
        stub_cmp_num);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "cmp_string"),
        stub_cmp_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "cmp_pmc"),
        stub_cmp_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "logical_or"),
        stub_logical_or);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "logical_and"),
        stub_logical_and);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "logical_xor"),
        stub_logical_xor);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "logical_not"),
        stub_logical_not);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_logical_not"),
        stub_i_logical_not);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "concatenate"),
        stub_concatenate);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "concatenate_str"),
        stub_concatenate_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_concatenate"),
        stub_i_concatenate);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_concatenate_str"),
        stub_i_concatenate_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "repeat"),
        stub_repeat);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "repeat_int"),
        stub_repeat_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_repeat"),
        stub_i_repeat);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_repeat_int"),
        stub_i_repeat_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "substr"),
        stub_substr);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "substr_str"),
        stub_substr_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "exists_keyed"),
        stub_exists_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "exists_keyed_int"),
        stub_exists_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "exists_keyed_str"),
        stub_exists_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "defined"),
        stub_defined);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "defined_keyed"),
        stub_defined_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "defined_keyed_int"),
        stub_defined_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "defined_keyed_str"),
        stub_defined_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "delete_keyed"),
        stub_delete_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "delete_keyed_int"),
        stub_delete_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "delete_keyed_str"),
        stub_delete_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_iter"),
        stub_get_iter);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "hashvalue"),
        stub_hashvalue);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "invoke"),
        stub_invoke);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "can"),
        stub_can);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "does_pmc"),
        stub_does_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "does"),
        stub_does);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "isa_pmc"),
        stub_isa_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "isa"),
        stub_isa);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_attr_str"),
        stub_get_attr_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_attr_keyed"),
        stub_get_attr_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_attr_str"),
        stub_set_attr_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_attr_keyed"),
        stub_set_attr_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_class"),
        stub_get_class);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_parent"),
        stub_add_parent);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "remove_parent"),
        stub_remove_parent);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_role"),
        stub_add_role);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "remove_role"),
        stub_remove_role);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_attribute"),
        stub_add_attribute);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "remove_attribute"),
        stub_remove_attribute);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_method"),
        stub_add_method);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "remove_method"),
        stub_remove_method);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_vtable_override"),
        stub_add_vtable_override);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "remove_vtable_override"),
        stub_remove_vtable_override);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "inspect"),
        stub_inspect);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "inspect_str"),
        stub_inspect_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "freeze"),
        stub_freeze);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "thaw"),
        stub_thaw);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "thawfinish"),
        stub_thawfinish);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "visit"),
        stub_visit);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "share"),
        stub_share);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "share_ro"),
        stub_share_ro);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "init_int"),
        stub_init_int);
    /* END vtable mapping name stubs */

    /* BEGIN vtable mapping group items */
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "exists_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "exists_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "exists_keyed_str"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "exists"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_integer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_integer_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_integer_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_integer_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_number"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_number_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_number_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_number_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_repr"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_string_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_string_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_string_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_bool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pmc_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pmc_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pmc_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pointer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pointer_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pointer_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pointer_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_integer_native"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_integer_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_integer_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_integer_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_number_native"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_number_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_number_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_number_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_string_native"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "assign_string_native"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_string_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_string_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_string_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_bool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "assign_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pmc_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pmc_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pmc_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pointer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pointer_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pointer_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pointer_keyed_str"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "fetch"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "init"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "init_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "instantiate"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "morph"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "destroy"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_namespace"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "getprop"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "setprop"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "delprop"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "getprops"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "type"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "name"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "clone"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "clone_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "find_method"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_integer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_integer_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_integer_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_integer_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_number"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_number_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_number_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_number_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_repr"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_string_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_string_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_string_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_bool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pmc_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pmc_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pmc_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pointer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pointer_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pointer_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_pointer_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_integer_native"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_integer_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_integer_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_integer_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_number_native"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_number_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_number_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_number_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_string_native"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "assign_string_native"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_string_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_string_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_string_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_bool"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "assign_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pmc_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pmc_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pmc_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pointer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pointer_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pointer_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_pointer_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "elements"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pop_integer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pop_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pop_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pop_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "push_integer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "push_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "push_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "push_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "shift_integer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "shift_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "shift_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "shift_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unshift_integer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unshift_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unshift_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unshift_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "splice"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_add"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_add_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_add_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "subtract"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "subtract_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "subtract_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_subtract"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_subtract_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_subtract_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "multiply"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "multiply_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "multiply_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_multiply"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_multiply_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_multiply_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "divide"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "divide_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "divide_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_divide"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_divide_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_divide_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "floor_divide"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "floor_divide_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "floor_divide_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_floor_divide"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_floor_divide_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_floor_divide_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "modulus"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "modulus_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "modulus_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_modulus"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_modulus_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_modulus_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "increment"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "decrement"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "absolute"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_absolute"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "neg"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_neg"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "is_equal"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "is_equal_num"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "is_equal_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "is_same"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp_num"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "logical_or"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "logical_and"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "logical_xor"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "logical_not"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_logical_not"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "concatenate"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "concatenate_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_concatenate"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_concatenate_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "repeat"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "repeat_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_repeat"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_repeat_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "substr"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "substr_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "exists_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "exists_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "exists_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "defined"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "defined_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "defined_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "defined_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "delete_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "delete_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "delete_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_iter"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "hashvalue"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "invoke"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "can"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "does_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "does"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "isa_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "isa"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_attr_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_attr_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_attr_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_attr_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_class"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_parent"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_parent"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_role"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_role"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_attribute"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_attribute"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_method"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_method"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_vtable_override"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_vtable_override"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "inspect"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "inspect_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "freeze"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "thaw"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "thawfinish"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "visit"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "share"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "share_ro"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "init_int"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "all"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "concatenate"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "concatenate_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_concatenate"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_concatenate_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "repeat"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "repeat_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_repeat"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_repeat_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "substr"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "substr_str"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "string"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "defined"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "defined_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "defined_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "defined_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "delete_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "delete_keyed_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "delete_keyed_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_iter"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "hashvalue"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "invoke"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "can"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "does_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "does"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "isa_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "isa"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_attr_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_attr_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_attr_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_attr_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_class"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_parent"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_parent"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_role"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_role"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_attribute"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_attribute"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_method"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_method"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_vtable_override"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_vtable_override"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "inspect"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "inspect_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "freeze"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "thaw"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "thawfinish"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "visit"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "share"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "share_ro"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "init_int"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "main"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_add"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_add_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_add_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "subtract"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "subtract_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "subtract_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_subtract"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_subtract_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_subtract_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "multiply"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "multiply_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "multiply_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_multiply"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_multiply_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_multiply_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "divide"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "divide_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "divide_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_divide"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_divide_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_divide_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "floor_divide"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "floor_divide_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "floor_divide_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_floor_divide"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_floor_divide_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_floor_divide_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "modulus"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "modulus_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "modulus_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_modulus"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_modulus_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_modulus_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "increment"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "decrement"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "absolute"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_absolute"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "neg"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_neg"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "math"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "elements"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pop_integer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pop_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pop_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "pop_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "push_integer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "push_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "push_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "push_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "shift_integer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "shift_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "shift_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "shift_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unshift_integer"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unshift_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unshift_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "unshift_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "splice"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "fetchsize"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "is_equal"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "is_equal_num"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "is_equal_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "is_same"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp_num"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp_string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "logical_or"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "logical_and"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "logical_xor"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "logical_not"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_logical_not"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "cmp"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "morph"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_add"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_add_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_add_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_subtract"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_subtract_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_subtract_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_multiply"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_multiply_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_multiply_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_divide"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_divide_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_divide_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_floor_divide"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_floor_divide_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_floor_divide_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_modulus"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_modulus_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_modulus_float"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "increment"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "decrement"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_absolute"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_neg"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_logical_not"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_concatenate"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_concatenate_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_repeat"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "i_repeat_int"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_attr_str"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "set_attr_keyed"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_parent"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_parent"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_role"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_role"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_attribute"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_attribute"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_method"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_method"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "add_vtable_override"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "remove_vtable_override"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "thaw"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "thawfinish"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "write"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "init"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "init_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "instantiate"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "morph"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "mark"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "destroy"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "get_namespace"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "getprop"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "setprop"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "delprop"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "getprops"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "type"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "name"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "clone"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "clone_pmc"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "find_method"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "core"),
        temp);
    /* END vtable mapping group items */

    /* BEGIN vtable mapping item groups */
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "init"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "init_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "instantiate"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "morph"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "mark"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "destroy"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_namespace"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "getprop"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "setprop"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "delprop"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "getprops"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "type"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "name"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "clone"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "clone_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "core"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "find_method"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_integer"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_integer_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_integer_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_integer_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_number"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_number_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_number_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_number_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_string"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_repr"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_string_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_string_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_string_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_bool"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_pmc_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_pmc_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_pmc_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_pointer"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_pointer_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_pointer_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_pointer_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_integer_native"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_integer_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_integer_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_integer_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_number_native"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_number_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_number_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_number_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_string_native"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "assign_string_native"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_string_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_string_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_string_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_bool"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "assign_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_pmc_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_pmc_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_pmc_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_pointer"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_pointer_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_pointer_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_pointer_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "elements"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "pop_integer"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "pop_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "pop_string"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "pop_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "push_integer"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "push_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "push_string"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "push_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "shift_integer"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "shift_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "shift_string"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "shift_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "unshift_integer"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "unshift_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "unshift_string"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "unshift_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "splice"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "add"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "add_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "add_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_add"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_add_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_add_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "subtract"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "subtract_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "subtract_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_subtract"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_subtract_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_subtract_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "multiply"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "multiply_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "multiply_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_multiply"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_multiply_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_multiply_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "divide"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "divide_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "divide_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_divide"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_divide_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_divide_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "floor_divide"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "floor_divide_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "floor_divide_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_floor_divide"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_floor_divide_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_floor_divide_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "modulus"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "modulus_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "modulus_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_modulus"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_modulus_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_modulus_float"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "increment"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "decrement"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "absolute"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_absolute"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "neg"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "math"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_neg"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "is_equal"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "is_equal_num"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "is_equal_string"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "is_same"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "cmp"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "cmp_num"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "cmp_string"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "cmp_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "logical_or"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "logical_and"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "logical_xor"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "logical_not"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "cmp"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_logical_not"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "concatenate"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "concatenate_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_concatenate"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_concatenate_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "repeat"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "repeat_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_repeat"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "string"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "i_repeat_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "substr"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "substr_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "exists"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "exists_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "exists"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "exists_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "exists"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "exists_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "defined"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "defined_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "defined_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "defined_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "delete_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "delete_keyed_int"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "delete_keyed_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_iter"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "hashvalue"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "invoke"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "can"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "does_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "does"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "isa_pmc"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "isa"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_attr_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_attr_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_attr_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "set_attr_keyed"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "get_class"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "add_parent"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "remove_parent"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "add_role"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "remove_role"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "add_attribute"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "remove_attribute"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "add_method"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "remove_method"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "add_vtable_override"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "remove_vtable_override"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "inspect"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "inspect_str"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "freeze"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "thaw"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "write"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "thawfinish"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "visit"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "share"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "share_ro"),
        temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp,
                       CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups,
        CONST_STRING(interp, "init_int"),
        temp);
    /* END vtable mapping item groups */
}

void destroy_vtable_common_hashes(PARROT_INTERP) {
    if (parrot_hash_size(interp, vtable_registry) == 0) {
        parrot_hash_destroy(interp, vtable_registry);
        parrot_hash_destroy(interp, vtable_name_stubs);
        parrot_hash_destroy(interp, vtable_group_items);
        parrot_hash_destroy(interp, vtable_item_groups);

        vtable_first_run = 1;
    }
}

void setup_vtable_individual_hashes(PARROT_INTERP, Hash *orig_hash, Hash *instr_hash,
                                    _vtable *vt_orig, _vtable *vt_instr) {
    /* BEGIN vtable mapping name offset */
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "init"),
        &(vt_instr->init));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "init_pmc"),
        &(vt_instr->init_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "instantiate"),
        &(vt_instr->instantiate));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "morph"),
        &(vt_instr->morph));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "mark"),
        &(vt_instr->mark));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "destroy"),
        &(vt_instr->destroy));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_namespace"),
        &(vt_instr->get_namespace));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "getprop"),
        &(vt_instr->getprop));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "setprop"),
        &(vt_instr->setprop));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "delprop"),
        &(vt_instr->delprop));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "getprops"),
        &(vt_instr->getprops));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "type"),
        &(vt_instr->type));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "name"),
        &(vt_instr->name));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "clone"),
        &(vt_instr->clone));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "clone_pmc"),
        &(vt_instr->clone_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "find_method"),
        &(vt_instr->find_method));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_integer"),
        &(vt_instr->get_integer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_integer_keyed"),
        &(vt_instr->get_integer_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_integer_keyed_int"),
        &(vt_instr->get_integer_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_integer_keyed_str"),
        &(vt_instr->get_integer_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_number"),
        &(vt_instr->get_number));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_number_keyed"),
        &(vt_instr->get_number_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_number_keyed_int"),
        &(vt_instr->get_number_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_number_keyed_str"),
        &(vt_instr->get_number_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_string"),
        &(vt_instr->get_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_repr"),
        &(vt_instr->get_repr));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_string_keyed"),
        &(vt_instr->get_string_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_string_keyed_int"),
        &(vt_instr->get_string_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_string_keyed_str"),
        &(vt_instr->get_string_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_bool"),
        &(vt_instr->get_bool));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pmc"),
        &(vt_instr->get_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pmc_keyed"),
        &(vt_instr->get_pmc_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pmc_keyed_int"),
        &(vt_instr->get_pmc_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pmc_keyed_str"),
        &(vt_instr->get_pmc_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pointer"),
        &(vt_instr->get_pointer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pointer_keyed"),
        &(vt_instr->get_pointer_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pointer_keyed_int"),
        &(vt_instr->get_pointer_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pointer_keyed_str"),
        &(vt_instr->get_pointer_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_integer_native"),
        &(vt_instr->set_integer_native));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_integer_keyed"),
        &(vt_instr->set_integer_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_integer_keyed_int"),
        &(vt_instr->set_integer_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_integer_keyed_str"),
        &(vt_instr->set_integer_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_number_native"),
        &(vt_instr->set_number_native));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_number_keyed"),
        &(vt_instr->set_number_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_number_keyed_int"),
        &(vt_instr->set_number_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_number_keyed_str"),
        &(vt_instr->set_number_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_string_native"),
        &(vt_instr->set_string_native));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "assign_string_native"),
        &(vt_instr->assign_string_native));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_string_keyed"),
        &(vt_instr->set_string_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_string_keyed_int"),
        &(vt_instr->set_string_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_string_keyed_str"),
        &(vt_instr->set_string_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_bool"),
        &(vt_instr->set_bool));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pmc"),
        &(vt_instr->set_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "assign_pmc"),
        &(vt_instr->assign_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pmc_keyed"),
        &(vt_instr->set_pmc_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pmc_keyed_int"),
        &(vt_instr->set_pmc_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pmc_keyed_str"),
        &(vt_instr->set_pmc_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pointer"),
        &(vt_instr->set_pointer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pointer_keyed"),
        &(vt_instr->set_pointer_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pointer_keyed_int"),
        &(vt_instr->set_pointer_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pointer_keyed_str"),
        &(vt_instr->set_pointer_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "elements"),
        &(vt_instr->elements));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "pop_integer"),
        &(vt_instr->pop_integer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "pop_float"),
        &(vt_instr->pop_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "pop_string"),
        &(vt_instr->pop_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "pop_pmc"),
        &(vt_instr->pop_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "push_integer"),
        &(vt_instr->push_integer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "push_float"),
        &(vt_instr->push_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "push_string"),
        &(vt_instr->push_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "push_pmc"),
        &(vt_instr->push_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "shift_integer"),
        &(vt_instr->shift_integer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "shift_float"),
        &(vt_instr->shift_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "shift_string"),
        &(vt_instr->shift_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "shift_pmc"),
        &(vt_instr->shift_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unshift_integer"),
        &(vt_instr->unshift_integer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unshift_float"),
        &(vt_instr->unshift_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unshift_string"),
        &(vt_instr->unshift_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unshift_pmc"),
        &(vt_instr->unshift_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "splice"),
        &(vt_instr->splice));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add"),
        &(vt_instr->add));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_int"),
        &(vt_instr->add_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_float"),
        &(vt_instr->add_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_add"),
        &(vt_instr->i_add));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_add_int"),
        &(vt_instr->i_add_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_add_float"),
        &(vt_instr->i_add_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "subtract"),
        &(vt_instr->subtract));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "subtract_int"),
        &(vt_instr->subtract_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "subtract_float"),
        &(vt_instr->subtract_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_subtract"),
        &(vt_instr->i_subtract));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_subtract_int"),
        &(vt_instr->i_subtract_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_subtract_float"),
        &(vt_instr->i_subtract_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "multiply"),
        &(vt_instr->multiply));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "multiply_int"),
        &(vt_instr->multiply_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "multiply_float"),
        &(vt_instr->multiply_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_multiply"),
        &(vt_instr->i_multiply));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_multiply_int"),
        &(vt_instr->i_multiply_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_multiply_float"),
        &(vt_instr->i_multiply_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "divide"),
        &(vt_instr->divide));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "divide_int"),
        &(vt_instr->divide_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "divide_float"),
        &(vt_instr->divide_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_divide"),
        &(vt_instr->i_divide));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_divide_int"),
        &(vt_instr->i_divide_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_divide_float"),
        &(vt_instr->i_divide_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "floor_divide"),
        &(vt_instr->floor_divide));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "floor_divide_int"),
        &(vt_instr->floor_divide_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "floor_divide_float"),
        &(vt_instr->floor_divide_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_floor_divide"),
        &(vt_instr->i_floor_divide));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_floor_divide_int"),
        &(vt_instr->i_floor_divide_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_floor_divide_float"),
        &(vt_instr->i_floor_divide_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "modulus"),
        &(vt_instr->modulus));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "modulus_int"),
        &(vt_instr->modulus_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "modulus_float"),
        &(vt_instr->modulus_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_modulus"),
        &(vt_instr->i_modulus));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_modulus_int"),
        &(vt_instr->i_modulus_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_modulus_float"),
        &(vt_instr->i_modulus_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "increment"),
        &(vt_instr->increment));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "decrement"),
        &(vt_instr->decrement));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "absolute"),
        &(vt_instr->absolute));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_absolute"),
        &(vt_instr->i_absolute));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "neg"),
        &(vt_instr->neg));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_neg"),
        &(vt_instr->i_neg));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "is_equal"),
        &(vt_instr->is_equal));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "is_equal_num"),
        &(vt_instr->is_equal_num));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "is_equal_string"),
        &(vt_instr->is_equal_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "is_same"),
        &(vt_instr->is_same));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "cmp"),
        &(vt_instr->cmp));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "cmp_num"),
        &(vt_instr->cmp_num));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "cmp_string"),
        &(vt_instr->cmp_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "cmp_pmc"),
        &(vt_instr->cmp_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "logical_or"),
        &(vt_instr->logical_or));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "logical_and"),
        &(vt_instr->logical_and));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "logical_xor"),
        &(vt_instr->logical_xor));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "logical_not"),
        &(vt_instr->logical_not));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_logical_not"),
        &(vt_instr->i_logical_not));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "concatenate"),
        &(vt_instr->concatenate));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "concatenate_str"),
        &(vt_instr->concatenate_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_concatenate"),
        &(vt_instr->i_concatenate));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_concatenate_str"),
        &(vt_instr->i_concatenate_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "repeat"),
        &(vt_instr->repeat));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "repeat_int"),
        &(vt_instr->repeat_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_repeat"),
        &(vt_instr->i_repeat));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_repeat_int"),
        &(vt_instr->i_repeat_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "substr"),
        &(vt_instr->substr));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "substr_str"),
        &(vt_instr->substr_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "exists_keyed"),
        &(vt_instr->exists_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "exists_keyed_int"),
        &(vt_instr->exists_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "exists_keyed_str"),
        &(vt_instr->exists_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "defined"),
        &(vt_instr->defined));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "defined_keyed"),
        &(vt_instr->defined_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "defined_keyed_int"),
        &(vt_instr->defined_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "defined_keyed_str"),
        &(vt_instr->defined_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "delete_keyed"),
        &(vt_instr->delete_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "delete_keyed_int"),
        &(vt_instr->delete_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "delete_keyed_str"),
        &(vt_instr->delete_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_iter"),
        &(vt_instr->get_iter));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "hashvalue"),
        &(vt_instr->hashvalue));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "invoke"),
        &(vt_instr->invoke));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "can"),
        &(vt_instr->can));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "does_pmc"),
        &(vt_instr->does_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "does"),
        &(vt_instr->does));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "isa_pmc"),
        &(vt_instr->isa_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "isa"),
        &(vt_instr->isa));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_attr_str"),
        &(vt_instr->get_attr_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_attr_keyed"),
        &(vt_instr->get_attr_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_attr_str"),
        &(vt_instr->set_attr_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_attr_keyed"),
        &(vt_instr->set_attr_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_class"),
        &(vt_instr->get_class));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_parent"),
        &(vt_instr->add_parent));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "remove_parent"),
        &(vt_instr->remove_parent));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_role"),
        &(vt_instr->add_role));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "remove_role"),
        &(vt_instr->remove_role));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_attribute"),
        &(vt_instr->add_attribute));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "remove_attribute"),
        &(vt_instr->remove_attribute));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_method"),
        &(vt_instr->add_method));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "remove_method"),
        &(vt_instr->remove_method));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_vtable_override"),
        &(vt_instr->add_vtable_override));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "remove_vtable_override"),
        &(vt_instr->remove_vtable_override));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "inspect"),
        &(vt_instr->inspect));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "inspect_str"),
        &(vt_instr->inspect_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "freeze"),
        &(vt_instr->freeze));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "thaw"),
        &(vt_instr->thaw));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "thawfinish"),
        &(vt_instr->thawfinish));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "visit"),
        &(vt_instr->visit));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "share"),
        &(vt_instr->share));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "share_ro"),
        &(vt_instr->share_ro));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "init_int"),
        &(vt_instr->init_int));
    /* END vtable mapping name offset */

    /* BEGIN vtable mapping name original */
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "init"),
        vt_orig->init);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "init_pmc"),
        vt_orig->init_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "instantiate"),
        vt_orig->instantiate);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "morph"),
        vt_orig->morph);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "mark"),
        vt_orig->mark);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "destroy"),
        vt_orig->destroy);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_namespace"),
        vt_orig->get_namespace);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "getprop"),
        vt_orig->getprop);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "setprop"),
        vt_orig->setprop);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "delprop"),
        vt_orig->delprop);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "getprops"),
        vt_orig->getprops);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "type"),
        vt_orig->type);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "name"),
        vt_orig->name);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "clone"),
        vt_orig->clone);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "clone_pmc"),
        vt_orig->clone_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "find_method"),
        vt_orig->find_method);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_integer"),
        vt_orig->get_integer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_integer_keyed"),
        vt_orig->get_integer_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_integer_keyed_int"),
        vt_orig->get_integer_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_integer_keyed_str"),
        vt_orig->get_integer_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_number"),
        vt_orig->get_number);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_number_keyed"),
        vt_orig->get_number_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_number_keyed_int"),
        vt_orig->get_number_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_number_keyed_str"),
        vt_orig->get_number_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_string"),
        vt_orig->get_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_repr"),
        vt_orig->get_repr);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_string_keyed"),
        vt_orig->get_string_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_string_keyed_int"),
        vt_orig->get_string_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_string_keyed_str"),
        vt_orig->get_string_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_bool"),
        vt_orig->get_bool);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pmc"),
        vt_orig->get_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pmc_keyed"),
        vt_orig->get_pmc_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pmc_keyed_int"),
        vt_orig->get_pmc_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pmc_keyed_str"),
        vt_orig->get_pmc_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pointer"),
        vt_orig->get_pointer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pointer_keyed"),
        vt_orig->get_pointer_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pointer_keyed_int"),
        vt_orig->get_pointer_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pointer_keyed_str"),
        vt_orig->get_pointer_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_integer_native"),
        vt_orig->set_integer_native);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_integer_keyed"),
        vt_orig->set_integer_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_integer_keyed_int"),
        vt_orig->set_integer_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_integer_keyed_str"),
        vt_orig->set_integer_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_number_native"),
        vt_orig->set_number_native);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_number_keyed"),
        vt_orig->set_number_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_number_keyed_int"),
        vt_orig->set_number_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_number_keyed_str"),
        vt_orig->set_number_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_string_native"),
        vt_orig->set_string_native);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "assign_string_native"),
        vt_orig->assign_string_native);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_string_keyed"),
        vt_orig->set_string_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_string_keyed_int"),
        vt_orig->set_string_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_string_keyed_str"),
        vt_orig->set_string_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_bool"),
        vt_orig->set_bool);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pmc"),
        vt_orig->set_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "assign_pmc"),
        vt_orig->assign_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pmc_keyed"),
        vt_orig->set_pmc_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pmc_keyed_int"),
        vt_orig->set_pmc_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pmc_keyed_str"),
        vt_orig->set_pmc_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pointer"),
        vt_orig->set_pointer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pointer_keyed"),
        vt_orig->set_pointer_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pointer_keyed_int"),
        vt_orig->set_pointer_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pointer_keyed_str"),
        vt_orig->set_pointer_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "elements"),
        vt_orig->elements);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "pop_integer"),
        vt_orig->pop_integer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "pop_float"),
        vt_orig->pop_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "pop_string"),
        vt_orig->pop_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "pop_pmc"),
        vt_orig->pop_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "push_integer"),
        vt_orig->push_integer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "push_float"),
        vt_orig->push_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "push_string"),
        vt_orig->push_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "push_pmc"),
        vt_orig->push_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "shift_integer"),
        vt_orig->shift_integer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "shift_float"),
        vt_orig->shift_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "shift_string"),
        vt_orig->shift_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "shift_pmc"),
        vt_orig->shift_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unshift_integer"),
        vt_orig->unshift_integer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unshift_float"),
        vt_orig->unshift_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unshift_string"),
        vt_orig->unshift_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unshift_pmc"),
        vt_orig->unshift_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "splice"),
        vt_orig->splice);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add"),
        vt_orig->add);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_int"),
        vt_orig->add_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_float"),
        vt_orig->add_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_add"),
        vt_orig->i_add);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_add_int"),
        vt_orig->i_add_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_add_float"),
        vt_orig->i_add_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "subtract"),
        vt_orig->subtract);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "subtract_int"),
        vt_orig->subtract_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "subtract_float"),
        vt_orig->subtract_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_subtract"),
        vt_orig->i_subtract);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_subtract_int"),
        vt_orig->i_subtract_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_subtract_float"),
        vt_orig->i_subtract_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "multiply"),
        vt_orig->multiply);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "multiply_int"),
        vt_orig->multiply_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "multiply_float"),
        vt_orig->multiply_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_multiply"),
        vt_orig->i_multiply);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_multiply_int"),
        vt_orig->i_multiply_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_multiply_float"),
        vt_orig->i_multiply_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "divide"),
        vt_orig->divide);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "divide_int"),
        vt_orig->divide_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "divide_float"),
        vt_orig->divide_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_divide"),
        vt_orig->i_divide);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_divide_int"),
        vt_orig->i_divide_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_divide_float"),
        vt_orig->i_divide_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "floor_divide"),
        vt_orig->floor_divide);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "floor_divide_int"),
        vt_orig->floor_divide_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "floor_divide_float"),
        vt_orig->floor_divide_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_floor_divide"),
        vt_orig->i_floor_divide);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_floor_divide_int"),
        vt_orig->i_floor_divide_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_floor_divide_float"),
        vt_orig->i_floor_divide_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "modulus"),
        vt_orig->modulus);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "modulus_int"),
        vt_orig->modulus_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "modulus_float"),
        vt_orig->modulus_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_modulus"),
        vt_orig->i_modulus);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_modulus_int"),
        vt_orig->i_modulus_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_modulus_float"),
        vt_orig->i_modulus_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "increment"),
        vt_orig->increment);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "decrement"),
        vt_orig->decrement);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "absolute"),
        vt_orig->absolute);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_absolute"),
        vt_orig->i_absolute);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "neg"),
        vt_orig->neg);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_neg"),
        vt_orig->i_neg);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "is_equal"),
        vt_orig->is_equal);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "is_equal_num"),
        vt_orig->is_equal_num);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "is_equal_string"),
        vt_orig->is_equal_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "is_same"),
        vt_orig->is_same);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "cmp"),
        vt_orig->cmp);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "cmp_num"),
        vt_orig->cmp_num);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "cmp_string"),
        vt_orig->cmp_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "cmp_pmc"),
        vt_orig->cmp_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "logical_or"),
        vt_orig->logical_or);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "logical_and"),
        vt_orig->logical_and);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "logical_xor"),
        vt_orig->logical_xor);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "logical_not"),
        vt_orig->logical_not);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_logical_not"),
        vt_orig->i_logical_not);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "concatenate"),
        vt_orig->concatenate);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "concatenate_str"),
        vt_orig->concatenate_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_concatenate"),
        vt_orig->i_concatenate);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_concatenate_str"),
        vt_orig->i_concatenate_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "repeat"),
        vt_orig->repeat);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "repeat_int"),
        vt_orig->repeat_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_repeat"),
        vt_orig->i_repeat);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_repeat_int"),
        vt_orig->i_repeat_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "substr"),
        vt_orig->substr);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "substr_str"),
        vt_orig->substr_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "exists_keyed"),
        vt_orig->exists_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "exists_keyed_int"),
        vt_orig->exists_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "exists_keyed_str"),
        vt_orig->exists_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "defined"),
        vt_orig->defined);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "defined_keyed"),
        vt_orig->defined_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "defined_keyed_int"),
        vt_orig->defined_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "defined_keyed_str"),
        vt_orig->defined_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "delete_keyed"),
        vt_orig->delete_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "delete_keyed_int"),
        vt_orig->delete_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "delete_keyed_str"),
        vt_orig->delete_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_iter"),
        vt_orig->get_iter);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "hashvalue"),
        vt_orig->hashvalue);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "invoke"),
        vt_orig->invoke);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "can"),
        vt_orig->can);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "does_pmc"),
        vt_orig->does_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "does"),
        vt_orig->does);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "isa_pmc"),
        vt_orig->isa_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "isa"),
        vt_orig->isa);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_attr_str"),
        vt_orig->get_attr_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_attr_keyed"),
        vt_orig->get_attr_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_attr_str"),
        vt_orig->set_attr_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_attr_keyed"),
        vt_orig->set_attr_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_class"),
        vt_orig->get_class);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_parent"),
        vt_orig->add_parent);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "remove_parent"),
        vt_orig->remove_parent);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_role"),
        vt_orig->add_role);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "remove_role"),
        vt_orig->remove_role);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_attribute"),
        vt_orig->add_attribute);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "remove_attribute"),
        vt_orig->remove_attribute);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_method"),
        vt_orig->add_method);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "remove_method"),
        vt_orig->remove_method);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_vtable_override"),
        vt_orig->add_vtable_override);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "remove_vtable_override"),
        vt_orig->remove_vtable_override);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "inspect"),
        vt_orig->inspect);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "inspect_str"),
        vt_orig->inspect_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "freeze"),
        vt_orig->freeze);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "thaw"),
        vt_orig->thaw);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "thawfinish"),
        vt_orig->thawfinish);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "visit"),
        vt_orig->visit);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "share"),
        vt_orig->share);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "share_ro"),
        vt_orig->share_ro);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "init_int"),
        vt_orig->init_int);
    /* END vtable mapping name original */
}

/* BEGIN vtable stubs */
static
void stub_init(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->init(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "init"));

    return;
}

static
void stub_init_pmc(PARROT_INTERP, PMC* pmc, PMC* initializer) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->init_pmc(interp, pmc, initializer);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, initializer);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "init_pmc"));

    return;
}

static
PMC* stub_instantiate(PARROT_INTERP, PMC* pmc, PMC* sig) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->instantiate(interp, pmc, sig);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, sig);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "instantiate"));

    return ret;
}

static
void stub_morph(PARROT_INTERP, PMC* pmc, PMC* type) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->morph(interp, pmc, type);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, type);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "morph"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "morph"));

    return;
}

static
void stub_mark(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->mark(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "mark"));

    return;
}

static
void stub_destroy(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->destroy(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "destroy"));

    return;
}

static
PMC* stub_get_namespace(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_namespace(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "get_namespace"));

    return ret;
}

static
PMC* stub_getprop(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->getprop(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "getprop"));

    return ret;
}

static
void stub_setprop(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->setprop(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "setprop"));

    return;
}

static
void stub_delprop(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->delprop(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "delprop"));

    return;
}

static
PMC* stub_getprops(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->getprops(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "getprops"));

    return ret;
}

static
INTVAL stub_type(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->type(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "type"));

    return ret;
}

static
STRING* stub_name(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->name(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "name"));

    return ret;
}

static
PMC* stub_clone(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->clone(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "clone"));

    return ret;
}

static
PMC* stub_clone_pmc(PARROT_INTERP, PMC* pmc, PMC* args) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->clone_pmc(interp, pmc, args);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, args);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "clone_pmc"));

    return ret;
}

static
PMC* stub_find_method(PARROT_INTERP, PMC* pmc, STRING* method_name) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->find_method(interp, pmc, method_name);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, method_name);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "find_method"));

    return ret;
}

static
INTVAL stub_get_integer(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_integer(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_integer"));

    return ret;
}

static
INTVAL stub_get_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_integer_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_integer_keyed"));

    return ret;
}

static
INTVAL stub_get_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_integer_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_integer_keyed_int"));

    return ret;
}

static
INTVAL stub_get_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_integer_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_integer_keyed_str"));

    return ret;
}

static
FLOATVAL stub_get_number(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_number(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_number"));

    return ret;
}

static
FLOATVAL stub_get_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_number_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_number_keyed"));

    return ret;
}

static
FLOATVAL stub_get_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_number_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_number_keyed_int"));

    return ret;
}

static
FLOATVAL stub_get_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_number_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_number_keyed_str"));

    return ret;
}

static
STRING* stub_get_string(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_string(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_string"));

    return ret;
}

static
STRING* stub_get_repr(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_repr(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_repr"));

    return ret;
}

static
STRING* stub_get_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_string_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_string_keyed"));

    return ret;
}

static
STRING* stub_get_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_string_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_string_keyed_int"));

    return ret;
}

static
STRING* stub_get_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_string_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_string_keyed_str"));

    return ret;
}

static
INTVAL stub_get_bool(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_bool(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_bool"));

    return ret;
}

static
PMC* stub_get_pmc(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_pmc(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pmc"));

    return ret;
}

static
PMC* stub_get_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_pmc_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pmc_keyed"));

    return ret;
}

static
PMC* stub_get_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_pmc_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pmc_keyed_int"));

    return ret;
}

static
PMC* stub_get_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_pmc_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pmc_keyed_str"));

    return ret;
}

static
void* stub_get_pointer(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    void* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_pointer(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pointer"));

    return ret;
}

static
void* stub_get_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    void* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_pointer_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pointer_keyed"));

    return ret;
}

static
void* stub_get_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    void* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_pointer_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pointer_keyed_int"));

    return ret;
}

static
void* stub_get_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    void* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_pointer_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pointer_keyed_str"));

    return ret;
}

static
void stub_set_integer_native(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_integer_native(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_integer_native"));

    return;
}

static
void stub_set_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_integer_keyed(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_integer_keyed"));

    return;
}

static
void stub_set_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_integer_keyed_int(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_integer_keyed_int"));

    return;
}

static
void stub_set_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_integer_keyed_str(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_integer_keyed_str"));

    return;
}

static
void stub_set_number_native(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_number_native(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_number_native"));

    return;
}

static
void stub_set_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_number_keyed(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_number_keyed"));

    return;
}

static
void stub_set_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_number_keyed_int(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_number_keyed_int"));

    return;
}

static
void stub_set_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_number_keyed_str(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_number_keyed_str"));

    return;
}

static
void stub_set_string_native(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_string_native(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_string_native"));

    return;
}

static
void stub_assign_string_native(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->assign_string_native(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "assign_string_native"));

    return;
}

static
void stub_set_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_string_keyed(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_string_keyed"));

    return;
}

static
void stub_set_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, STRING* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_string_keyed_int(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_string_keyed_int"));

    return;
}

static
void stub_set_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, STRING* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_string_keyed_str(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_string_keyed_str"));

    return;
}

static
void stub_set_bool(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_bool(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_bool"));

    return;
}

static
void stub_set_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_pmc(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pmc"));

    return;
}

static
void stub_assign_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->assign_pmc(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "assign_pmc"));

    return;
}

static
void stub_set_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_pmc_keyed(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pmc_keyed"));

    return;
}

static
void stub_set_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_pmc_keyed_int(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pmc_keyed_int"));

    return;
}

static
void stub_set_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_pmc_keyed_str(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pmc_keyed_str"));

    return;
}

static
void stub_set_pointer(PARROT_INTERP, PMC* pmc, void* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_pointer(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pointer"));

    return;
}

static
void stub_set_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, void* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_pointer_keyed(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pointer_keyed"));

    return;
}

static
void stub_set_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, void* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_pointer_keyed_int(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pointer_keyed_int"));

    return;
}

static
void stub_set_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, void* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_pointer_keyed_str(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pointer_keyed_str"));

    return;
}

static
INTVAL stub_elements(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->elements(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "elements"));

    return ret;
}

static
INTVAL stub_pop_integer(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->pop_integer(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "pop_integer"));

    return ret;
}

static
FLOATVAL stub_pop_float(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->pop_float(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "pop_float"));

    return ret;
}

static
STRING* stub_pop_string(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->pop_string(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "pop_string"));

    return ret;
}

static
PMC* stub_pop_pmc(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->pop_pmc(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "pop_pmc"));

    return ret;
}

static
void stub_push_integer(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->push_integer(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "push_integer"));

    return;
}

static
void stub_push_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->push_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "push_float"));

    return;
}

static
void stub_push_string(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->push_string(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "push_string"));

    return;
}

static
void stub_push_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->push_pmc(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "push_pmc"));

    return;
}

static
INTVAL stub_shift_integer(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->shift_integer(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "shift_integer"));

    return ret;
}

static
FLOATVAL stub_shift_float(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->shift_float(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "shift_float"));

    return ret;
}

static
STRING* stub_shift_string(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->shift_string(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "shift_string"));

    return ret;
}

static
PMC* stub_shift_pmc(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->shift_pmc(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "shift_pmc"));

    return ret;
}

static
void stub_unshift_integer(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->unshift_integer(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "unshift_integer"));

    return;
}

static
void stub_unshift_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->unshift_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "unshift_float"));

    return;
}

static
void stub_unshift_string(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->unshift_string(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "unshift_string"));

    return;
}

static
void stub_unshift_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->unshift_pmc(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "unshift_pmc"));

    return;
}

static
void stub_splice(PARROT_INTERP, PMC* pmc, PMC* value, INTVAL offset, INTVAL count) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->splice(interp, pmc, value, offset, count);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, offset);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, count);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "splice"));

    return;
}

static
PMC* stub_add(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->add(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "add"));

    return ret;
}

static
PMC* stub_add_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->add_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "add_int"));

    return ret;
}

static
PMC* stub_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->add_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "add_float"));

    return ret;
}

static
void stub_i_add(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_add(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_add"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_add"));

    return;
}

static
void stub_i_add_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_add_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_add_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_add_int"));

    return;
}

static
void stub_i_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_add_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_add_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_add_float"));

    return;
}

static
PMC* stub_subtract(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->subtract(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "subtract"));

    return ret;
}

static
PMC* stub_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->subtract_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "subtract_int"));

    return ret;
}

static
PMC* stub_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->subtract_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "subtract_float"));

    return ret;
}

static
void stub_i_subtract(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_subtract(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_subtract"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_subtract"));

    return;
}

static
void stub_i_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_subtract_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_subtract_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_subtract_int"));

    return;
}

static
void stub_i_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_subtract_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_subtract_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_subtract_float"));

    return;
}

static
PMC* stub_multiply(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->multiply(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "multiply"));

    return ret;
}

static
PMC* stub_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->multiply_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "multiply_int"));

    return ret;
}

static
PMC* stub_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->multiply_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "multiply_float"));

    return ret;
}

static
void stub_i_multiply(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_multiply(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_multiply"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_multiply"));

    return;
}

static
void stub_i_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_multiply_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_multiply_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_multiply_int"));

    return;
}

static
void stub_i_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_multiply_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_multiply_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_multiply_float"));

    return;
}

static
PMC* stub_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->divide(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "divide"));

    return ret;
}

static
PMC* stub_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->divide_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "divide_int"));

    return ret;
}

static
PMC* stub_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->divide_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "divide_float"));

    return ret;
}

static
void stub_i_divide(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_divide(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_divide"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_divide"));

    return;
}

static
void stub_i_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_divide_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_divide_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_divide_int"));

    return;
}

static
void stub_i_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_divide_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_divide_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_divide_float"));

    return;
}

static
PMC* stub_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->floor_divide(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "floor_divide"));

    return ret;
}

static
PMC* stub_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->floor_divide_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "floor_divide_int"));

    return ret;
}

static
PMC* stub_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->floor_divide_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "floor_divide_float"));

    return ret;
}

static
void stub_i_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_floor_divide(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_floor_divide"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_floor_divide"));

    return;
}

static
void stub_i_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_floor_divide_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_floor_divide_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_floor_divide_int"));

    return;
}

static
void stub_i_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_floor_divide_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_floor_divide_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_floor_divide_float"));

    return;
}

static
PMC* stub_modulus(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->modulus(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "modulus"));

    return ret;
}

static
PMC* stub_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->modulus_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "modulus_int"));

    return ret;
}

static
PMC* stub_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->modulus_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "modulus_float"));

    return ret;
}

static
void stub_i_modulus(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_modulus(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_modulus"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_modulus"));

    return;
}

static
void stub_i_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_modulus_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_modulus_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_modulus_int"));

    return;
}

static
void stub_i_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_modulus_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_modulus_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_modulus_float"));

    return;
}

static
void stub_increment(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->increment(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "increment"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "increment"));

    return;
}

static
void stub_decrement(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->decrement(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "decrement"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "decrement"));

    return;
}

static
PMC* stub_absolute(PARROT_INTERP, PMC* pmc, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->absolute(interp, pmc, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "absolute"));

    return ret;
}

static
void stub_i_absolute(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_absolute(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_absolute"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_absolute"));

    return;
}

static
PMC* stub_neg(PARROT_INTERP, PMC* pmc, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->neg(interp, pmc, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "neg"));

    return ret;
}

static
void stub_i_neg(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_neg(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_neg"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_neg"));

    return;
}

static
INTVAL stub_is_equal(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->is_equal(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "is_equal"));

    return ret;
}

static
INTVAL stub_is_equal_num(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->is_equal_num(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "is_equal_num"));

    return ret;
}

static
INTVAL stub_is_equal_string(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->is_equal_string(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "is_equal_string"));

    return ret;
}

static
INTVAL stub_is_same(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->is_same(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "is_same"));

    return ret;
}

static
INTVAL stub_cmp(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->cmp(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "cmp"));

    return ret;
}

static
INTVAL stub_cmp_num(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->cmp_num(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "cmp_num"));

    return ret;
}

static
INTVAL stub_cmp_string(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->cmp_string(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "cmp_string"));

    return ret;
}

static
PMC* stub_cmp_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->cmp_pmc(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "cmp_pmc"));

    return ret;
}

static
PMC* stub_logical_or(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->logical_or(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "logical_or"));

    return ret;
}

static
PMC* stub_logical_and(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->logical_and(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "logical_and"));

    return ret;
}

static
PMC* stub_logical_xor(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->logical_xor(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "logical_xor"));

    return ret;
}

static
PMC* stub_logical_not(PARROT_INTERP, PMC* pmc, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->logical_not(interp, pmc, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "logical_not"));

    return ret;
}

static
void stub_i_logical_not(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_logical_not(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "i_logical_not"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_logical_not"));

    return;
}

static
PMC* stub_concatenate(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->concatenate(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "concatenate"));

    return ret;
}

static
PMC* stub_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->concatenate_str(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "concatenate_str"));

    return ret;
}

static
void stub_i_concatenate(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_concatenate(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "i_concatenate"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_concatenate"));

    return;
}

static
void stub_i_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_concatenate_str(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "i_concatenate_str"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_concatenate_str"));

    return;
}

static
PMC* stub_repeat(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->repeat(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "repeat"));

    return ret;
}

static
PMC* stub_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->repeat_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "repeat_int"));

    return ret;
}

static
void stub_i_repeat(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_repeat(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "i_repeat"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_repeat"));

    return;
}

static
void stub_i_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->i_repeat_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "i_repeat_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_repeat_int"));

    return;
}

static
void stub_substr(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length, PMC* dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->substr(interp, pmc, offset, length, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, offset);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, length);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "substr"));

    return;
}

static
STRING* stub_substr_str(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->substr_str(interp, pmc, offset, length);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, offset);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, length);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "substr_str"));

    return ret;
}

static
INTVAL stub_exists_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->exists_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "exists"),
                   CONST_STRING(supervisor, "exists_keyed"));

    return ret;
}

static
INTVAL stub_exists_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->exists_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "exists"),
                   CONST_STRING(supervisor, "exists_keyed_int"));

    return ret;
}

static
INTVAL stub_exists_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->exists_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "exists"),
                   CONST_STRING(supervisor, "exists_keyed_str"));

    return ret;
}

static
INTVAL stub_defined(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->defined(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "defined"));

    return ret;
}

static
INTVAL stub_defined_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->defined_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "defined_keyed"));

    return ret;
}

static
INTVAL stub_defined_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->defined_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "defined_keyed_int"));

    return ret;
}

static
INTVAL stub_defined_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->defined_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "defined_keyed_str"));

    return ret;
}

static
void stub_delete_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->delete_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "delete_keyed"));

    return;
}

static
void stub_delete_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->delete_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "delete_keyed_int"));

    return;
}

static
void stub_delete_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->delete_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "delete_keyed_str"));

    return;
}

static
PMC* stub_get_iter(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_iter(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "get_iter"));

    return ret;
}

static
INTVAL stub_hashvalue(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->hashvalue(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "hashvalue"));

    return ret;
}

static
opcode_t* stub_invoke(PARROT_INTERP, PMC* pmc, void* next) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    opcode_t* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->invoke(interp, pmc, next);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, next);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "invoke"));

    return ret;
}

static
INTVAL stub_can(PARROT_INTERP, PMC* pmc, STRING* method) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->can(interp, pmc, method);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, method);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "can"));

    return ret;
}

static
INTVAL stub_does_pmc(PARROT_INTERP, PMC* pmc, PMC* role) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->does_pmc(interp, pmc, role);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, role);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "does_pmc"));

    return ret;
}

static
INTVAL stub_does(PARROT_INTERP, PMC* pmc, STRING* role) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->does(interp, pmc, role);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, role);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "does"));

    return ret;
}

static
INTVAL stub_isa_pmc(PARROT_INTERP, PMC* pmc, PMC* _class) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->isa_pmc(interp, pmc, _class);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, _class);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "isa_pmc"));

    return ret;
}

static
INTVAL stub_isa(PARROT_INTERP, PMC* pmc, STRING* _class) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->isa(interp, pmc, _class);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, _class);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "isa"));

    return ret;
}

static
PMC* stub_get_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_attr_str(interp, pmc, idx);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, idx);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "get_attr_str"));

    return ret;
}

static
PMC* stub_get_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_attr_keyed(interp, pmc, key, idx);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, idx);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "get_attr_keyed"));

    return ret;
}

static
void stub_set_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_attr_str(interp, pmc, idx, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, idx);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "set_attr_str"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "set_attr_str"));

    return;
}

static
void stub_set_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx, PMC* value) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->set_attr_keyed(interp, pmc, key, idx, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, idx);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "set_attr_keyed"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "set_attr_keyed"));

    return;
}

static
PMC* stub_get_class(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->get_class(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "get_class"));

    return ret;
}

static
void stub_add_parent(PARROT_INTERP, PMC* pmc, PMC* parent) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->add_parent(interp, pmc, parent);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, parent);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "add_parent"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "add_parent"));

    return;
}

static
void stub_remove_parent(PARROT_INTERP, PMC* pmc, PMC* parent) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->remove_parent(interp, pmc, parent);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, parent);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "remove_parent"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "remove_parent"));

    return;
}

static
void stub_add_role(PARROT_INTERP, PMC* pmc, PMC* role) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->add_role(interp, pmc, role);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, role);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "add_role"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "add_role"));

    return;
}

static
void stub_remove_role(PARROT_INTERP, PMC* pmc, PMC* role) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->remove_role(interp, pmc, role);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, role);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "remove_role"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "remove_role"));

    return;
}

static
void stub_add_attribute(PARROT_INTERP, PMC* pmc, STRING* name, PMC* type) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->add_attribute(interp, pmc, name, type);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, name);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, type);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "add_attribute"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "add_attribute"));

    return;
}

static
void stub_remove_attribute(PARROT_INTERP, PMC* pmc, STRING* name) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->remove_attribute(interp, pmc, name);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, name);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "remove_attribute"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "remove_attribute"));

    return;
}

static
void stub_add_method(PARROT_INTERP, PMC* pmc, STRING* method_name, PMC* sub_pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->add_method(interp, pmc, method_name, sub_pmc);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, method_name);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, sub_pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "add_method"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "add_method"));

    return;
}

static
void stub_remove_method(PARROT_INTERP, PMC* pmc, STRING* method_name) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->remove_method(interp, pmc, method_name);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, method_name);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "remove_method"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "remove_method"));

    return;
}

static
void stub_add_vtable_override(PARROT_INTERP, PMC* pmc, STRING* vtable_name, PMC* sub_pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->add_vtable_override(interp, pmc, vtable_name, sub_pmc);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, vtable_name);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, sub_pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "add_vtable_override"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "add_vtable_override"));

    return;
}

static
void stub_remove_vtable_override(PARROT_INTERP, PMC* pmc, STRING* vtable_name) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->remove_vtable_override(interp, pmc, vtable_name);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, vtable_name);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "remove_vtable_override"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "remove_vtable_override"));

    return;
}

static
PMC* stub_inspect(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->inspect(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "inspect"));

    return ret;
}

static
PMC* stub_inspect_str(PARROT_INTERP, PMC* pmc, STRING* what) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->inspect_str(interp, pmc, what);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, what);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "inspect_str"));

    return ret;
}

static
void stub_freeze(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->freeze(interp, pmc, info);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, info);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "freeze"));

    return;
}

static
void stub_thaw(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->thaw(interp, pmc, info);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, info);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "thaw"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "thaw"));

    return;
}

static
void stub_thawfinish(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->thawfinish(interp, pmc, info);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, info);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "thawfinish"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "thawfinish"));

    return;
}

static
void stub_visit(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->visit(interp, pmc, info);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, info);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "visit"));

    return;
}

static
void stub_share(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->share(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "share"));

    return;
}

static
PMC* stub_share_ro(PARROT_INTERP, PMC* pmc) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = ((_vtable *)orig_vtable)->share_ro(interp, pmc);

    VTABLE_push_pmc(supervisor, params, pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "share_ro"));

    return ret;
}

static
void stub_init_int(PARROT_INTERP, PMC* pmc, INTVAL initializer) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ((_vtable *)orig_vtable)->init_int(interp, pmc, initializer);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, initializer);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "init_int"));

    return;
}

/* END vtable stubs */

/* END OF GENERATED CODE */

/*

=back

=head1 SEE ALSO

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
