/*
Copyright (C) 2010, Parrot Foundation.
$Id$

=head1 NAME

src/dynpmc/instrumentvtable.pmc - Interface to instrument a PMC's vtable.

=head1 DESCRIPTION

C<InstrumentVtable> is a PMC class that provides an interface to
instrument a PMC's vtable entries.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

#include "pmc/pmc_class.h"
#include "pmc_instrument.h"

#include "instrument_private.h"
#include "instrument_extern.h"

/* Helper Prototypes. */
void setup_vtable_common_hashes(PARROT_INTERP);
void destroy_vtable_common_hashes(PARROT_INTERP);
void setup_vtable_individual_hashes(PARROT_INTERP, Hash *orig_hash, Hash *instr_hash,
                                    _vtable *vt_orig, _vtable *vt_instr);

/* Globals used internally. */
static INTVAL  vtable_first_run   = 1;
static Hash   *vtable_registry    = NULL;
static Hash   *vtable_name_stubs  = NULL;
static Hash   *vtable_group_items = NULL;
static Hash   *vtable_item_groups = NULL;

pmclass InstrumentVtable auto_attrs dynpmc group instrument_group extends InstrumentStubBase {
    ATTR size_t         class_index;
    ATTR STRING        *class_name;
    ATTR Parrot_Interp  supervisor;
    ATTR PMC           *rename_hash;
    ATTR PMC           *vtable_overrides;

/*

=item C<void init_pmc(PMC *instrument)>

Perform a partial initialization. The remaining attributes are initialised
upon calling 'attach_to_class'.

=cut

*/

    VTABLE void init_pmc(PMC *instrument) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        SUPER(instrument);

        /* Initialise the attributes.
           Other attributes are deferred to after attaching to a class. */
        attr->supervisor       = INTERP;
        attr->rename_hash      = Parrot_pmc_new(INTERP, enum_class_Hash);
        attr->vtable_overrides = Parrot_pmc_new(INTERP, enum_class_Hash);

        /* Initialise the static hashes. */
        setup_vtable_common_hashes(INTERP);

        /* Update the attributes to point to the static hashes. */
        attr->registry    = vtable_registry;
        attr->name_stubs  = vtable_name_stubs;
        attr->group_items = vtable_group_items;
        attr->item_groups = vtable_item_groups;
    }

/*

=item C<void destroy()>

Cleanup internal data structures.

=cut

*/

    VTABLE void destroy() {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        SUPER();
        if (attr->instrumented_struct != NULL) {
            parrot_hash_delete(INTERP, vtable_registry, attr->instrumented_struct);
        }
        destroy_vtable_common_hashes(INTERP);
    }

/*

=item C<void attach_to_class(STRING *classname)>

Prepare the given class' vtable for instrumentation.
If class is not found, throw an exception.

=cut

*/

    METHOD attach_to_class(STRING *classname) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        Parrot_Interp supervised;

        GETATTR_Instrument_supervised(INTERP, attr->instrument, supervised);

        /* Find the class. */
        attr->class_index = Parrot_pmc_get_type_str(supervised, classname);
        attr->class_name  = classname;

        /* class_index must not be 0. (0 = default). */
        if (attr->class_index == 0) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                        "%Ss : Class not found, '%Ss'",
                                        VTABLE_name(INTERP, SELF), classname);
        }
        attr->original_struct = supervised->vtables[attr->class_index];

        /* Prepare the class's vtable for instrumentation. */
        attr->instrumented_struct = mem_gc_allocate_zeroed_typed(supervised, _vtable);
        mem_copy_n_typed(attr->instrumented_struct, attr->original_struct, 1, _vtable);
        supervised->vtables[attr->class_index] = (_vtable *) attr->instrumented_struct;

        /* Register the instrumented vtable to SELF. */
        parrot_hash_put(INTERP, attr->registry, attr->instrumented_struct, SELF);

        /* Build the vtable hashes, passing a sample vtable to build the offsets. */
        setup_vtable_individual_hashes(INTERP, attr->name_original, attr->name_offset,
                                       (_vtable *) attr->original_struct,
                                       (_vtable *) attr->instrumented_struct);

        /* Update the event_prefix attribute. */
        VTABLE_push_string(INTERP, attr->event_prefix, CONST_STRING(INTERP, "Class"));
        VTABLE_push_string(INTERP, attr->event_prefix, classname);
    }

/*

=item C<void insert_hook(STRING *name)>

Inserts the stub function for the entry given by name.
If name denotes a group, inserts stubs for all functions in that group.

=cut

*/

    METHOD insert_hook(STRING *name) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        PMC *_class;
        Parrot_Interp supervised;
        PMC *list;
        PMC *iter;
        PMC *overrides;

        GETATTR_Instrument_supervised(INTERP, attr->instrument, supervised);
        _class   = Parrot_oo_get_class_str(supervised, attr->class_name);
        GETATTR_Class_vtable_overrides(supervised, _class, overrides);

        (PMC *list) = PCCINVOKE(INTERP, SELF, "get_hook_list", STRING *name);

        iter = VTABLE_get_iter(INTERP, list);
        while (VTABLE_get_bool(INTERP, iter)) {
            INTVAL count;
            PMC *item_pmc = VTABLE_shift_pmc(INTERP, iter);
            STRING *item  = VTABLE_get_string(INTERP, item_pmc);
            size_t **entry, *func;

            /* Check if the entry has already been instrumented. */
            count = VTABLE_get_integer_keyed_str(INTERP, attr->hook_count, item);
            if (count == 0) {
                /* Look for a vtable override. */
                PMC *override;
                override = VTABLE_get_pmc_keyed_str(supervised, overrides, item);

                if (PMC_IS_NULL(override)) {
                    /* No override. */
                    /* Replace the entry with the stub. */
                    entry = (size_t **) parrot_hash_get(INTERP, attr->name_offset, item);
                    func  = (size_t *)  parrot_hash_get(INTERP, attr->name_stubs, item);
                    if (entry == NULL || func == NULL) {
                        Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                                    "%Ss : Unknown function, '%Ss'",
                                                    VTABLE_name(INTERP, SELF), item);
                    }
                    *entry = func;
                }
                else {
                    /* It appears that there is a vtable override.
                       Instrument the invoke vtable entry of the override.
                       (which is assumed to be invokable, otherwise it won't be much
                        of an override.) */
                    PMC *invokable, *event;
                    STRING *group;
                    INTVAL type;

                    type     = Parrot_pmc_get_type_str(INTERP, CONST_STRING(INTERP, "InstrumentInvokable"));
                    invokable= Parrot_pmc_new_init(INTERP, type, attr->instrument);

                    (STRING *group) = PCCINVOKE(INTERP, SELF, "get_hook_group", STRING *item);

                    event    = VTABLE_clone(INTERP, attr->event_prefix);
                    VTABLE_push_string(INTERP, event, CONST_STRING(INTERP, "vtable"));
                    VTABLE_push_string(INTERP, event, group);
                    VTABLE_push_string(INTERP, event, item);

                    () = PCCINVOKE(INTERP, invokable, "set_event", PMC *event);

                    VTABLE_set_pointer(INTERP, invokable, override);

                    VTABLE_set_pmc_keyed_str(supervised, overrides, item, invokable);
                }
            }

            /* Update the count. */
            count++;
            VTABLE_set_integer_keyed_str(INTERP, attr->hook_count, item, count);
        }
    }

/*

=item C<void remove_hook(STRING *name)>

Removes the stub function for the given entry given by name.
If name denotes a group, removes stubs for all functions in that group.

=cut

*/

    METHOD remove_hook(STRING *name) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        PMC *list;
        PMC *iter;
        PMC *_class;
        Parrot_Interp supervised;
        PMC *overrides;

        GETATTR_Instrument_supervised(INTERP, attr->instrument, supervised);
        _class   = Parrot_oo_get_class_str(supervised, attr->class_name);
        GETATTR_Class_vtable_overrides(supervised, _class, overrides);

        (PMC *list) = PCCINVOKE(INTERP, SELF, "get_hook_list", STRING *name);

        iter = VTABLE_get_iter(INTERP, list);
        while (VTABLE_get_bool(INTERP, iter)) {
            INTVAL count;
            PMC *item_pmc = VTABLE_shift_pmc(INTERP, iter);
            STRING *item  = VTABLE_get_string(INTERP, item_pmc);
            size_t **entry, *func;

            /* Only remove the stub if request count == 1 => Last request. */
            count = VTABLE_get_integer_keyed_str(INTERP, attr->hook_count, item);
            if (count <= 0) {
                /* Tried to remove 1 time too many. */
                Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                                "%Ss : Unknown function, '%Ss'",
                                                VTABLE_name(INTERP, SELF), item);
            }
            else if (count == 1) {
                /* Look for a vtable override. */
                PMC *override;
                override = Parrot_oo_find_vtable_override_for_class(supervised, _class, name);

                if (PMC_IS_NULL(override)) {
                    /* No override. */
                    /* Simply replace the stub with the original entry. */
                    entry = (size_t **) parrot_hash_get(INTERP, attr->name_offset, item);
                    func  = (size_t *)  parrot_hash_get(INTERP, attr->name_original, item);
                    if (entry == NULL || func == NULL) {
                        Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                                    "%Ss : Unknown function, '%Ss'",
                                                    VTABLE_name(INTERP, SELF), item);
                    }
                    *entry = func;
                }
                else {
                    /* It appears that there is a vtable override.
                       Remove the instrumentation of the override's invoke
                       vtable entry. */
                    PMC *orig_vtable_sub;

                    orig_vtable_sub = (PMC *) VTABLE_get_pointer(INTERP, override);
                    VTABLE_set_pmc_keyed_str(supervised, overrides, item, orig_vtable_sub);
                }
            }

            /* Update the count. */
            count--;
            VTABLE_set_integer_keyed_str(INTERP, attr->hook_count, item, count);
        }
    }

}

/* BELOW LIES GENERATED CODE GENERATED BY tools/build/gen_vtable_stubs.pl */
/* Stub Prototypes */
/* BEGIN vtable prototypes */
static PMC* stub_absolute(PARROT_INTERP, PMC *pmc, PMC* dest);
static PMC* stub_add(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest);
static void stub_add_attribute(PARROT_INTERP, PMC *pmc, STRING* name, PMC* type);
static PMC* stub_add_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest);
static PMC* stub_add_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest);
static void stub_add_method(PARROT_INTERP, PMC *pmc, STRING* method_name, PMC* sub_pmc);
static void stub_add_parent(PARROT_INTERP, PMC *pmc, PMC* parent);
static void stub_add_role(PARROT_INTERP, PMC *pmc, PMC* role);
static void stub_add_vtable_override(PARROT_INTERP, PMC *pmc, STRING* vtable_name, PMC* sub_pmc);
static void stub_assign_pmc(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_assign_string_native(PARROT_INTERP, PMC *pmc, STRING* value);
static INTVAL stub_can(PARROT_INTERP, PMC *pmc, STRING* method);
static PMC* stub_clone(PARROT_INTERP, PMC *pmc);
static PMC* stub_clone_pmc(PARROT_INTERP, PMC *pmc, PMC* args);
static INTVAL stub_cmp(PARROT_INTERP, PMC *pmc, PMC* value);
static INTVAL stub_cmp_num(PARROT_INTERP, PMC *pmc, PMC* value);
static PMC* stub_cmp_pmc(PARROT_INTERP, PMC *pmc, PMC* value);
static INTVAL stub_cmp_string(PARROT_INTERP, PMC *pmc, PMC* value);
static PMC* stub_concatenate(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest);
static PMC* stub_concatenate_str(PARROT_INTERP, PMC *pmc, STRING* value, PMC* dest);
static void stub_decrement(PARROT_INTERP, PMC *pmc);
static INTVAL stub_defined(PARROT_INTERP, PMC *pmc);
static INTVAL stub_defined_keyed(PARROT_INTERP, PMC *pmc, PMC* key);
static INTVAL stub_defined_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key);
static INTVAL stub_defined_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key);
static void stub_delete_keyed(PARROT_INTERP, PMC *pmc, PMC* key);
static void stub_delete_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key);
static void stub_delete_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key);
static void stub_delprop(PARROT_INTERP, PMC *pmc, STRING* key);
static void stub_destroy(PARROT_INTERP, PMC *pmc);
static PMC* stub_divide(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest);
static PMC* stub_divide_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest);
static PMC* stub_divide_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest);
static INTVAL stub_does(PARROT_INTERP, PMC *pmc, STRING* role);
static INTVAL stub_does_pmc(PARROT_INTERP, PMC *pmc, PMC* role);
static INTVAL stub_elements(PARROT_INTERP, PMC *pmc);
static INTVAL stub_exists_keyed(PARROT_INTERP, PMC *pmc, PMC* key);
static INTVAL stub_exists_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key);
static INTVAL stub_exists_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key);
static PMC* stub_find_method(PARROT_INTERP, PMC *pmc, STRING* method_name);
static PMC* stub_floor_divide(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest);
static PMC* stub_floor_divide_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest);
static PMC* stub_floor_divide_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest);
static void stub_freeze(PARROT_INTERP, PMC *pmc, PMC* info);
static PMC* stub_get_attr_keyed(PARROT_INTERP, PMC *pmc, PMC* key, STRING* idx);
static PMC* stub_get_attr_str(PARROT_INTERP, PMC *pmc, STRING* idx);
static INTVAL stub_get_bool(PARROT_INTERP, PMC *pmc);
static PMC* stub_get_class(PARROT_INTERP, PMC *pmc);
static INTVAL stub_get_integer(PARROT_INTERP, PMC *pmc);
static INTVAL stub_get_integer_keyed(PARROT_INTERP, PMC *pmc, PMC* key);
static INTVAL stub_get_integer_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key);
static INTVAL stub_get_integer_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key);
static PMC* stub_get_iter(PARROT_INTERP, PMC *pmc);
static PMC* stub_get_namespace(PARROT_INTERP, PMC *pmc);
static FLOATVAL stub_get_number(PARROT_INTERP, PMC *pmc);
static FLOATVAL stub_get_number_keyed(PARROT_INTERP, PMC *pmc, PMC* key);
static FLOATVAL stub_get_number_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key);
static FLOATVAL stub_get_number_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key);
static PMC* stub_get_pmc(PARROT_INTERP, PMC *pmc);
static PMC* stub_get_pmc_keyed(PARROT_INTERP, PMC *pmc, PMC* key);
static PMC* stub_get_pmc_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key);
static PMC* stub_get_pmc_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key);
static void* stub_get_pointer(PARROT_INTERP, PMC *pmc);
static void* stub_get_pointer_keyed(PARROT_INTERP, PMC *pmc, PMC* key);
static void* stub_get_pointer_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key);
static void* stub_get_pointer_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key);
static STRING* stub_get_repr(PARROT_INTERP, PMC *pmc);
static STRING* stub_get_string(PARROT_INTERP, PMC *pmc);
static STRING* stub_get_string_keyed(PARROT_INTERP, PMC *pmc, PMC* key);
static STRING* stub_get_string_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key);
static STRING* stub_get_string_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key);
static PMC* stub_getprop(PARROT_INTERP, PMC *pmc, STRING* key);
static PMC* stub_getprops(PARROT_INTERP, PMC *pmc);
static INTVAL stub_hashvalue(PARROT_INTERP, PMC *pmc);
static void stub_i_absolute(PARROT_INTERP, PMC *pmc);
static void stub_i_add(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_i_add_float(PARROT_INTERP, PMC *pmc, FLOATVAL value);
static void stub_i_add_int(PARROT_INTERP, PMC *pmc, INTVAL value);
static void stub_i_concatenate(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_i_concatenate_str(PARROT_INTERP, PMC *pmc, STRING* value);
static void stub_i_divide(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_i_divide_float(PARROT_INTERP, PMC *pmc, FLOATVAL value);
static void stub_i_divide_int(PARROT_INTERP, PMC *pmc, INTVAL value);
static void stub_i_floor_divide(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_i_floor_divide_float(PARROT_INTERP, PMC *pmc, FLOATVAL value);
static void stub_i_floor_divide_int(PARROT_INTERP, PMC *pmc, INTVAL value);
static void stub_i_logical_not(PARROT_INTERP, PMC *pmc);
static void stub_i_modulus(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_i_modulus_float(PARROT_INTERP, PMC *pmc, FLOATVAL value);
static void stub_i_modulus_int(PARROT_INTERP, PMC *pmc, INTVAL value);
static void stub_i_multiply(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_i_multiply_float(PARROT_INTERP, PMC *pmc, FLOATVAL value);
static void stub_i_multiply_int(PARROT_INTERP, PMC *pmc, INTVAL value);
static void stub_i_neg(PARROT_INTERP, PMC *pmc);
static void stub_i_repeat(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_i_repeat_int(PARROT_INTERP, PMC *pmc, INTVAL value);
static void stub_i_subtract(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_i_subtract_float(PARROT_INTERP, PMC *pmc, FLOATVAL value);
static void stub_i_subtract_int(PARROT_INTERP, PMC *pmc, INTVAL value);
static void stub_increment(PARROT_INTERP, PMC *pmc);
static void stub_init(PARROT_INTERP, PMC *pmc);
static void stub_init_int(PARROT_INTERP, PMC *pmc, INTVAL initializer);
static void stub_init_pmc(PARROT_INTERP, PMC *pmc, PMC* initializer);
static PMC* stub_inspect(PARROT_INTERP, PMC *pmc);
static PMC* stub_inspect_str(PARROT_INTERP, PMC *pmc, STRING* what);
static PMC* stub_instantiate(PARROT_INTERP, PMC *pmc, PMC* sig);
static opcode_t* stub_invoke(PARROT_INTERP, PMC *pmc, void* next);
static INTVAL stub_is_equal(PARROT_INTERP, PMC *pmc, PMC* value);
static INTVAL stub_is_equal_num(PARROT_INTERP, PMC *pmc, PMC* value);
static INTVAL stub_is_equal_string(PARROT_INTERP, PMC *pmc, PMC* value);
static INTVAL stub_is_same(PARROT_INTERP, PMC *pmc, PMC* value);
static INTVAL stub_isa(PARROT_INTERP, PMC *pmc, STRING* _class);
static INTVAL stub_isa_pmc(PARROT_INTERP, PMC *pmc, PMC* _class);
static PMC* stub_logical_and(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest);
static PMC* stub_logical_not(PARROT_INTERP, PMC *pmc, PMC* dest);
static PMC* stub_logical_or(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest);
static PMC* stub_logical_xor(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest);
static void stub_mark(PARROT_INTERP, PMC *pmc);
static PMC* stub_modulus(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest);
static PMC* stub_modulus_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest);
static PMC* stub_modulus_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest);
static void stub_morph(PARROT_INTERP, PMC *pmc, PMC* type);
static PMC* stub_multiply(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest);
static PMC* stub_multiply_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest);
static PMC* stub_multiply_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest);
static STRING* stub_name(PARROT_INTERP, PMC *pmc);
static PMC* stub_neg(PARROT_INTERP, PMC *pmc, PMC* dest);
static FLOATVAL stub_pop_float(PARROT_INTERP, PMC *pmc);
static INTVAL stub_pop_integer(PARROT_INTERP, PMC *pmc);
static PMC* stub_pop_pmc(PARROT_INTERP, PMC *pmc);
static STRING* stub_pop_string(PARROT_INTERP, PMC *pmc);
static void stub_push_float(PARROT_INTERP, PMC *pmc, FLOATVAL value);
static void stub_push_integer(PARROT_INTERP, PMC *pmc, INTVAL value);
static void stub_push_pmc(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_push_string(PARROT_INTERP, PMC *pmc, STRING* value);
static void stub_remove_attribute(PARROT_INTERP, PMC *pmc, STRING* name);
static void stub_remove_method(PARROT_INTERP, PMC *pmc, STRING* method_name);
static void stub_remove_parent(PARROT_INTERP, PMC *pmc, PMC* parent);
static void stub_remove_role(PARROT_INTERP, PMC *pmc, PMC* role);
static void stub_remove_vtable_override(PARROT_INTERP, PMC *pmc, STRING* vtable_name);
static PMC* stub_repeat(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest);
static PMC* stub_repeat_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest);
static void stub_set_attr_keyed(PARROT_INTERP, PMC *pmc, PMC* key, STRING* idx, PMC* value);
static void stub_set_attr_str(PARROT_INTERP, PMC *pmc, STRING* idx, PMC* value);
static void stub_set_bool(PARROT_INTERP, PMC *pmc, INTVAL value);
static void stub_set_integer_keyed(PARROT_INTERP, PMC *pmc, PMC* key, INTVAL value);
static void stub_set_integer_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key, INTVAL value);
static void stub_set_integer_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key, INTVAL value);
static void stub_set_integer_native(PARROT_INTERP, PMC *pmc, INTVAL value);
static void stub_set_number_keyed(PARROT_INTERP, PMC *pmc, PMC* key, FLOATVAL value);
static void stub_set_number_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key, FLOATVAL value);
static void stub_set_number_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key, FLOATVAL value);
static void stub_set_number_native(PARROT_INTERP, PMC *pmc, FLOATVAL value);
static void stub_set_pmc(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_set_pmc_keyed(PARROT_INTERP, PMC *pmc, PMC* key, PMC* value);
static void stub_set_pmc_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key, PMC* value);
static void stub_set_pmc_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key, PMC* value);
static void stub_set_pointer(PARROT_INTERP, PMC *pmc, void* value);
static void stub_set_pointer_keyed(PARROT_INTERP, PMC *pmc, PMC* key, void* value);
static void stub_set_pointer_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key, void* value);
static void stub_set_pointer_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key, void* value);
static void stub_set_string_keyed(PARROT_INTERP, PMC *pmc, PMC* key, STRING* value);
static void stub_set_string_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key, STRING* value);
static void stub_set_string_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key, STRING* value);
static void stub_set_string_native(PARROT_INTERP, PMC *pmc, STRING* value);
static void stub_setprop(PARROT_INTERP, PMC *pmc, STRING* key, PMC* value);
static void stub_share(PARROT_INTERP, PMC *pmc);
static PMC* stub_share_ro(PARROT_INTERP, PMC *pmc);
static FLOATVAL stub_shift_float(PARROT_INTERP, PMC *pmc);
static INTVAL stub_shift_integer(PARROT_INTERP, PMC *pmc);
static PMC* stub_shift_pmc(PARROT_INTERP, PMC *pmc);
static STRING* stub_shift_string(PARROT_INTERP, PMC *pmc);
static void stub_splice(PARROT_INTERP, PMC *pmc, PMC* value, INTVAL offset, INTVAL count);
static void stub_substr(PARROT_INTERP, PMC *pmc, INTVAL offset, INTVAL length, PMC* dest);
static STRING* stub_substr_str(PARROT_INTERP, PMC *pmc, INTVAL offset, INTVAL length);
static PMC* stub_subtract(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest);
static PMC* stub_subtract_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest);
static PMC* stub_subtract_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest);
static void stub_thaw(PARROT_INTERP, PMC *pmc, PMC* info);
static void stub_thawfinish(PARROT_INTERP, PMC *pmc, PMC* info);
static INTVAL stub_type(PARROT_INTERP, PMC *pmc);
static void stub_unshift_float(PARROT_INTERP, PMC *pmc, FLOATVAL value);
static void stub_unshift_integer(PARROT_INTERP, PMC *pmc, INTVAL value);
static void stub_unshift_pmc(PARROT_INTERP, PMC *pmc, PMC* value);
static void stub_unshift_string(PARROT_INTERP, PMC *pmc, STRING* value);
static void stub_visit(PARROT_INTERP, PMC *pmc, PMC* info);
/* END vtable prototypes */

void setup_vtable_common_hashes(PARROT_INTERP) {
    PMC *temp;
    if (!vtable_first_run) return;

    vtable_first_run   = 0;
    vtable_registry    = parrot_new_pointer_hash(interp);
    vtable_name_stubs  = parrot_new_hash(interp);
    vtable_group_items = parrot_new_hash(interp);
    vtable_item_groups = parrot_new_hash(interp);

    /* BEGIN vtable mapping name stubs */
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "absolute"), stub_absolute);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add"), stub_add);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_attribute"), stub_add_attribute);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_float"), stub_add_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_int"), stub_add_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_method"), stub_add_method);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_parent"), stub_add_parent);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_role"), stub_add_role);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "add_vtable_override"), stub_add_vtable_override);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "assign_pmc"), stub_assign_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "assign_string_native"), stub_assign_string_native);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "can"), stub_can);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "clone"), stub_clone);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "clone_pmc"), stub_clone_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "cmp"), stub_cmp);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "cmp_num"), stub_cmp_num);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "cmp_pmc"), stub_cmp_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "cmp_string"), stub_cmp_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "concatenate"), stub_concatenate);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "concatenate_str"), stub_concatenate_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "decrement"), stub_decrement);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "defined"), stub_defined);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "defined_keyed"), stub_defined_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "defined_keyed_int"), stub_defined_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "defined_keyed_str"), stub_defined_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "delete_keyed"), stub_delete_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "delete_keyed_int"), stub_delete_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "delete_keyed_str"), stub_delete_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "delprop"), stub_delprop);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "destroy"), stub_destroy);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "divide"), stub_divide);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "divide_float"), stub_divide_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "divide_int"), stub_divide_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "does"), stub_does);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "does_pmc"), stub_does_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "elements"), stub_elements);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "exists_keyed"), stub_exists_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "exists_keyed_int"), stub_exists_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "exists_keyed_str"), stub_exists_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "find_method"), stub_find_method);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "floor_divide"), stub_floor_divide);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "floor_divide_float"), stub_floor_divide_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "floor_divide_int"), stub_floor_divide_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "freeze"), stub_freeze);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_attr_keyed"), stub_get_attr_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_attr_str"), stub_get_attr_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_bool"), stub_get_bool);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_class"), stub_get_class);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_integer"), stub_get_integer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_integer_keyed"), stub_get_integer_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_integer_keyed_int"), stub_get_integer_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_integer_keyed_str"), stub_get_integer_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_iter"), stub_get_iter);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_namespace"), stub_get_namespace);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_number"), stub_get_number);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_number_keyed"), stub_get_number_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_number_keyed_int"), stub_get_number_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_number_keyed_str"), stub_get_number_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pmc"), stub_get_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pmc_keyed"), stub_get_pmc_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pmc_keyed_int"), stub_get_pmc_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pmc_keyed_str"), stub_get_pmc_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pointer"), stub_get_pointer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pointer_keyed"), stub_get_pointer_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pointer_keyed_int"), stub_get_pointer_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_pointer_keyed_str"), stub_get_pointer_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_repr"), stub_get_repr);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_string"), stub_get_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_string_keyed"), stub_get_string_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_string_keyed_int"), stub_get_string_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "get_string_keyed_str"), stub_get_string_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "getprop"), stub_getprop);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "getprops"), stub_getprops);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "hashvalue"), stub_hashvalue);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_absolute"), stub_i_absolute);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_add"), stub_i_add);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_add_float"), stub_i_add_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_add_int"), stub_i_add_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_concatenate"), stub_i_concatenate);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_concatenate_str"), stub_i_concatenate_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_divide"), stub_i_divide);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_divide_float"), stub_i_divide_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_divide_int"), stub_i_divide_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_floor_divide"), stub_i_floor_divide);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_floor_divide_float"), stub_i_floor_divide_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_floor_divide_int"), stub_i_floor_divide_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_logical_not"), stub_i_logical_not);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_modulus"), stub_i_modulus);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_modulus_float"), stub_i_modulus_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_modulus_int"), stub_i_modulus_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_multiply"), stub_i_multiply);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_multiply_float"), stub_i_multiply_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_multiply_int"), stub_i_multiply_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_neg"), stub_i_neg);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_repeat"), stub_i_repeat);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_repeat_int"), stub_i_repeat_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_subtract"), stub_i_subtract);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_subtract_float"), stub_i_subtract_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "i_subtract_int"), stub_i_subtract_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "increment"), stub_increment);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "init"), stub_init);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "init_int"), stub_init_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "init_pmc"), stub_init_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "inspect"), stub_inspect);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "inspect_str"), stub_inspect_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "instantiate"), stub_instantiate);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "invoke"), stub_invoke);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "is_equal"), stub_is_equal);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "is_equal_num"), stub_is_equal_num);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "is_equal_string"), stub_is_equal_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "is_same"), stub_is_same);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "isa"), stub_isa);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "isa_pmc"), stub_isa_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "logical_and"), stub_logical_and);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "logical_not"), stub_logical_not);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "logical_or"), stub_logical_or);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "logical_xor"), stub_logical_xor);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "mark"), stub_mark);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "modulus"), stub_modulus);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "modulus_float"), stub_modulus_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "modulus_int"), stub_modulus_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "morph"), stub_morph);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "multiply"), stub_multiply);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "multiply_float"), stub_multiply_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "multiply_int"), stub_multiply_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "name"), stub_name);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "neg"), stub_neg);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "pop_float"), stub_pop_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "pop_integer"), stub_pop_integer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "pop_pmc"), stub_pop_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "pop_string"), stub_pop_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "push_float"), stub_push_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "push_integer"), stub_push_integer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "push_pmc"), stub_push_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "push_string"), stub_push_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "remove_attribute"), stub_remove_attribute);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "remove_method"), stub_remove_method);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "remove_parent"), stub_remove_parent);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "remove_role"), stub_remove_role);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "remove_vtable_override"), stub_remove_vtable_override);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "repeat"), stub_repeat);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "repeat_int"), stub_repeat_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_attr_keyed"), stub_set_attr_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_attr_str"), stub_set_attr_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_bool"), stub_set_bool);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_integer_keyed"), stub_set_integer_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_integer_keyed_int"), stub_set_integer_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_integer_keyed_str"), stub_set_integer_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_integer_native"), stub_set_integer_native);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_number_keyed"), stub_set_number_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_number_keyed_int"), stub_set_number_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_number_keyed_str"), stub_set_number_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_number_native"), stub_set_number_native);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pmc"), stub_set_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pmc_keyed"), stub_set_pmc_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pmc_keyed_int"), stub_set_pmc_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pmc_keyed_str"), stub_set_pmc_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pointer"), stub_set_pointer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pointer_keyed"), stub_set_pointer_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pointer_keyed_int"), stub_set_pointer_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_pointer_keyed_str"), stub_set_pointer_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_string_keyed"), stub_set_string_keyed);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_string_keyed_int"), stub_set_string_keyed_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_string_keyed_str"), stub_set_string_keyed_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "set_string_native"), stub_set_string_native);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "setprop"), stub_setprop);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "share"), stub_share);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "share_ro"), stub_share_ro);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "shift_float"), stub_shift_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "shift_integer"), stub_shift_integer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "shift_pmc"), stub_shift_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "shift_string"), stub_shift_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "splice"), stub_splice);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "substr"), stub_substr);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "substr_str"), stub_substr_str);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "subtract"), stub_subtract);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "subtract_float"), stub_subtract_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "subtract_int"), stub_subtract_int);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "thaw"), stub_thaw);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "thawfinish"), stub_thawfinish);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "type"), stub_type);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "unshift_float"), stub_unshift_float);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "unshift_integer"), stub_unshift_integer);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "unshift_pmc"), stub_unshift_pmc);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "unshift_string"), stub_unshift_string);
    parrot_hash_put(interp, vtable_name_stubs,
        CONST_STRING(interp, "visit"), stub_visit);
    /* END vtable mapping name stubs */

    /* BEGIN vtable mapping group items */
    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "assign_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "assign_string_native"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_bool"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_integer_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_integer_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_integer_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_integer_native"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_number_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_number_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_number_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_number_native"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pmc_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pmc_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pmc_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pointer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pointer_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pointer_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pointer_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_string_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_string_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_string_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_string_native"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "store"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "absolute"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "decrement"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "divide"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "divide_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "divide_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "floor_divide"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "floor_divide_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "floor_divide_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_absolute"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_add"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_add_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_add_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_divide"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_divide_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_divide_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_floor_divide"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_floor_divide_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_floor_divide_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_modulus"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_modulus_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_modulus_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_multiply"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_multiply_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_multiply_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_neg"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_subtract"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_subtract_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_subtract_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "increment"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "modulus"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "modulus_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "modulus_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "multiply"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "multiply_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "multiply_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "neg"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "subtract"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "subtract_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "subtract_int"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "math"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "concatenate"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "concatenate_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_concatenate"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_concatenate_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_repeat"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_repeat_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "repeat"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "repeat_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "substr"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "substr_str"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "string"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "absolute"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_attribute"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_method"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_parent"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_role"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_vtable_override"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "assign_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "assign_string_native"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "can"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "clone"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "clone_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "cmp"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "cmp_num"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "cmp_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "cmp_string"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "concatenate"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "concatenate_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "decrement"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "defined"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "defined_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "defined_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "defined_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "delete_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "delete_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "delete_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "delprop"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "destroy"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "divide"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "divide_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "divide_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "does"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "does_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "elements"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "exists_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "exists_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "exists_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "find_method"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "floor_divide"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "floor_divide_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "floor_divide_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "freeze"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_attr_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_attr_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_bool"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_class"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_integer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_integer_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_integer_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_integer_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_iter"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_namespace"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_number"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_number_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_number_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_number_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pmc_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pmc_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pmc_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pointer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pointer_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pointer_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pointer_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_repr"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_string"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_string_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_string_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_string_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "getprop"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "getprops"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "hashvalue"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_absolute"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_add"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_add_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_add_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_concatenate"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_concatenate_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_divide"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_divide_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_divide_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_floor_divide"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_floor_divide_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_floor_divide_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_logical_not"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_modulus"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_modulus_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_modulus_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_multiply"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_multiply_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_multiply_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_neg"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_repeat"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_repeat_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_subtract"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_subtract_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_subtract_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "increment"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "init"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "init_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "init_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "inspect"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "inspect_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "instantiate"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "invoke"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "is_equal"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "is_equal_num"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "is_equal_string"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "is_same"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "isa"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "isa_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "logical_and"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "logical_not"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "logical_or"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "logical_xor"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "mark"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "modulus"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "modulus_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "modulus_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "morph"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "multiply"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "multiply_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "multiply_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "name"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "neg"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "pop_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "pop_integer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "pop_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "pop_string"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "push_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "push_integer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "push_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "push_string"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "remove_attribute"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "remove_method"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "remove_parent"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "remove_role"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "remove_vtable_override"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "repeat"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "repeat_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_attr_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_attr_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_bool"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_integer_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_integer_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_integer_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_integer_native"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_number_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_number_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_number_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_number_native"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pmc_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pmc_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pmc_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pointer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pointer_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pointer_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_pointer_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_string_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_string_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_string_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_string_native"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "setprop"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "share"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "share_ro"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "shift_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "shift_integer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "shift_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "shift_string"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "splice"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "substr"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "substr_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "subtract"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "subtract_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "subtract_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "thaw"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "thawfinish"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "type"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "unshift_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "unshift_integer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "unshift_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "unshift_string"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "visit"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "all"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_attribute"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_method"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_parent"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_role"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "add_vtable_override"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "can"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "clone"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "clone_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "defined"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "defined_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "defined_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "defined_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "delprop"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "destroy"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "does"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "does_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "find_method"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "freeze"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_attr_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_attr_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_class"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_iter"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_namespace"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "getprop"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "getprops"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "hashvalue"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "init"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "init_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "init_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "inspect"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "inspect_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "instantiate"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "invoke"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "isa"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "isa_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "mark"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "morph"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "name"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "remove_attribute"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "remove_method"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "remove_parent"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "remove_role"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "remove_vtable_override"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_attr_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "set_attr_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "setprop"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "share"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "share_ro"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "thaw"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "thawfinish"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "type"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "visit"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "main"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "push_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "push_integer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "push_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "push_string"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "push"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "cmp"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "cmp_num"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "cmp_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "cmp_string"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "i_logical_not"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "is_equal"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "is_equal_num"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "is_equal_string"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "is_same"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "logical_and"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "logical_not"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "logical_or"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "logical_xor"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "cmp"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "splice"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "splice"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "unshift_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "unshift_integer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "unshift_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "unshift_string"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "unshift"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "shift_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "shift_integer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "shift_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "shift_string"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "shift"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "delete_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "delete_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "delete_keyed_str"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "delete"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "elements"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "fetchsize"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "exists_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "exists_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "exists_keyed_str"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "exists"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_bool"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_integer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_integer_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_integer_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_integer_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_number"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_number_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_number_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_number_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pmc_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pmc_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pmc_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pointer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pointer_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pointer_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_pointer_keyed_str"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_repr"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_string"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_string_keyed"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_string_keyed_int"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "get_string_keyed_str"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "fetch"), temp);

    temp = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "pop_float"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "pop_integer"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "pop_pmc"));
    VTABLE_push_string(interp, temp, CONST_STRING(interp, "pop_string"));
    parrot_hash_put(interp, vtable_group_items,
        CONST_STRING(interp, "pop"), temp);
    /* END vtable mapping group items */

    /* BEGIN vtable mapping item groups */
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "absolute"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "add"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "add_attribute"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "add_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "add_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "add_method"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "add_parent"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "add_role"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "add_vtable_override"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "assign_pmc"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "assign_string_native"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "can"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "clone"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "clone_pmc"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "cmp"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "cmp_num"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "cmp_pmc"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "cmp_string"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "concatenate"),
                    CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "concatenate_str"),
                    CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "decrement"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "defined"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "defined_keyed"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "defined_keyed_int"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "defined_keyed_str"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "delete_keyed"),
                    CONST_STRING(interp, "delete"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "delete_keyed_int"),
                    CONST_STRING(interp, "delete"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "delete_keyed_str"),
                    CONST_STRING(interp, "delete"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "delprop"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "destroy"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "divide"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "divide_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "divide_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "does"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "does_pmc"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "elements"),
                    CONST_STRING(interp, "fetchsize"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "exists_keyed"),
                    CONST_STRING(interp, "exists"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "exists_keyed_int"),
                    CONST_STRING(interp, "exists"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "exists_keyed_str"),
                    CONST_STRING(interp, "exists"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "find_method"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "floor_divide"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "floor_divide_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "floor_divide_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "freeze"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_attr_keyed"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_attr_str"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_bool"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_class"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_integer"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_integer_keyed"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_integer_keyed_int"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_integer_keyed_str"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_iter"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_namespace"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_number"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_number_keyed"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_number_keyed_int"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_number_keyed_str"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_pmc"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_pmc_keyed"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_pmc_keyed_int"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_pmc_keyed_str"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_pointer"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_pointer_keyed"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_pointer_keyed_int"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_pointer_keyed_str"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_repr"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_string"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_string_keyed"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_string_keyed_int"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "get_string_keyed_str"),
                    CONST_STRING(interp, "fetch"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "getprop"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "getprops"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "hashvalue"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_absolute"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_add"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_add_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_add_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_concatenate"),
                    CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_concatenate_str"),
                    CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_divide"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_divide_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_divide_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_floor_divide"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_floor_divide_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_floor_divide_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_logical_not"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_modulus"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_modulus_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_modulus_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_multiply"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_multiply_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_multiply_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_neg"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_repeat"),
                    CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_repeat_int"),
                    CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_subtract"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_subtract_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "i_subtract_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "increment"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "init"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "init_int"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "init_pmc"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "inspect"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "inspect_str"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "instantiate"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "invoke"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "is_equal"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "is_equal_num"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "is_equal_string"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "is_same"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "isa"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "isa_pmc"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "logical_and"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "logical_not"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "logical_or"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "logical_xor"),
                    CONST_STRING(interp, "cmp"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "mark"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "modulus"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "modulus_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "modulus_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "morph"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "multiply"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "multiply_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "multiply_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "name"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "neg"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "pop_float"),
                    CONST_STRING(interp, "pop"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "pop_integer"),
                    CONST_STRING(interp, "pop"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "pop_pmc"),
                    CONST_STRING(interp, "pop"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "pop_string"),
                    CONST_STRING(interp, "pop"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "push_float"),
                    CONST_STRING(interp, "push"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "push_integer"),
                    CONST_STRING(interp, "push"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "push_pmc"),
                    CONST_STRING(interp, "push"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "push_string"),
                    CONST_STRING(interp, "push"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "remove_attribute"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "remove_method"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "remove_parent"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "remove_role"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "remove_vtable_override"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "repeat"),
                    CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "repeat_int"),
                    CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_attr_keyed"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_attr_str"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_bool"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_integer_keyed"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_integer_keyed_int"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_integer_keyed_str"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_integer_native"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_number_keyed"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_number_keyed_int"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_number_keyed_str"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_number_native"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_pmc"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_pmc_keyed"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_pmc_keyed_int"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_pmc_keyed_str"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_pointer"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_pointer_keyed"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_pointer_keyed_int"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_pointer_keyed_str"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_string_keyed"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_string_keyed_int"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_string_keyed_str"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "set_string_native"),
                    CONST_STRING(interp, "store"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "setprop"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "share"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "share_ro"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "shift_float"),
                    CONST_STRING(interp, "shift"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "shift_integer"),
                    CONST_STRING(interp, "shift"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "shift_pmc"),
                    CONST_STRING(interp, "shift"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "shift_string"),
                    CONST_STRING(interp, "shift"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "splice"),
                    CONST_STRING(interp, "splice"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "substr"),
                    CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "substr_str"),
                    CONST_STRING(interp, "string"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "subtract"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "subtract_float"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "subtract_int"),
                    CONST_STRING(interp, "math"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "thaw"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "thawfinish"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "type"),
                    CONST_STRING(interp, "main"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "unshift_float"),
                    CONST_STRING(interp, "unshift"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "unshift_integer"),
                    CONST_STRING(interp, "unshift"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "unshift_pmc"),
                    CONST_STRING(interp, "unshift"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "unshift_string"),
                    CONST_STRING(interp, "unshift"));
    parrot_hash_put(interp, vtable_item_groups, CONST_STRING(interp, "visit"),
                    CONST_STRING(interp, "main"));
    /* END vtable mapping item groups */
}

void destroy_vtable_common_hashes(PARROT_INTERP) {
    if (vtable_registry == NULL) { return; }

    if (parrot_hash_size(interp, vtable_registry) == 0) {
        parrot_hash_destroy(interp, vtable_registry);
        parrot_hash_destroy(interp, vtable_name_stubs);
        parrot_hash_destroy(interp, vtable_group_items);
        parrot_hash_destroy(interp, vtable_item_groups);

        vtable_first_run = 1;
        vtable_registry    = NULL;
        vtable_name_stubs  = NULL;
        vtable_group_items = NULL;
        vtable_item_groups = NULL;
    }
}

void setup_vtable_individual_hashes(PARROT_INTERP, Hash *orig_hash, Hash *instr_hash,
                                    _vtable *vt_orig, _vtable *vt_instr) {
    /* BEGIN vtable mapping name offset */
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "absolute"), &(vt_instr->absolute));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add"), &(vt_instr->add));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_attribute"), &(vt_instr->add_attribute));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_float"), &(vt_instr->add_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_int"), &(vt_instr->add_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_method"), &(vt_instr->add_method));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_parent"), &(vt_instr->add_parent));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_role"), &(vt_instr->add_role));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "add_vtable_override"), &(vt_instr->add_vtable_override));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "assign_pmc"), &(vt_instr->assign_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "assign_string_native"), &(vt_instr->assign_string_native));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "can"), &(vt_instr->can));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "clone"), &(vt_instr->clone));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "clone_pmc"), &(vt_instr->clone_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "cmp"), &(vt_instr->cmp));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "cmp_num"), &(vt_instr->cmp_num));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "cmp_pmc"), &(vt_instr->cmp_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "cmp_string"), &(vt_instr->cmp_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "concatenate"), &(vt_instr->concatenate));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "concatenate_str"), &(vt_instr->concatenate_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "decrement"), &(vt_instr->decrement));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "defined"), &(vt_instr->defined));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "defined_keyed"), &(vt_instr->defined_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "defined_keyed_int"), &(vt_instr->defined_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "defined_keyed_str"), &(vt_instr->defined_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "delete_keyed"), &(vt_instr->delete_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "delete_keyed_int"), &(vt_instr->delete_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "delete_keyed_str"), &(vt_instr->delete_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "delprop"), &(vt_instr->delprop));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "destroy"), &(vt_instr->destroy));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "divide"), &(vt_instr->divide));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "divide_float"), &(vt_instr->divide_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "divide_int"), &(vt_instr->divide_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "does"), &(vt_instr->does));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "does_pmc"), &(vt_instr->does_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "elements"), &(vt_instr->elements));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "exists_keyed"), &(vt_instr->exists_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "exists_keyed_int"), &(vt_instr->exists_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "exists_keyed_str"), &(vt_instr->exists_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "find_method"), &(vt_instr->find_method));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "floor_divide"), &(vt_instr->floor_divide));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "floor_divide_float"), &(vt_instr->floor_divide_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "floor_divide_int"), &(vt_instr->floor_divide_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "freeze"), &(vt_instr->freeze));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_attr_keyed"), &(vt_instr->get_attr_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_attr_str"), &(vt_instr->get_attr_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_bool"), &(vt_instr->get_bool));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_class"), &(vt_instr->get_class));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_integer"), &(vt_instr->get_integer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_integer_keyed"), &(vt_instr->get_integer_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_integer_keyed_int"), &(vt_instr->get_integer_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_integer_keyed_str"), &(vt_instr->get_integer_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_iter"), &(vt_instr->get_iter));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_namespace"), &(vt_instr->get_namespace));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_number"), &(vt_instr->get_number));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_number_keyed"), &(vt_instr->get_number_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_number_keyed_int"), &(vt_instr->get_number_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_number_keyed_str"), &(vt_instr->get_number_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pmc"), &(vt_instr->get_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pmc_keyed"), &(vt_instr->get_pmc_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pmc_keyed_int"), &(vt_instr->get_pmc_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pmc_keyed_str"), &(vt_instr->get_pmc_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pointer"), &(vt_instr->get_pointer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pointer_keyed"), &(vt_instr->get_pointer_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pointer_keyed_int"), &(vt_instr->get_pointer_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_pointer_keyed_str"), &(vt_instr->get_pointer_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_repr"), &(vt_instr->get_repr));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_string"), &(vt_instr->get_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_string_keyed"), &(vt_instr->get_string_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_string_keyed_int"), &(vt_instr->get_string_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "get_string_keyed_str"), &(vt_instr->get_string_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "getprop"), &(vt_instr->getprop));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "getprops"), &(vt_instr->getprops));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "hashvalue"), &(vt_instr->hashvalue));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_absolute"), &(vt_instr->i_absolute));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_add"), &(vt_instr->i_add));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_add_float"), &(vt_instr->i_add_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_add_int"), &(vt_instr->i_add_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_concatenate"), &(vt_instr->i_concatenate));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_concatenate_str"), &(vt_instr->i_concatenate_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_divide"), &(vt_instr->i_divide));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_divide_float"), &(vt_instr->i_divide_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_divide_int"), &(vt_instr->i_divide_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_floor_divide"), &(vt_instr->i_floor_divide));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_floor_divide_float"), &(vt_instr->i_floor_divide_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_floor_divide_int"), &(vt_instr->i_floor_divide_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_logical_not"), &(vt_instr->i_logical_not));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_modulus"), &(vt_instr->i_modulus));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_modulus_float"), &(vt_instr->i_modulus_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_modulus_int"), &(vt_instr->i_modulus_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_multiply"), &(vt_instr->i_multiply));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_multiply_float"), &(vt_instr->i_multiply_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_multiply_int"), &(vt_instr->i_multiply_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_neg"), &(vt_instr->i_neg));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_repeat"), &(vt_instr->i_repeat));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_repeat_int"), &(vt_instr->i_repeat_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_subtract"), &(vt_instr->i_subtract));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_subtract_float"), &(vt_instr->i_subtract_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "i_subtract_int"), &(vt_instr->i_subtract_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "increment"), &(vt_instr->increment));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "init"), &(vt_instr->init));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "init_int"), &(vt_instr->init_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "init_pmc"), &(vt_instr->init_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "inspect"), &(vt_instr->inspect));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "inspect_str"), &(vt_instr->inspect_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "instantiate"), &(vt_instr->instantiate));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "invoke"), &(vt_instr->invoke));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "is_equal"), &(vt_instr->is_equal));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "is_equal_num"), &(vt_instr->is_equal_num));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "is_equal_string"), &(vt_instr->is_equal_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "is_same"), &(vt_instr->is_same));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "isa"), &(vt_instr->isa));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "isa_pmc"), &(vt_instr->isa_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "logical_and"), &(vt_instr->logical_and));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "logical_not"), &(vt_instr->logical_not));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "logical_or"), &(vt_instr->logical_or));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "logical_xor"), &(vt_instr->logical_xor));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "mark"), &(vt_instr->mark));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "modulus"), &(vt_instr->modulus));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "modulus_float"), &(vt_instr->modulus_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "modulus_int"), &(vt_instr->modulus_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "morph"), &(vt_instr->morph));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "multiply"), &(vt_instr->multiply));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "multiply_float"), &(vt_instr->multiply_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "multiply_int"), &(vt_instr->multiply_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "name"), &(vt_instr->name));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "neg"), &(vt_instr->neg));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "pop_float"), &(vt_instr->pop_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "pop_integer"), &(vt_instr->pop_integer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "pop_pmc"), &(vt_instr->pop_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "pop_string"), &(vt_instr->pop_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "push_float"), &(vt_instr->push_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "push_integer"), &(vt_instr->push_integer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "push_pmc"), &(vt_instr->push_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "push_string"), &(vt_instr->push_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "remove_attribute"), &(vt_instr->remove_attribute));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "remove_method"), &(vt_instr->remove_method));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "remove_parent"), &(vt_instr->remove_parent));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "remove_role"), &(vt_instr->remove_role));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "remove_vtable_override"), &(vt_instr->remove_vtable_override));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "repeat"), &(vt_instr->repeat));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "repeat_int"), &(vt_instr->repeat_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_attr_keyed"), &(vt_instr->set_attr_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_attr_str"), &(vt_instr->set_attr_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_bool"), &(vt_instr->set_bool));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_integer_keyed"), &(vt_instr->set_integer_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_integer_keyed_int"), &(vt_instr->set_integer_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_integer_keyed_str"), &(vt_instr->set_integer_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_integer_native"), &(vt_instr->set_integer_native));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_number_keyed"), &(vt_instr->set_number_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_number_keyed_int"), &(vt_instr->set_number_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_number_keyed_str"), &(vt_instr->set_number_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_number_native"), &(vt_instr->set_number_native));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pmc"), &(vt_instr->set_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pmc_keyed"), &(vt_instr->set_pmc_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pmc_keyed_int"), &(vt_instr->set_pmc_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pmc_keyed_str"), &(vt_instr->set_pmc_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pointer"), &(vt_instr->set_pointer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pointer_keyed"), &(vt_instr->set_pointer_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pointer_keyed_int"), &(vt_instr->set_pointer_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_pointer_keyed_str"), &(vt_instr->set_pointer_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_string_keyed"), &(vt_instr->set_string_keyed));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_string_keyed_int"), &(vt_instr->set_string_keyed_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_string_keyed_str"), &(vt_instr->set_string_keyed_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "set_string_native"), &(vt_instr->set_string_native));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "setprop"), &(vt_instr->setprop));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "share"), &(vt_instr->share));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "share_ro"), &(vt_instr->share_ro));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "shift_float"), &(vt_instr->shift_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "shift_integer"), &(vt_instr->shift_integer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "shift_pmc"), &(vt_instr->shift_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "shift_string"), &(vt_instr->shift_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "splice"), &(vt_instr->splice));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "substr"), &(vt_instr->substr));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "substr_str"), &(vt_instr->substr_str));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "subtract"), &(vt_instr->subtract));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "subtract_float"), &(vt_instr->subtract_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "subtract_int"), &(vt_instr->subtract_int));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "thaw"), &(vt_instr->thaw));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "thawfinish"), &(vt_instr->thawfinish));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "type"), &(vt_instr->type));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unshift_float"), &(vt_instr->unshift_float));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unshift_integer"), &(vt_instr->unshift_integer));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unshift_pmc"), &(vt_instr->unshift_pmc));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "unshift_string"), &(vt_instr->unshift_string));
    parrot_hash_put(interp, instr_hash,
        CONST_STRING(interp, "visit"), &(vt_instr->visit));
    /* END vtable mapping name offset */

    /* BEGIN vtable mapping name original */
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "absolute"), vt_orig->absolute);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add"), vt_orig->add);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_attribute"), vt_orig->add_attribute);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_float"), vt_orig->add_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_int"), vt_orig->add_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_method"), vt_orig->add_method);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_parent"), vt_orig->add_parent);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_role"), vt_orig->add_role);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "add_vtable_override"), vt_orig->add_vtable_override);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "assign_pmc"), vt_orig->assign_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "assign_string_native"), vt_orig->assign_string_native);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "can"), vt_orig->can);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "clone"), vt_orig->clone);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "clone_pmc"), vt_orig->clone_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "cmp"), vt_orig->cmp);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "cmp_num"), vt_orig->cmp_num);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "cmp_pmc"), vt_orig->cmp_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "cmp_string"), vt_orig->cmp_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "concatenate"), vt_orig->concatenate);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "concatenate_str"), vt_orig->concatenate_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "decrement"), vt_orig->decrement);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "defined"), vt_orig->defined);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "defined_keyed"), vt_orig->defined_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "defined_keyed_int"), vt_orig->defined_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "defined_keyed_str"), vt_orig->defined_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "delete_keyed"), vt_orig->delete_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "delete_keyed_int"), vt_orig->delete_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "delete_keyed_str"), vt_orig->delete_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "delprop"), vt_orig->delprop);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "destroy"), vt_orig->destroy);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "divide"), vt_orig->divide);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "divide_float"), vt_orig->divide_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "divide_int"), vt_orig->divide_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "does"), vt_orig->does);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "does_pmc"), vt_orig->does_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "elements"), vt_orig->elements);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "exists_keyed"), vt_orig->exists_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "exists_keyed_int"), vt_orig->exists_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "exists_keyed_str"), vt_orig->exists_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "find_method"), vt_orig->find_method);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "floor_divide"), vt_orig->floor_divide);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "floor_divide_float"), vt_orig->floor_divide_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "floor_divide_int"), vt_orig->floor_divide_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "freeze"), vt_orig->freeze);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_attr_keyed"), vt_orig->get_attr_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_attr_str"), vt_orig->get_attr_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_bool"), vt_orig->get_bool);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_class"), vt_orig->get_class);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_integer"), vt_orig->get_integer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_integer_keyed"), vt_orig->get_integer_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_integer_keyed_int"), vt_orig->get_integer_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_integer_keyed_str"), vt_orig->get_integer_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_iter"), vt_orig->get_iter);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_namespace"), vt_orig->get_namespace);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_number"), vt_orig->get_number);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_number_keyed"), vt_orig->get_number_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_number_keyed_int"), vt_orig->get_number_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_number_keyed_str"), vt_orig->get_number_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pmc"), vt_orig->get_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pmc_keyed"), vt_orig->get_pmc_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pmc_keyed_int"), vt_orig->get_pmc_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pmc_keyed_str"), vt_orig->get_pmc_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pointer"), vt_orig->get_pointer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pointer_keyed"), vt_orig->get_pointer_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pointer_keyed_int"), vt_orig->get_pointer_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_pointer_keyed_str"), vt_orig->get_pointer_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_repr"), vt_orig->get_repr);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_string"), vt_orig->get_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_string_keyed"), vt_orig->get_string_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_string_keyed_int"), vt_orig->get_string_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "get_string_keyed_str"), vt_orig->get_string_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "getprop"), vt_orig->getprop);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "getprops"), vt_orig->getprops);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "hashvalue"), vt_orig->hashvalue);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_absolute"), vt_orig->i_absolute);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_add"), vt_orig->i_add);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_add_float"), vt_orig->i_add_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_add_int"), vt_orig->i_add_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_concatenate"), vt_orig->i_concatenate);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_concatenate_str"), vt_orig->i_concatenate_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_divide"), vt_orig->i_divide);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_divide_float"), vt_orig->i_divide_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_divide_int"), vt_orig->i_divide_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_floor_divide"), vt_orig->i_floor_divide);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_floor_divide_float"), vt_orig->i_floor_divide_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_floor_divide_int"), vt_orig->i_floor_divide_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_logical_not"), vt_orig->i_logical_not);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_modulus"), vt_orig->i_modulus);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_modulus_float"), vt_orig->i_modulus_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_modulus_int"), vt_orig->i_modulus_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_multiply"), vt_orig->i_multiply);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_multiply_float"), vt_orig->i_multiply_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_multiply_int"), vt_orig->i_multiply_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_neg"), vt_orig->i_neg);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_repeat"), vt_orig->i_repeat);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_repeat_int"), vt_orig->i_repeat_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_subtract"), vt_orig->i_subtract);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_subtract_float"), vt_orig->i_subtract_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "i_subtract_int"), vt_orig->i_subtract_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "increment"), vt_orig->increment);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "init"), vt_orig->init);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "init_int"), vt_orig->init_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "init_pmc"), vt_orig->init_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "inspect"), vt_orig->inspect);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "inspect_str"), vt_orig->inspect_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "instantiate"), vt_orig->instantiate);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "invoke"), vt_orig->invoke);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "is_equal"), vt_orig->is_equal);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "is_equal_num"), vt_orig->is_equal_num);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "is_equal_string"), vt_orig->is_equal_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "is_same"), vt_orig->is_same);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "isa"), vt_orig->isa);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "isa_pmc"), vt_orig->isa_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "logical_and"), vt_orig->logical_and);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "logical_not"), vt_orig->logical_not);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "logical_or"), vt_orig->logical_or);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "logical_xor"), vt_orig->logical_xor);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "mark"), vt_orig->mark);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "modulus"), vt_orig->modulus);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "modulus_float"), vt_orig->modulus_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "modulus_int"), vt_orig->modulus_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "morph"), vt_orig->morph);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "multiply"), vt_orig->multiply);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "multiply_float"), vt_orig->multiply_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "multiply_int"), vt_orig->multiply_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "name"), vt_orig->name);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "neg"), vt_orig->neg);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "pop_float"), vt_orig->pop_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "pop_integer"), vt_orig->pop_integer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "pop_pmc"), vt_orig->pop_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "pop_string"), vt_orig->pop_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "push_float"), vt_orig->push_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "push_integer"), vt_orig->push_integer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "push_pmc"), vt_orig->push_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "push_string"), vt_orig->push_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "remove_attribute"), vt_orig->remove_attribute);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "remove_method"), vt_orig->remove_method);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "remove_parent"), vt_orig->remove_parent);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "remove_role"), vt_orig->remove_role);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "remove_vtable_override"), vt_orig->remove_vtable_override);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "repeat"), vt_orig->repeat);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "repeat_int"), vt_orig->repeat_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_attr_keyed"), vt_orig->set_attr_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_attr_str"), vt_orig->set_attr_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_bool"), vt_orig->set_bool);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_integer_keyed"), vt_orig->set_integer_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_integer_keyed_int"), vt_orig->set_integer_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_integer_keyed_str"), vt_orig->set_integer_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_integer_native"), vt_orig->set_integer_native);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_number_keyed"), vt_orig->set_number_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_number_keyed_int"), vt_orig->set_number_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_number_keyed_str"), vt_orig->set_number_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_number_native"), vt_orig->set_number_native);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pmc"), vt_orig->set_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pmc_keyed"), vt_orig->set_pmc_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pmc_keyed_int"), vt_orig->set_pmc_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pmc_keyed_str"), vt_orig->set_pmc_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pointer"), vt_orig->set_pointer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pointer_keyed"), vt_orig->set_pointer_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pointer_keyed_int"), vt_orig->set_pointer_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_pointer_keyed_str"), vt_orig->set_pointer_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_string_keyed"), vt_orig->set_string_keyed);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_string_keyed_int"), vt_orig->set_string_keyed_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_string_keyed_str"), vt_orig->set_string_keyed_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "set_string_native"), vt_orig->set_string_native);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "setprop"), vt_orig->setprop);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "share"), vt_orig->share);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "share_ro"), vt_orig->share_ro);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "shift_float"), vt_orig->shift_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "shift_integer"), vt_orig->shift_integer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "shift_pmc"), vt_orig->shift_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "shift_string"), vt_orig->shift_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "splice"), vt_orig->splice);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "substr"), vt_orig->substr);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "substr_str"), vt_orig->substr_str);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "subtract"), vt_orig->subtract);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "subtract_float"), vt_orig->subtract_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "subtract_int"), vt_orig->subtract_int);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "thaw"), vt_orig->thaw);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "thawfinish"), vt_orig->thawfinish);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "type"), vt_orig->type);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unshift_float"), vt_orig->unshift_float);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unshift_integer"), vt_orig->unshift_integer);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unshift_pmc"), vt_orig->unshift_pmc);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "unshift_string"), vt_orig->unshift_string);
    parrot_hash_put(interp, orig_hash,
        CONST_STRING(interp, "visit"), vt_orig->visit);
    /* END vtable mapping name original */
}

/* BEGIN vtable stubs */
static
PMC* stub_absolute(PARROT_INTERP, PMC *pmc, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::absolute"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->absolute(interp, pmc, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_add(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::add"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->add(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_add_attribute(PARROT_INTERP, PMC *pmc, STRING* name, PMC* type) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PSP", pmc, name, type);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::add_attribute"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->add_attribute(interp, pmc, name, type);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
PMC* stub_add_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PFP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::add_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->add_float(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_add_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::add_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->add_int(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_add_method(PARROT_INTERP, PMC *pmc, STRING* method_name, PMC* sub_pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PSP", pmc, method_name, sub_pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::add_method"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->add_method(interp, pmc, method_name, sub_pmc);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_add_parent(PARROT_INTERP, PMC *pmc, PMC* parent) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, parent);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::add_parent"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->add_parent(interp, pmc, parent);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_add_role(PARROT_INTERP, PMC *pmc, PMC* role) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, role);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::add_role"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->add_role(interp, pmc, role);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_add_vtable_override(PARROT_INTERP, PMC *pmc, STRING* vtable_name, PMC* sub_pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PSP", pmc, vtable_name, sub_pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::add_vtable_override"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->add_vtable_override(interp, pmc, vtable_name, sub_pmc);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_assign_pmc(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::assign_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->assign_pmc(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_assign_string_native(PARROT_INTERP, PMC *pmc, STRING* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::assign_string_native"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->assign_string_native(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
INTVAL stub_can(PARROT_INTERP, PMC *pmc, STRING* method) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, method);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::can"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->can(interp, pmc, method);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_clone(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::clone"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->clone(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_clone_pmc(PARROT_INTERP, PMC *pmc, PMC* args) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, args);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::clone_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->clone_pmc(interp, pmc, args);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_cmp(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::cmp"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->cmp(interp, pmc, value);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_cmp_num(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::cmp_num"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->cmp_num(interp, pmc, value);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_cmp_pmc(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::cmp_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->cmp_pmc(interp, pmc, value);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_cmp_string(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::cmp_string"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->cmp_string(interp, pmc, value);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_concatenate(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::string::concatenate"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->concatenate(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_concatenate_str(PARROT_INTERP, PMC *pmc, STRING* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PSP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::string::concatenate_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->concatenate_str(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_decrement(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::decrement"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->decrement(interp, pmc);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
INTVAL stub_defined(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::defined"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->defined(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_defined_keyed(PARROT_INTERP, PMC *pmc, PMC* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::defined_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->defined_keyed(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_defined_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::defined_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->defined_keyed_int(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_defined_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::defined_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->defined_keyed_str(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_delete_keyed(PARROT_INTERP, PMC *pmc, PMC* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::delete::delete_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->delete_keyed(interp, pmc, key);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_delete_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::delete::delete_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->delete_keyed_int(interp, pmc, key);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_delete_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::delete::delete_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->delete_keyed_str(interp, pmc, key);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_delprop(PARROT_INTERP, PMC *pmc, STRING* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::delprop"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->delprop(interp, pmc, key);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_destroy(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::destroy"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->destroy(interp, pmc);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
PMC* stub_divide(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::divide"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->divide(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_divide_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PFP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::divide_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->divide_float(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_divide_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::divide_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->divide_int(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_does(PARROT_INTERP, PMC *pmc, STRING* role) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, role);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::does"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->does(interp, pmc, role);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_does_pmc(PARROT_INTERP, PMC *pmc, PMC* role) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, role);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::does_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->does_pmc(interp, pmc, role);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_elements(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetchsize::elements"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->elements(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_exists_keyed(PARROT_INTERP, PMC *pmc, PMC* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::exists::exists_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->exists_keyed(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_exists_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::exists::exists_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->exists_keyed_int(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_exists_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::exists::exists_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->exists_keyed_str(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_find_method(PARROT_INTERP, PMC *pmc, STRING* method_name) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, method_name);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::find_method"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->find_method(interp, pmc, method_name);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_floor_divide(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::floor_divide"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->floor_divide(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_floor_divide_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PFP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::floor_divide_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->floor_divide_float(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_floor_divide_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::floor_divide_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->floor_divide_int(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_freeze(PARROT_INTERP, PMC *pmc, PMC* info) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, info);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::freeze"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->freeze(interp, pmc, info);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
PMC* stub_get_attr_keyed(PARROT_INTERP, PMC *pmc, PMC* key, STRING* idx) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPS", pmc, key, idx);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::get_attr_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_attr_keyed(interp, pmc, key, idx);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_get_attr_str(PARROT_INTERP, PMC *pmc, STRING* idx) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, idx);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::get_attr_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_attr_str(interp, pmc, idx);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_get_bool(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_bool"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_bool(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_get_class(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::get_class"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_class(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_get_integer(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_integer"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_integer(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_get_integer_keyed(PARROT_INTERP, PMC *pmc, PMC* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_integer_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_integer_keyed(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_get_integer_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_integer_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_integer_keyed_int(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_get_integer_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_integer_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_integer_keyed_str(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_get_iter(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::get_iter"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_iter(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_get_namespace(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::get_namespace"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_namespace(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
FLOATVAL stub_get_number(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    FLOATVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_number"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_number(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "F", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
FLOATVAL stub_get_number_keyed(PARROT_INTERP, PMC *pmc, PMC* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    FLOATVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_number_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_number_keyed(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "F", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
FLOATVAL stub_get_number_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    FLOATVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_number_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_number_keyed_int(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "F", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
FLOATVAL stub_get_number_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    FLOATVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_number_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_number_keyed_str(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "F", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_get_pmc(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_pmc(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_get_pmc_keyed(PARROT_INTERP, PMC *pmc, PMC* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_pmc_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_pmc_keyed(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_get_pmc_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_pmc_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_pmc_keyed_int(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_get_pmc_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_pmc_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_pmc_keyed_str(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void* stub_get_pointer(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    void* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_pointer"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_pointer(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void* stub_get_pointer_keyed(PARROT_INTERP, PMC *pmc, PMC* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    void* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_pointer_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_pointer_keyed(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void* stub_get_pointer_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    void* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_pointer_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_pointer_keyed_int(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void* stub_get_pointer_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    void* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_pointer_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_pointer_keyed_str(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
STRING* stub_get_repr(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    STRING* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_repr"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_repr(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "S", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
STRING* stub_get_string(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    STRING* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_string"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_string(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "S", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
STRING* stub_get_string_keyed(PARROT_INTERP, PMC *pmc, PMC* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    STRING* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_string_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_string_keyed(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "S", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
STRING* stub_get_string_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    STRING* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_string_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_string_keyed_int(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "S", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
STRING* stub_get_string_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    STRING* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::fetch::get_string_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->get_string_keyed_str(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "S", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_getprop(PARROT_INTERP, PMC *pmc, STRING* key) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, key);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::getprop"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->getprop(interp, pmc, key);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_getprops(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::getprops"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->getprops(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_hashvalue(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::hashvalue"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->hashvalue(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_i_absolute(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_absolute"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_absolute(interp, pmc);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_add(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_add"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_add(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_add_float(PARROT_INTERP, PMC *pmc, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PF", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_add_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_add_float(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_add_int(PARROT_INTERP, PMC *pmc, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_add_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_add_int(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_concatenate(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::string::i_concatenate"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_concatenate(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_concatenate_str(PARROT_INTERP, PMC *pmc, STRING* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::string::i_concatenate_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_concatenate_str(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_divide(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_divide"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_divide(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_divide_float(PARROT_INTERP, PMC *pmc, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PF", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_divide_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_divide_float(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_divide_int(PARROT_INTERP, PMC *pmc, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_divide_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_divide_int(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_floor_divide(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_floor_divide"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_floor_divide(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_floor_divide_float(PARROT_INTERP, PMC *pmc, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PF", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_floor_divide_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_floor_divide_float(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_floor_divide_int(PARROT_INTERP, PMC *pmc, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_floor_divide_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_floor_divide_int(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_logical_not(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::i_logical_not"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_logical_not(interp, pmc);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_modulus(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_modulus"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_modulus(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_modulus_float(PARROT_INTERP, PMC *pmc, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PF", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_modulus_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_modulus_float(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_modulus_int(PARROT_INTERP, PMC *pmc, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_modulus_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_modulus_int(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_multiply(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_multiply"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_multiply(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_multiply_float(PARROT_INTERP, PMC *pmc, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PF", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_multiply_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_multiply_float(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_multiply_int(PARROT_INTERP, PMC *pmc, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_multiply_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_multiply_int(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_neg(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_neg"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_neg(interp, pmc);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_repeat(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::string::i_repeat"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_repeat(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_repeat_int(PARROT_INTERP, PMC *pmc, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::string::i_repeat_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_repeat_int(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_subtract(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_subtract"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_subtract(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_subtract_float(PARROT_INTERP, PMC *pmc, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PF", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_subtract_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_subtract_float(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_i_subtract_int(PARROT_INTERP, PMC *pmc, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::i_subtract_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->i_subtract_int(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_increment(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::increment"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->increment(interp, pmc);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_init(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::init"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->init(interp, pmc);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_init_int(PARROT_INTERP, PMC *pmc, INTVAL initializer) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, initializer);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::init_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->init_int(interp, pmc, initializer);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_init_pmc(PARROT_INTERP, PMC *pmc, PMC* initializer) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, initializer);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::init_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->init_pmc(interp, pmc, initializer);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
PMC* stub_inspect(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::inspect"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->inspect(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_inspect_str(PARROT_INTERP, PMC *pmc, STRING* what) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, what);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::inspect_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->inspect_str(interp, pmc, what);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_instantiate(PARROT_INTERP, PMC *pmc, PMC* sig) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, sig);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::instantiate"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->instantiate(interp, pmc, sig);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
opcode_t* stub_invoke(PARROT_INTERP, PMC *pmc, void* next) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    opcode_t* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PV", pmc, next);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::invoke"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->invoke(interp, pmc, next);
    ret_pack = instrument_pack_params(supervisor, "V", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_is_equal(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::is_equal"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->is_equal(interp, pmc, value);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_is_equal_num(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::is_equal_num"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->is_equal_num(interp, pmc, value);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_is_equal_string(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::is_equal_string"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->is_equal_string(interp, pmc, value);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_is_same(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::is_same"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->is_same(interp, pmc, value);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_isa(PARROT_INTERP, PMC *pmc, STRING* _class) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, _class);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::isa"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->isa(interp, pmc, _class);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_isa_pmc(PARROT_INTERP, PMC *pmc, PMC* _class) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, _class);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::isa_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->isa_pmc(interp, pmc, _class);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_logical_and(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::logical_and"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->logical_and(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_logical_not(PARROT_INTERP, PMC *pmc, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::logical_not"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->logical_not(interp, pmc, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_logical_or(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::logical_or"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->logical_or(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_logical_xor(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::cmp::logical_xor"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->logical_xor(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_mark(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::mark"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->mark(interp, pmc);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
PMC* stub_modulus(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::modulus"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->modulus(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_modulus_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PFP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::modulus_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->modulus_float(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_modulus_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::modulus_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->modulus_int(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_morph(PARROT_INTERP, PMC *pmc, PMC* type) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, type);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::morph"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->morph(interp, pmc, type);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
PMC* stub_multiply(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::multiply"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->multiply(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_multiply_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PFP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::multiply_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->multiply_float(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_multiply_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::multiply_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->multiply_int(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
STRING* stub_name(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    STRING* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::name"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->name(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "S", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_neg(PARROT_INTERP, PMC *pmc, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::neg"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->neg(interp, pmc, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
FLOATVAL stub_pop_float(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    FLOATVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::pop::pop_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->pop_float(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "F", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_pop_integer(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::pop::pop_integer"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->pop_integer(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_pop_pmc(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::pop::pop_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->pop_pmc(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
STRING* stub_pop_string(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    STRING* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::pop::pop_string"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->pop_string(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "S", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_push_float(PARROT_INTERP, PMC *pmc, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PF", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::push::push_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->push_float(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_push_integer(PARROT_INTERP, PMC *pmc, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::push::push_integer"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->push_integer(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_push_pmc(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::push::push_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->push_pmc(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_push_string(PARROT_INTERP, PMC *pmc, STRING* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::push::push_string"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->push_string(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_remove_attribute(PARROT_INTERP, PMC *pmc, STRING* name) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, name);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::remove_attribute"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->remove_attribute(interp, pmc, name);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_remove_method(PARROT_INTERP, PMC *pmc, STRING* method_name) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, method_name);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::remove_method"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->remove_method(interp, pmc, method_name);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_remove_parent(PARROT_INTERP, PMC *pmc, PMC* parent) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, parent);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::remove_parent"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->remove_parent(interp, pmc, parent);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_remove_role(PARROT_INTERP, PMC *pmc, PMC* role) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, role);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::remove_role"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->remove_role(interp, pmc, role);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_remove_vtable_override(PARROT_INTERP, PMC *pmc, STRING* vtable_name) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, vtable_name);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::remove_vtable_override"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->remove_vtable_override(interp, pmc, vtable_name);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
PMC* stub_repeat(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::string::repeat"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->repeat(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_repeat_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::string::repeat_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->repeat_int(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_set_attr_keyed(PARROT_INTERP, PMC *pmc, PMC* key, STRING* idx, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPSP", pmc, key, idx, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::set_attr_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_attr_keyed(interp, pmc, key, idx, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_attr_str(PARROT_INTERP, PMC *pmc, STRING* idx, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PSP", pmc, idx, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::set_attr_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_attr_str(interp, pmc, idx, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_bool(PARROT_INTERP, PMC *pmc, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_bool"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_bool(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_integer_keyed(PARROT_INTERP, PMC *pmc, PMC* key, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPI", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_integer_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_integer_keyed(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_integer_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PII", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_integer_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_integer_keyed_int(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_integer_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PSI", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_integer_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_integer_keyed_str(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_integer_native(PARROT_INTERP, PMC *pmc, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_integer_native"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_integer_native(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_number_keyed(PARROT_INTERP, PMC *pmc, PMC* key, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPF", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_number_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_number_keyed(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_number_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIF", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_number_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_number_keyed_int(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_number_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PSF", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_number_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_number_keyed_str(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_number_native(PARROT_INTERP, PMC *pmc, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PF", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_number_native"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_number_native(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_pmc(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_pmc(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_pmc_keyed(PARROT_INTERP, PMC *pmc, PMC* key, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_pmc_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_pmc_keyed(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_pmc_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIP", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_pmc_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_pmc_keyed_int(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_pmc_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PSP", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_pmc_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_pmc_keyed_str(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_pointer(PARROT_INTERP, PMC *pmc, void* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PV", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_pointer"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_pointer(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_pointer_keyed(PARROT_INTERP, PMC *pmc, PMC* key, void* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPV", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_pointer_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_pointer_keyed(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_pointer_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key, void* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIV", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_pointer_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_pointer_keyed_int(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_pointer_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key, void* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PSV", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_pointer_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_pointer_keyed_str(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_string_keyed(PARROT_INTERP, PMC *pmc, PMC* key, STRING* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPS", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_string_keyed"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_string_keyed(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_string_keyed_int(PARROT_INTERP, PMC *pmc, INTVAL key, STRING* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIS", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_string_keyed_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_string_keyed_int(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_string_keyed_str(PARROT_INTERP, PMC *pmc, STRING* key, STRING* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PSS", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_string_keyed_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_string_keyed_str(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_set_string_native(PARROT_INTERP, PMC *pmc, STRING* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::store::set_string_native"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->set_string_native(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_setprop(PARROT_INTERP, PMC *pmc, STRING* key, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PSP", pmc, key, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::setprop"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->setprop(interp, pmc, key, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_share(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::share"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->share(interp, pmc);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
PMC* stub_share_ro(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::share_ro"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->share_ro(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
FLOATVAL stub_shift_float(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    FLOATVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::shift::shift_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->shift_float(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "F", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
INTVAL stub_shift_integer(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::shift::shift_integer"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->shift_integer(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_shift_pmc(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::shift::shift_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->shift_pmc(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
STRING* stub_shift_string(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    STRING* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::shift::shift_string"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->shift_string(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "S", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_splice(PARROT_INTERP, PMC *pmc, PMC* value, INTVAL offset, INTVAL count) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPII", pmc, value, offset, count);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::splice::splice"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->splice(interp, pmc, value, offset, count);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_substr(PARROT_INTERP, PMC *pmc, INTVAL offset, INTVAL length, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIIP", pmc, offset, length, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::string::substr"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->substr(interp, pmc, offset, length, dest);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
STRING* stub_substr_str(PARROT_INTERP, PMC *pmc, INTVAL offset, INTVAL length) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    STRING* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PII", pmc, offset, length);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::string::substr_str"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->substr_str(interp, pmc, offset, length);
    ret_pack = instrument_pack_params(supervisor, "S", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_subtract(PARROT_INTERP, PMC *pmc, PMC* value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PPP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::subtract"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->subtract(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_subtract_float(PARROT_INTERP, PMC *pmc, FLOATVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PFP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::subtract_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->subtract_float(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
PMC* stub_subtract_int(PARROT_INTERP, PMC *pmc, INTVAL value, PMC* dest) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    PMC* ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PIP", pmc, value, dest);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::math::subtract_int"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->subtract_int(interp, pmc, value, dest);
    ret_pack = instrument_pack_params(supervisor, "P", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_thaw(PARROT_INTERP, PMC *pmc, PMC* info) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, info);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::thaw"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->thaw(interp, pmc, info);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_thawfinish(PARROT_INTERP, PMC *pmc, PMC* info) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, info);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::thawfinish"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->thawfinish(interp, pmc, info);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
INTVAL stub_type(PARROT_INTERP, PMC *pmc) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;
    INTVAL ret;
    PMC *ret_pack;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "P", pmc);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::type"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ret = ((_vtable *)orig_vtable)->type(interp, pmc);
    ret_pack = instrument_pack_params(supervisor, "I", ret);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "return"), ret_pack);

    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
    return ret;
}

static
void stub_unshift_float(PARROT_INTERP, PMC *pmc, FLOATVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PF", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::unshift::unshift_float"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->unshift_float(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_unshift_integer(PARROT_INTERP, PMC *pmc, INTVAL value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PI", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::unshift::unshift_integer"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->unshift_integer(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_unshift_pmc(PARROT_INTERP, PMC *pmc, PMC* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::unshift::unshift_pmc"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->unshift_pmc(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_unshift_string(PARROT_INTERP, PMC *pmc, STRING* value) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PS", pmc, value);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::unshift::unshift_string"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->unshift_string(interp, pmc, value);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

static
void stub_visit(PARROT_INTERP, PMC *pmc, PMC* info) {
    PMC *instrument, *instrumentvt, *params, *data, *event_array, *recall;
    Parrot_Interp supervisor;
    STRING *raise_event, *event;
    void *orig_vtable;

    instrumentvt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);
    GETATTR_InstrumentVtable_original_struct(interp, instrumentvt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instrumentvt, supervisor);
    GETATTR_InstrumentVtable_event_prefix(interp, instrumentvt, event_array);

    params = instrument_pack_params(supervisor, "PP", pmc, info);
    data   = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data, CONST_STRING(supervisor, "parameters"), params);

    event_array = VTABLE_clone(supervisor, event_array);
    VTABLE_push_string(supervisor, event_array,
                       CONST_STRING(supervisor, "vtable::main::visit"));

    raise_event = CONST_STRING(supervisor, "raise_event");
    event       = Parrot_str_join(supervisor, CONST_STRING(supervisor, "::"), event_array);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, &recall);
    ((_vtable *)orig_vtable)->visit(interp, pmc, info);
    Parrot_pcc_invoke_method_from_c_args(supervisor, instrument, raise_event, "SP->P",
        event, data, recall, &recall);
    probe_list_delete_list(supervisor, (probe_list_t *)VTABLE_get_pointer(supervisor, recall));
}

/* END vtable stubs */

/* END OF GENERATED CODE */

/*

=back

=head1 SEE ALSO

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
