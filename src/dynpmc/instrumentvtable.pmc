/*
Copyright (C) 2010, Parrot Foundation.
$Id$

=head1 NAME

src/dynpmc/instrumentpmc.pmc - Interface to instrument a PMC's vtable.

=head1 DESCRIPTION

C<InstrumentPMC> is a PMC class that provides an interface to
instrument a PMC.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

#include "pmc_instrument.h"

/* Stub Prototypes */
/* BEGIN vtable prototypes */
static void stub_init_pmc(PARROT_INTERP, PMC* pmc, PMC* initializer);
static PMC* stub_instantiate(PARROT_INTERP, PMC* pmc, PMC* sig);
static void stub_morph(PARROT_INTERP, PMC* pmc, PMC* type);
static PMC* stub_getprop(PARROT_INTERP, PMC* pmc, STRING* key);
static void stub_setprop(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value);
static void stub_delprop(PARROT_INTERP, PMC* pmc, STRING* key);
static PMC* stub_clone_pmc(PARROT_INTERP, PMC* pmc, PMC* args);
static PMC* stub_find_method(PARROT_INTERP, PMC* pmc, STRING* method_name);
static INTVAL stub_get_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static INTVAL stub_get_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static INTVAL stub_get_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static FLOATVAL stub_get_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static FLOATVAL stub_get_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static FLOATVAL stub_get_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static STRING* stub_get_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static STRING* stub_get_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static STRING* stub_get_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static PMC* stub_get_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static PMC* stub_get_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static PMC* stub_get_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static void* stub_get_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static void* stub_get_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static void* stub_get_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static void stub_set_integer_native(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_set_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, INTVAL value);
static void stub_set_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, INTVAL value);
static void stub_set_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, INTVAL value);
static void stub_set_number_native(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_set_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key, FLOATVAL value);
static void stub_set_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, FLOATVAL value);
static void stub_set_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, FLOATVAL value);
static void stub_set_string_native(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_assign_string_native(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_set_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* value);
static void stub_set_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, STRING* value);
static void stub_set_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, STRING* value);
static void stub_set_bool(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_set_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_assign_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_set_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key, PMC* value);
static void stub_set_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, PMC* value);
static void stub_set_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value);
static void stub_set_pointer(PARROT_INTERP, PMC* pmc, void* value);
static void stub_set_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, void* value);
static void stub_set_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, void* value);
static void stub_set_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, void* value);
static void stub_push_integer(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_push_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_push_string(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_push_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_unshift_integer(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_unshift_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static void stub_unshift_string(PARROT_INTERP, PMC* pmc, STRING* value);
static void stub_unshift_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_splice(PARROT_INTERP, PMC* pmc, PMC* value, INTVAL offset, INTVAL count);
static PMC* stub_add(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_add_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_add(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_add_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static PMC* stub_subtract(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_subtract(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static PMC* stub_multiply(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_multiply(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static PMC* stub_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_divide(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static PMC* stub_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static PMC* stub_modulus(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static PMC* stub_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest);
static void stub_i_modulus(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_i_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value);
static PMC* stub_absolute(PARROT_INTERP, PMC* pmc, PMC* dest);
static PMC* stub_neg(PARROT_INTERP, PMC* pmc, PMC* dest);
static INTVAL stub_is_equal(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_is_equal_num(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_is_equal_string(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_is_same(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_cmp(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_cmp_num(PARROT_INTERP, PMC* pmc, PMC* value);
static INTVAL stub_cmp_string(PARROT_INTERP, PMC* pmc, PMC* value);
static PMC* stub_cmp_pmc(PARROT_INTERP, PMC* pmc, PMC* value);
static PMC* stub_logical_or(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_logical_and(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_logical_xor(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_logical_not(PARROT_INTERP, PMC* pmc, PMC* dest);
static PMC* stub_concatenate(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value, PMC* dest);
static void stub_i_concatenate(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value);
static PMC* stub_repeat(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest);
static PMC* stub_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest);
static void stub_i_repeat(PARROT_INTERP, PMC* pmc, PMC* value);
static void stub_i_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value);
static void stub_substr(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length, PMC* dest);
static STRING* stub_substr_str(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length);
static INTVAL stub_exists_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static INTVAL stub_exists_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static INTVAL stub_exists_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static INTVAL stub_defined_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static INTVAL stub_defined_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static INTVAL stub_defined_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static void stub_delete_keyed(PARROT_INTERP, PMC* pmc, PMC* key);
static void stub_delete_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key);
static void stub_delete_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key);
static opcode_t* stub_invoke(PARROT_INTERP, PMC* pmc, void* next);
static INTVAL stub_can(PARROT_INTERP, PMC* pmc, STRING* method);
static INTVAL stub_does_pmc(PARROT_INTERP, PMC* pmc, PMC* role);
static INTVAL stub_does(PARROT_INTERP, PMC* pmc, STRING* role);
static INTVAL stub_isa_pmc(PARROT_INTERP, PMC* pmc, PMC* _class);
static INTVAL stub_isa(PARROT_INTERP, PMC* pmc, STRING* _class);
static PMC* stub_get_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx);
static PMC* stub_get_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx);
static void stub_set_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx, PMC* value);
static void stub_set_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx, PMC* value);
static void stub_add_parent(PARROT_INTERP, PMC* pmc, PMC* parent);
static void stub_remove_parent(PARROT_INTERP, PMC* pmc, PMC* parent);
static void stub_add_role(PARROT_INTERP, PMC* pmc, PMC* role);
static void stub_remove_role(PARROT_INTERP, PMC* pmc, PMC* role);
static void stub_add_attribute(PARROT_INTERP, PMC* pmc, STRING* name, PMC* type);
static void stub_remove_attribute(PARROT_INTERP, PMC* pmc, STRING* name);
static void stub_add_method(PARROT_INTERP, PMC* pmc, STRING* method_name, PMC* sub_pmc);
static void stub_remove_method(PARROT_INTERP, PMC* pmc, STRING* method_name);
static void stub_add_vtable_override(PARROT_INTERP, PMC* pmc, STRING* vtable_name, PMC* sub_pmc);
static void stub_remove_vtable_override(PARROT_INTERP, PMC* pmc, STRING* vtable_name);
static PMC* stub_inspect_str(PARROT_INTERP, PMC* pmc, STRING* what);
static void stub_freeze(PARROT_INTERP, PMC* pmc, PMC* info);
static void stub_thaw(PARROT_INTERP, PMC* pmc, PMC* info);
static void stub_thawfinish(PARROT_INTERP, PMC* pmc, PMC* info);
static void stub_visit(PARROT_INTERP, PMC* pmc, PMC* info);
static void stub_init_int(PARROT_INTERP, PMC* pmc, INTVAL initializer);

/* END vtable prototypes */

/* Helper Prototypes. */
void raise_vtable_event(PARROT_INTERP, Parrot_Interp supervised, PMC *pmc,
                        PMC *data, STRING *group, STRING *type);
void build_vtable_hashes(PARROT_INTERP, Hash *orig, Hash *instr, Hash *stub,
                         _vtable *vtable, _vtable *instr_vtable);

/* Test */
static Hash *Instrument_Vtable_Entries = NULL;
static Hash *Instrument_Vtable_Stubs   = NULL;

pmclass InstrumentVtable auto_attrs dynpmc group instrument_group {
    ATTR Parrot_Interp   supervisor;
    ATTR PMC            *instrument;
    ATTR INTVAL          class_index;
    ATTR struct _vtable *original_vtable;
    ATTR struct _vtable *instrumented_vtable;
    ATTR Hash           *original_hash;
    ATTR Hash           *instrumented_hash;

    VTABLE void init() {
        /* Not supposed to be init on its own. */
        Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                   "InstrumentVtable should be instantiated with initpmc instead.");
    }

    VTABLE void init_pmc(PMC *instrument) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);

        attr->supervisor          = INTERP;
        attr->instrument          = instrument;
        attr->original_vtable     = NULL;
        attr->instrumented_vtable = NULL;
        attr->original_hash        = parrot_new_hash(INTERP);
        attr->instrumented_hash   = parrot_new_hash(INTERP);

        /* Initialise the Instrumented Vtable registry if needed. */
        if (Instrument_Vtable_Entries == NULL) {
            Instrument_Vtable_Entries = parrot_new_hash(INTERP);
            Instrument_Vtable_Stubs   = parrot_new_hash(INTERP);
        }

        PObj_custom_destroy_SET(SELF);
    }

    VTABLE void destroy() {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);

        /* Remove entry from Instrument_Vtable_Entries. */
        parrot_hash_delete(INTERP, Instrument_Vtable_Entries, attr->instrumented_vtable);

        /* Delete the hash if the size is 0. */
        if (parrot_hash_size(INTERP, Instrument_Vtable_Entries) == 0) {
            parrot_hash_destroy(INTERP, Instrument_Vtable_Entries);
            parrot_hash_destroy(INTERP, Instrument_Vtable_Stubs);
            Instrument_Vtable_Entries = NULL;
            Instrument_Vtable_Stubs   = NULL;
        }
    }

    METHOD attach_to_class(STRING *classname) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        Parrot_Interp supervised;

        GETATTR_Instrument_supervised(INTERP, attr->instrument, supervised);

        attr->class_index     = Parrot_pmc_get_type_str(supervised, classname);
        attr->original_vtable = supervised->vtables[attr->class_index];

        /* Prepare the class's vtable for instrumentation. */
        attr->instrumented_vtable = mem_gc_allocate_zeroed_typed(supervised, _vtable);
        mem_copy_n_typed(attr->instrumented_vtable, attr->original_vtable, 1, _vtable);
        supervised->vtables[attr->class_index] = attr->instrumented_vtable;

        /* Register the instrumented vtable to SELF. */
        parrot_hash_put(INTERP, Instrument_Vtable_Entries, attr->instrumented_vtable, SELF);

        /* Build the vtable hashes, passing a sample vtable to build the offsets. */
        build_vtable_hashes(INTERP,
                            attr->original_hash, attr->instrumented_hash,
                            Instrument_Vtable_Stubs,
                            attr->original_vtable, attr->instrumented_vtable);
    }

    METHOD insert_vtable_hook(STRING *key) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        char *con_string;
        size_t **instr, *stub;

        /* Modify the entry. */
        instr  = (size_t **) parrot_hash_get(INTERP, attr->instrumented_hash, key);
        stub   = (size_t *)  parrot_hash_get(INTERP, Instrument_Vtable_Stubs, key);
        if (instr == NULL || stub ==  NULL) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                        "Unknown VTABLE entry: %Ss", key);
        }
        *instr = stub;
    }

    METHOD remove_vtable_hook(STRING *key) {
        Parrot_InstrumentVtable_attributes * const attr = PARROT_INSTRUMENTVTABLE(SELF);
        char *con_string;
        size_t **instr, *orig;

        /* Modify the entry. */
        instr  = (size_t **) parrot_hash_get(INTERP, attr->instrumented_hash, key);
        orig   = (size_t *)  parrot_hash_get(INTERP, attr->original_hash, key);
        if (instr == NULL || orig ==  NULL) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                        "Unknown VTABLE entry: %Ss", key);
        }
        *instr = orig;
    }

/*

=item C<PMC* get_hook_list(STRING *name)>

Returns a ResizableStringArray PMC filled with
the names of the gc entries to instrument.

=cut

*/

    METHOD get_hook_list(STRING *name) {
        PMC *list;

        list = Parrot_pmc_new(INTERP, enum_class_ResizableStringArray);

        /* BEGIN vtable groupings */
        if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "exists"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "exists_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "exists_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "exists_keyed_str"));
        }
        else if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "fetch"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_integer_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_integer_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_integer_keyed_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_number_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_number_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_number_keyed_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_string_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_string_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_string_keyed_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_pmc_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_pmc_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_pmc_keyed_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_pointer_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_pointer_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_pointer_keyed_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_integer_native"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_integer_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_integer_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_integer_keyed_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_number_native"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_number_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_number_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_number_keyed_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_string_native"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "assign_string_native"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_string_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_string_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_string_keyed_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_bool"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_pmc"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "assign_pmc"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_pmc_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_pmc_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_pmc_keyed_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_pointer"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_pointer_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_pointer_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_pointer_keyed_str"));
        }
        else if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "string"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "concatenate"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "concatenate_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_concatenate"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_concatenate_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "repeat"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "repeat_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_repeat"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_repeat_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "substr"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "substr_str"));
        }
        else if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "math"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_add"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_add_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_add_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "subtract"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "subtract_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "subtract_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_subtract"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_subtract_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_subtract_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "multiply"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "multiply_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "multiply_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_multiply"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_multiply_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_multiply_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "divide"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "divide_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "divide_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_divide"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_divide_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_divide_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "floor_divide"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "floor_divide_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "floor_divide_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_floor_divide"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_floor_divide_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_floor_divide_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "modulus"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "modulus_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "modulus_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_modulus"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_modulus_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_modulus_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "absolute"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "neg"));
        }
        else if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "main"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "defined_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "defined_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "defined_keyed_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "delete_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "delete_keyed_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "delete_keyed_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "invoke"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "can"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "does_pmc"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "does"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "isa_pmc"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "isa"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_attr_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "get_attr_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_attr_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_attr_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_parent"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "remove_parent"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_role"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "remove_role"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_attribute"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "remove_attribute"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_method"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "remove_method"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_vtable_override"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "remove_vtable_override"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "inspect_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "freeze"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "thaw"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "thawfinish"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "visit"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "init_int"));
        }
        else if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "fetchsize"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "push_integer"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "push_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "push_string"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "push_pmc"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "unshift_integer"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "unshift_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "unshift_string"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "unshift_pmc"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "splice"));
        }
        else if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "cmp"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "is_equal"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "is_equal_num"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "is_equal_string"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "is_same"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "cmp"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "cmp_num"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "cmp_string"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "cmp_pmc"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "logical_or"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "logical_and"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "logical_xor"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "logical_not"));
        }
        else if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "core"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "init_pmc"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "instantiate"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "morph"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "getprop"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "setprop"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "delprop"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "clone_pmc"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "find_method"));
        }
        else if (Parrot_str_equal(INTERP, name, CONST_STRING(INTERP, "write"))) {
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "morph"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_add"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_add_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_add_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_subtract"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_subtract_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_subtract_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_multiply"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_multiply_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_multiply_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_divide"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_divide_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_divide_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_floor_divide"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_floor_divide_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_floor_divide_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_modulus"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_modulus_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_modulus_float"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_concatenate"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_concatenate_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_repeat"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "i_repeat_int"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_attr_str"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "set_attr_keyed"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_parent"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "remove_parent"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_role"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "remove_role"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_attribute"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "remove_attribute"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_method"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "remove_method"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "add_vtable_override"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "remove_vtable_override"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "thaw"));
           VTABLE_push_string(INTERP, list,
               CONST_STRING(INTERP, "thawfinish"));
        }

        /* END vtable groupings */
        else {
            /* Ensure that name is the name of a hook before pushing it in. */
            size_t *check;
            check = (size_t *) parrot_hash_get(INTERP, Instrument_Vtable_Stubs, name);
            if (check == NULL) {
                Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                            "Unknown GC function: %Ss", name);
            }

            VTABLE_push_string(INTERP, list, name);
        }

        RETURN(PMC *list);
    }

}

/*
 * Helpers
 */

void raise_vtable_event(PARROT_INTERP, Parrot_Interp supervised,
                        PMC *pmc, PMC *data, STRING *group, STRING *type) {
    Parrot_Context_info info;
    PMC *task_hash, *task;
    PMC *event_arr;

    /* Get the current context info. */
    Parrot_Context_get_info(interp, CURRENT_CONTEXT(supervised), &info);

    /* Set the event type. */
    event_arr = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, event_arr, CONST_STRING(interp, "Class"));
    VTABLE_push_string(interp, event_arr, VTABLE_name(supervised, pmc));
    VTABLE_push_string(interp, event_arr, CONST_STRING(interp, "vtable"));
    VTABLE_push_string(interp, event_arr, group);
    VTABLE_push_string(interp, event_arr, type);

    /* Populate data with common items. */
    VTABLE_set_pmc_keyed_str(interp, data,
                                CONST_STRING(interp, "event"),
                                event_arr);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "file"),      info.file);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "sub"),       info.subname);
    VTABLE_set_string_keyed_str(interp,  data, CONST_STRING(interp, "namespace"), info.nsname);
    VTABLE_set_integer_keyed_str(interp, data, CONST_STRING(interp, "line"),      info.line);

    /* Raise the event. */
    task_hash = Parrot_pmc_new(interp, enum_class_Hash);
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "type"),
                                CONST_STRING(interp, "event"));
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "subtype"),
                                CONST_STRING(interp, "Instrument"));
    VTABLE_set_pmc_keyed_str(interp, task_hash, CONST_STRING(interp, "data"), data);

    task = Parrot_pmc_new_init(interp, enum_class_Task, task_hash);
    Parrot_cx_schedule_task(interp, task);
}

void build_vtable_hashes(PARROT_INTERP, Hash *orig, Hash *instr, Hash *stub,
                         _vtable *orig_vtable, _vtable *instr_vtable) {
    /* BEGIN vtable mappings */
    /* Build mappings for name -> original function.vtable entry */
    parrot_hash_put(interp, orig, CONST_STRING(interp, "init_pmc"),
                orig_vtable->init_pmc);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "instantiate"),
                orig_vtable->instantiate);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "morph"),
                orig_vtable->morph);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "getprop"),
                orig_vtable->getprop);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "setprop"),
                orig_vtable->setprop);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "delprop"),
                orig_vtable->delprop);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "clone_pmc"),
                orig_vtable->clone_pmc);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "find_method"),
                orig_vtable->find_method);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_integer_keyed"),
                orig_vtable->get_integer_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_integer_keyed_int"),
                orig_vtable->get_integer_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_integer_keyed_str"),
                orig_vtable->get_integer_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_number_keyed"),
                orig_vtable->get_number_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_number_keyed_int"),
                orig_vtable->get_number_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_number_keyed_str"),
                orig_vtable->get_number_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_string_keyed"),
                orig_vtable->get_string_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_string_keyed_int"),
                orig_vtable->get_string_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_string_keyed_str"),
                orig_vtable->get_string_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pmc_keyed"),
                orig_vtable->get_pmc_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pmc_keyed_int"),
                orig_vtable->get_pmc_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pmc_keyed_str"),
                orig_vtable->get_pmc_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pointer_keyed"),
                orig_vtable->get_pointer_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pointer_keyed_int"),
                orig_vtable->get_pointer_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_pointer_keyed_str"),
                orig_vtable->get_pointer_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_integer_native"),
                orig_vtable->set_integer_native);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_integer_keyed"),
                orig_vtable->set_integer_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_integer_keyed_int"),
                orig_vtable->set_integer_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_integer_keyed_str"),
                orig_vtable->set_integer_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_number_native"),
                orig_vtable->set_number_native);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_number_keyed"),
                orig_vtable->set_number_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_number_keyed_int"),
                orig_vtable->set_number_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_number_keyed_str"),
                orig_vtable->set_number_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_string_native"),
                orig_vtable->set_string_native);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "assign_string_native"),
                orig_vtable->assign_string_native);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_string_keyed"),
                orig_vtable->set_string_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_string_keyed_int"),
                orig_vtable->set_string_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_string_keyed_str"),
                orig_vtable->set_string_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_bool"),
                orig_vtable->set_bool);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pmc"),
                orig_vtable->set_pmc);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "assign_pmc"),
                orig_vtable->assign_pmc);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pmc_keyed"),
                orig_vtable->set_pmc_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pmc_keyed_int"),
                orig_vtable->set_pmc_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pmc_keyed_str"),
                orig_vtable->set_pmc_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pointer"),
                orig_vtable->set_pointer);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pointer_keyed"),
                orig_vtable->set_pointer_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pointer_keyed_int"),
                orig_vtable->set_pointer_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_pointer_keyed_str"),
                orig_vtable->set_pointer_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "push_integer"),
                orig_vtable->push_integer);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "push_float"),
                orig_vtable->push_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "push_string"),
                orig_vtable->push_string);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "push_pmc"),
                orig_vtable->push_pmc);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "unshift_integer"),
                orig_vtable->unshift_integer);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "unshift_float"),
                orig_vtable->unshift_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "unshift_string"),
                orig_vtable->unshift_string);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "unshift_pmc"),
                orig_vtable->unshift_pmc);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "splice"),
                orig_vtable->splice);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "add"),
                orig_vtable->add);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "add_int"),
                orig_vtable->add_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "add_float"),
                orig_vtable->add_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_add"),
                orig_vtable->i_add);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_add_int"),
                orig_vtable->i_add_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_add_float"),
                orig_vtable->i_add_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "subtract"),
                orig_vtable->subtract);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "subtract_int"),
                orig_vtable->subtract_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "subtract_float"),
                orig_vtable->subtract_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_subtract"),
                orig_vtable->i_subtract);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_subtract_int"),
                orig_vtable->i_subtract_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_subtract_float"),
                orig_vtable->i_subtract_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "multiply"),
                orig_vtable->multiply);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "multiply_int"),
                orig_vtable->multiply_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "multiply_float"),
                orig_vtable->multiply_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_multiply"),
                orig_vtable->i_multiply);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_multiply_int"),
                orig_vtable->i_multiply_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_multiply_float"),
                orig_vtable->i_multiply_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "divide"),
                orig_vtable->divide);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "divide_int"),
                orig_vtable->divide_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "divide_float"),
                orig_vtable->divide_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_divide"),
                orig_vtable->i_divide);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_divide_int"),
                orig_vtable->i_divide_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_divide_float"),
                orig_vtable->i_divide_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "floor_divide"),
                orig_vtable->floor_divide);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "floor_divide_int"),
                orig_vtable->floor_divide_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "floor_divide_float"),
                orig_vtable->floor_divide_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_floor_divide"),
                orig_vtable->i_floor_divide);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_floor_divide_int"),
                orig_vtable->i_floor_divide_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_floor_divide_float"),
                orig_vtable->i_floor_divide_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "modulus"),
                orig_vtable->modulus);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "modulus_int"),
                orig_vtable->modulus_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "modulus_float"),
                orig_vtable->modulus_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_modulus"),
                orig_vtable->i_modulus);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_modulus_int"),
                orig_vtable->i_modulus_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_modulus_float"),
                orig_vtable->i_modulus_float);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "absolute"),
                orig_vtable->absolute);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "neg"),
                orig_vtable->neg);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "is_equal"),
                orig_vtable->is_equal);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "is_equal_num"),
                orig_vtable->is_equal_num);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "is_equal_string"),
                orig_vtable->is_equal_string);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "is_same"),
                orig_vtable->is_same);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "cmp"),
                orig_vtable->cmp);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "cmp_num"),
                orig_vtable->cmp_num);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "cmp_string"),
                orig_vtable->cmp_string);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "cmp_pmc"),
                orig_vtable->cmp_pmc);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "logical_or"),
                orig_vtable->logical_or);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "logical_and"),
                orig_vtable->logical_and);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "logical_xor"),
                orig_vtable->logical_xor);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "logical_not"),
                orig_vtable->logical_not);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "concatenate"),
                orig_vtable->concatenate);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "concatenate_str"),
                orig_vtable->concatenate_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_concatenate"),
                orig_vtable->i_concatenate);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_concatenate_str"),
                orig_vtable->i_concatenate_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "repeat"),
                orig_vtable->repeat);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "repeat_int"),
                orig_vtable->repeat_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_repeat"),
                orig_vtable->i_repeat);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "i_repeat_int"),
                orig_vtable->i_repeat_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "substr"),
                orig_vtable->substr);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "substr_str"),
                orig_vtable->substr_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "exists_keyed"),
                orig_vtable->exists_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "exists_keyed_int"),
                orig_vtable->exists_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "exists_keyed_str"),
                orig_vtable->exists_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "defined_keyed"),
                orig_vtable->defined_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "defined_keyed_int"),
                orig_vtable->defined_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "defined_keyed_str"),
                orig_vtable->defined_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "delete_keyed"),
                orig_vtable->delete_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "delete_keyed_int"),
                orig_vtable->delete_keyed_int);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "delete_keyed_str"),
                orig_vtable->delete_keyed_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "invoke"),
                orig_vtable->invoke);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "can"),
                orig_vtable->can);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "does_pmc"),
                orig_vtable->does_pmc);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "does"),
                orig_vtable->does);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "isa_pmc"),
                orig_vtable->isa_pmc);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "isa"),
                orig_vtable->isa);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_attr_str"),
                orig_vtable->get_attr_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "get_attr_keyed"),
                orig_vtable->get_attr_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_attr_str"),
                orig_vtable->set_attr_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "set_attr_keyed"),
                orig_vtable->set_attr_keyed);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "add_parent"),
                orig_vtable->add_parent);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "remove_parent"),
                orig_vtable->remove_parent);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "add_role"),
                orig_vtable->add_role);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "remove_role"),
                orig_vtable->remove_role);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "add_attribute"),
                orig_vtable->add_attribute);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "remove_attribute"),
                orig_vtable->remove_attribute);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "add_method"),
                orig_vtable->add_method);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "remove_method"),
                orig_vtable->remove_method);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "add_vtable_override"),
                orig_vtable->add_vtable_override);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "remove_vtable_override"),
                orig_vtable->remove_vtable_override);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "inspect_str"),
                orig_vtable->inspect_str);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "freeze"),
                orig_vtable->freeze);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "thaw"),
                orig_vtable->thaw);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "thawfinish"),
                orig_vtable->thawfinish);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "visit"),
                orig_vtable->visit);
     parrot_hash_put(interp, orig, CONST_STRING(interp, "init_int"),
                orig_vtable->init_int);


    /* Build mappings for name -> instrumented function.vtable entry. */
    parrot_hash_put(interp, instr, CONST_STRING(interp, "init_pmc"),
                &(instr_vtable->init_pmc));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "instantiate"),
                &(instr_vtable->instantiate));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "morph"),
                &(instr_vtable->morph));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "getprop"),
                &(instr_vtable->getprop));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "setprop"),
                &(instr_vtable->setprop));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "delprop"),
                &(instr_vtable->delprop));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "clone_pmc"),
                &(instr_vtable->clone_pmc));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "find_method"),
                &(instr_vtable->find_method));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_integer_keyed"),
                &(instr_vtable->get_integer_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_integer_keyed_int"),
                &(instr_vtable->get_integer_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_integer_keyed_str"),
                &(instr_vtable->get_integer_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_number_keyed"),
                &(instr_vtable->get_number_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_number_keyed_int"),
                &(instr_vtable->get_number_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_number_keyed_str"),
                &(instr_vtable->get_number_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_string_keyed"),
                &(instr_vtable->get_string_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_string_keyed_int"),
                &(instr_vtable->get_string_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_string_keyed_str"),
                &(instr_vtable->get_string_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pmc_keyed"),
                &(instr_vtable->get_pmc_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pmc_keyed_int"),
                &(instr_vtable->get_pmc_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pmc_keyed_str"),
                &(instr_vtable->get_pmc_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pointer_keyed"),
                &(instr_vtable->get_pointer_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pointer_keyed_int"),
                &(instr_vtable->get_pointer_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_pointer_keyed_str"),
                &(instr_vtable->get_pointer_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_integer_native"),
                &(instr_vtable->set_integer_native));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_integer_keyed"),
                &(instr_vtable->set_integer_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_integer_keyed_int"),
                &(instr_vtable->set_integer_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_integer_keyed_str"),
                &(instr_vtable->set_integer_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_number_native"),
                &(instr_vtable->set_number_native));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_number_keyed"),
                &(instr_vtable->set_number_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_number_keyed_int"),
                &(instr_vtable->set_number_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_number_keyed_str"),
                &(instr_vtable->set_number_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_string_native"),
                &(instr_vtable->set_string_native));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "assign_string_native"),
                &(instr_vtable->assign_string_native));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_string_keyed"),
                &(instr_vtable->set_string_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_string_keyed_int"),
                &(instr_vtable->set_string_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_string_keyed_str"),
                &(instr_vtable->set_string_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_bool"),
                &(instr_vtable->set_bool));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pmc"),
                &(instr_vtable->set_pmc));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "assign_pmc"),
                &(instr_vtable->assign_pmc));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pmc_keyed"),
                &(instr_vtable->set_pmc_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pmc_keyed_int"),
                &(instr_vtable->set_pmc_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pmc_keyed_str"),
                &(instr_vtable->set_pmc_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pointer"),
                &(instr_vtable->set_pointer));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pointer_keyed"),
                &(instr_vtable->set_pointer_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pointer_keyed_int"),
                &(instr_vtable->set_pointer_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_pointer_keyed_str"),
                &(instr_vtable->set_pointer_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "push_integer"),
                &(instr_vtable->push_integer));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "push_float"),
                &(instr_vtable->push_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "push_string"),
                &(instr_vtable->push_string));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "push_pmc"),
                &(instr_vtable->push_pmc));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "unshift_integer"),
                &(instr_vtable->unshift_integer));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "unshift_float"),
                &(instr_vtable->unshift_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "unshift_string"),
                &(instr_vtable->unshift_string));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "unshift_pmc"),
                &(instr_vtable->unshift_pmc));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "splice"),
                &(instr_vtable->splice));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "add"),
                &(instr_vtable->add));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "add_int"),
                &(instr_vtable->add_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "add_float"),
                &(instr_vtable->add_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_add"),
                &(instr_vtable->i_add));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_add_int"),
                &(instr_vtable->i_add_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_add_float"),
                &(instr_vtable->i_add_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "subtract"),
                &(instr_vtable->subtract));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "subtract_int"),
                &(instr_vtable->subtract_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "subtract_float"),
                &(instr_vtable->subtract_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_subtract"),
                &(instr_vtable->i_subtract));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_subtract_int"),
                &(instr_vtable->i_subtract_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_subtract_float"),
                &(instr_vtable->i_subtract_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "multiply"),
                &(instr_vtable->multiply));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "multiply_int"),
                &(instr_vtable->multiply_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "multiply_float"),
                &(instr_vtable->multiply_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_multiply"),
                &(instr_vtable->i_multiply));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_multiply_int"),
                &(instr_vtable->i_multiply_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_multiply_float"),
                &(instr_vtable->i_multiply_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "divide"),
                &(instr_vtable->divide));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "divide_int"),
                &(instr_vtable->divide_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "divide_float"),
                &(instr_vtable->divide_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_divide"),
                &(instr_vtable->i_divide));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_divide_int"),
                &(instr_vtable->i_divide_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_divide_float"),
                &(instr_vtable->i_divide_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "floor_divide"),
                &(instr_vtable->floor_divide));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "floor_divide_int"),
                &(instr_vtable->floor_divide_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "floor_divide_float"),
                &(instr_vtable->floor_divide_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_floor_divide"),
                &(instr_vtable->i_floor_divide));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_floor_divide_int"),
                &(instr_vtable->i_floor_divide_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_floor_divide_float"),
                &(instr_vtable->i_floor_divide_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "modulus"),
                &(instr_vtable->modulus));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "modulus_int"),
                &(instr_vtable->modulus_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "modulus_float"),
                &(instr_vtable->modulus_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_modulus"),
                &(instr_vtable->i_modulus));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_modulus_int"),
                &(instr_vtable->i_modulus_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_modulus_float"),
                &(instr_vtable->i_modulus_float));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "absolute"),
                &(instr_vtable->absolute));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "neg"),
                &(instr_vtable->neg));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "is_equal"),
                &(instr_vtable->is_equal));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "is_equal_num"),
                &(instr_vtable->is_equal_num));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "is_equal_string"),
                &(instr_vtable->is_equal_string));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "is_same"),
                &(instr_vtable->is_same));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "cmp"),
                &(instr_vtable->cmp));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "cmp_num"),
                &(instr_vtable->cmp_num));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "cmp_string"),
                &(instr_vtable->cmp_string));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "cmp_pmc"),
                &(instr_vtable->cmp_pmc));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "logical_or"),
                &(instr_vtable->logical_or));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "logical_and"),
                &(instr_vtable->logical_and));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "logical_xor"),
                &(instr_vtable->logical_xor));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "logical_not"),
                &(instr_vtable->logical_not));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "concatenate"),
                &(instr_vtable->concatenate));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "concatenate_str"),
                &(instr_vtable->concatenate_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_concatenate"),
                &(instr_vtable->i_concatenate));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_concatenate_str"),
                &(instr_vtable->i_concatenate_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "repeat"),
                &(instr_vtable->repeat));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "repeat_int"),
                &(instr_vtable->repeat_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_repeat"),
                &(instr_vtable->i_repeat));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "i_repeat_int"),
                &(instr_vtable->i_repeat_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "substr"),
                &(instr_vtable->substr));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "substr_str"),
                &(instr_vtable->substr_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "exists_keyed"),
                &(instr_vtable->exists_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "exists_keyed_int"),
                &(instr_vtable->exists_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "exists_keyed_str"),
                &(instr_vtable->exists_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "defined_keyed"),
                &(instr_vtable->defined_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "defined_keyed_int"),
                &(instr_vtable->defined_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "defined_keyed_str"),
                &(instr_vtable->defined_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "delete_keyed"),
                &(instr_vtable->delete_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "delete_keyed_int"),
                &(instr_vtable->delete_keyed_int));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "delete_keyed_str"),
                &(instr_vtable->delete_keyed_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "invoke"),
                &(instr_vtable->invoke));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "can"),
                &(instr_vtable->can));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "does_pmc"),
                &(instr_vtable->does_pmc));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "does"),
                &(instr_vtable->does));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "isa_pmc"),
                &(instr_vtable->isa_pmc));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "isa"),
                &(instr_vtable->isa));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_attr_str"),
                &(instr_vtable->get_attr_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "get_attr_keyed"),
                &(instr_vtable->get_attr_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_attr_str"),
                &(instr_vtable->set_attr_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "set_attr_keyed"),
                &(instr_vtable->set_attr_keyed));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "add_parent"),
                &(instr_vtable->add_parent));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "remove_parent"),
                &(instr_vtable->remove_parent));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "add_role"),
                &(instr_vtable->add_role));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "remove_role"),
                &(instr_vtable->remove_role));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "add_attribute"),
                &(instr_vtable->add_attribute));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "remove_attribute"),
                &(instr_vtable->remove_attribute));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "add_method"),
                &(instr_vtable->add_method));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "remove_method"),
                &(instr_vtable->remove_method));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "add_vtable_override"),
                &(instr_vtable->add_vtable_override));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "remove_vtable_override"),
                &(instr_vtable->remove_vtable_override));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "inspect_str"),
                &(instr_vtable->inspect_str));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "freeze"),
                &(instr_vtable->freeze));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "thaw"),
                &(instr_vtable->thaw));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "thawfinish"),
                &(instr_vtable->thawfinish));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "visit"),
                &(instr_vtable->visit));
     parrot_hash_put(interp, instr, CONST_STRING(interp, "init_int"),
                &(instr_vtable->init_int));


    /* Build mappings for name -> stub_function if it wasn't done already. */
    if (parrot_hash_size(interp, stub) == 0) {
        parrot_hash_put(interp, stub, CONST_STRING(interp, "init_pmc"),
                        stub_init_pmc);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "instantiate"),
                        stub_instantiate);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "morph"),
                        stub_morph);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "getprop"),
                        stub_getprop);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "setprop"),
                        stub_setprop);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "delprop"),
                        stub_delprop);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "clone_pmc"),
                        stub_clone_pmc);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "find_method"),
                        stub_find_method);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_integer_keyed"),
                        stub_get_integer_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_integer_keyed_int"),
                        stub_get_integer_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_integer_keyed_str"),
                        stub_get_integer_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_number_keyed"),
                        stub_get_number_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_number_keyed_int"),
                        stub_get_number_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_number_keyed_str"),
                        stub_get_number_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_string_keyed"),
                        stub_get_string_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_string_keyed_int"),
                        stub_get_string_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_string_keyed_str"),
                        stub_get_string_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pmc_keyed"),
                        stub_get_pmc_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pmc_keyed_int"),
                        stub_get_pmc_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pmc_keyed_str"),
                        stub_get_pmc_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pointer_keyed"),
                        stub_get_pointer_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pointer_keyed_int"),
                        stub_get_pointer_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_pointer_keyed_str"),
                        stub_get_pointer_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_integer_native"),
                        stub_set_integer_native);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_integer_keyed"),
                        stub_set_integer_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_integer_keyed_int"),
                        stub_set_integer_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_integer_keyed_str"),
                        stub_set_integer_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_number_native"),
                        stub_set_number_native);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_number_keyed"),
                        stub_set_number_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_number_keyed_int"),
                        stub_set_number_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_number_keyed_str"),
                        stub_set_number_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_string_native"),
                        stub_set_string_native);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "assign_string_native"),
                        stub_assign_string_native);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_string_keyed"),
                        stub_set_string_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_string_keyed_int"),
                        stub_set_string_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_string_keyed_str"),
                        stub_set_string_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_bool"),
                        stub_set_bool);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pmc"),
                        stub_set_pmc);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "assign_pmc"),
                        stub_assign_pmc);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pmc_keyed"),
                        stub_set_pmc_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pmc_keyed_int"),
                        stub_set_pmc_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pmc_keyed_str"),
                        stub_set_pmc_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pointer"),
                        stub_set_pointer);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pointer_keyed"),
                        stub_set_pointer_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pointer_keyed_int"),
                        stub_set_pointer_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_pointer_keyed_str"),
                        stub_set_pointer_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "push_integer"),
                        stub_push_integer);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "push_float"),
                        stub_push_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "push_string"),
                        stub_push_string);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "push_pmc"),
                        stub_push_pmc);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "unshift_integer"),
                        stub_unshift_integer);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "unshift_float"),
                        stub_unshift_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "unshift_string"),
                        stub_unshift_string);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "unshift_pmc"),
                        stub_unshift_pmc);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "splice"),
                        stub_splice);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "add"),
                        stub_add);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "add_int"),
                        stub_add_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "add_float"),
                        stub_add_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_add"),
                        stub_i_add);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_add_int"),
                        stub_i_add_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_add_float"),
                        stub_i_add_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "subtract"),
                        stub_subtract);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "subtract_int"),
                        stub_subtract_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "subtract_float"),
                        stub_subtract_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_subtract"),
                        stub_i_subtract);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_subtract_int"),
                        stub_i_subtract_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_subtract_float"),
                        stub_i_subtract_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "multiply"),
                        stub_multiply);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "multiply_int"),
                        stub_multiply_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "multiply_float"),
                        stub_multiply_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_multiply"),
                        stub_i_multiply);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_multiply_int"),
                        stub_i_multiply_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_multiply_float"),
                        stub_i_multiply_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "divide"),
                        stub_divide);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "divide_int"),
                        stub_divide_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "divide_float"),
                        stub_divide_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_divide"),
                        stub_i_divide);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_divide_int"),
                        stub_i_divide_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_divide_float"),
                        stub_i_divide_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "floor_divide"),
                        stub_floor_divide);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "floor_divide_int"),
                        stub_floor_divide_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "floor_divide_float"),
                        stub_floor_divide_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_floor_divide"),
                        stub_i_floor_divide);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_floor_divide_int"),
                        stub_i_floor_divide_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_floor_divide_float"),
                        stub_i_floor_divide_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "modulus"),
                        stub_modulus);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "modulus_int"),
                        stub_modulus_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "modulus_float"),
                        stub_modulus_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_modulus"),
                        stub_i_modulus);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_modulus_int"),
                        stub_i_modulus_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_modulus_float"),
                        stub_i_modulus_float);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "absolute"),
                        stub_absolute);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "neg"),
                        stub_neg);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "is_equal"),
                        stub_is_equal);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "is_equal_num"),
                        stub_is_equal_num);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "is_equal_string"),
                        stub_is_equal_string);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "is_same"),
                        stub_is_same);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "cmp"),
                        stub_cmp);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "cmp_num"),
                        stub_cmp_num);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "cmp_string"),
                        stub_cmp_string);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "cmp_pmc"),
                        stub_cmp_pmc);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "logical_or"),
                        stub_logical_or);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "logical_and"),
                        stub_logical_and);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "logical_xor"),
                        stub_logical_xor);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "logical_not"),
                        stub_logical_not);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "concatenate"),
                        stub_concatenate);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "concatenate_str"),
                        stub_concatenate_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_concatenate"),
                        stub_i_concatenate);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_concatenate_str"),
                        stub_i_concatenate_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "repeat"),
                        stub_repeat);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "repeat_int"),
                        stub_repeat_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_repeat"),
                        stub_i_repeat);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "i_repeat_int"),
                        stub_i_repeat_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "substr"),
                        stub_substr);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "substr_str"),
                        stub_substr_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "exists_keyed"),
                        stub_exists_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "exists_keyed_int"),
                        stub_exists_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "exists_keyed_str"),
                        stub_exists_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "defined_keyed"),
                        stub_defined_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "defined_keyed_int"),
                        stub_defined_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "defined_keyed_str"),
                        stub_defined_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "delete_keyed"),
                        stub_delete_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "delete_keyed_int"),
                        stub_delete_keyed_int);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "delete_keyed_str"),
                        stub_delete_keyed_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "invoke"),
                        stub_invoke);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "can"),
                        stub_can);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "does_pmc"),
                        stub_does_pmc);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "does"),
                        stub_does);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "isa_pmc"),
                        stub_isa_pmc);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "isa"),
                        stub_isa);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_attr_str"),
                        stub_get_attr_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "get_attr_keyed"),
                        stub_get_attr_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_attr_str"),
                        stub_set_attr_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "set_attr_keyed"),
                        stub_set_attr_keyed);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "add_parent"),
                        stub_add_parent);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "remove_parent"),
                        stub_remove_parent);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "add_role"),
                        stub_add_role);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "remove_role"),
                        stub_remove_role);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "add_attribute"),
                        stub_add_attribute);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "remove_attribute"),
                        stub_remove_attribute);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "add_method"),
                        stub_add_method);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "remove_method"),
                        stub_remove_method);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "add_vtable_override"),
                        stub_add_vtable_override);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "remove_vtable_override"),
                        stub_remove_vtable_override);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "inspect_str"),
                        stub_inspect_str);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "freeze"),
                        stub_freeze);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "thaw"),
                        stub_thaw);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "thawfinish"),
                        stub_thawfinish);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "visit"),
                        stub_visit);
         parrot_hash_put(interp, stub, CONST_STRING(interp, "init_int"),
                        stub_init_int);

    }

    /* END vtable mappings */
}

/*
 * Stubs
 */

/* BEGIN vtable stubs */
static
void stub_init_pmc(PARROT_INTERP, PMC* pmc, PMC* initializer) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->init_pmc(interp, pmc, initializer);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, initializer);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "init_pmc"));


    return;
}

static
PMC* stub_instantiate(PARROT_INTERP, PMC* pmc, PMC* sig) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->instantiate(interp, pmc, sig);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, sig);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "instantiate"));


    return ret;
}

static
void stub_morph(PARROT_INTERP, PMC* pmc, PMC* type) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->morph(interp, pmc, type);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, type);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "morph"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "morph"));


    return;
}

static
PMC* stub_getprop(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->getprop(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "getprop"));


    return ret;
}

static
void stub_setprop(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->setprop(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "setprop"));


    return;
}

static
void stub_delprop(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->delprop(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "delprop"));


    return;
}

static
PMC* stub_clone_pmc(PARROT_INTERP, PMC* pmc, PMC* args) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->clone_pmc(interp, pmc, args);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, args);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "clone_pmc"));


    return ret;
}

static
PMC* stub_find_method(PARROT_INTERP, PMC* pmc, STRING* method_name) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->find_method(interp, pmc, method_name);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, method_name);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "core"),
                   CONST_STRING(supervisor, "find_method"));


    return ret;
}

static
INTVAL stub_get_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_integer_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_integer_keyed"));


    return ret;
}

static
INTVAL stub_get_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_integer_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_integer_keyed_int"));


    return ret;
}

static
INTVAL stub_get_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_integer_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_integer_keyed_str"));


    return ret;
}

static
FLOATVAL stub_get_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_number_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_number_keyed"));


    return ret;
}

static
FLOATVAL stub_get_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_number_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_number_keyed_int"));


    return ret;
}

static
FLOATVAL stub_get_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    FLOATVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_number_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_number_keyed_str"));


    return ret;
}

static
STRING* stub_get_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_string_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_string_keyed"));


    return ret;
}

static
STRING* stub_get_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_string_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_string_keyed_int"));


    return ret;
}

static
STRING* stub_get_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_string_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_string_keyed_str"));


    return ret;
}

static
PMC* stub_get_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pmc_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pmc_keyed"));


    return ret;
}

static
PMC* stub_get_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pmc_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pmc_keyed_int"));


    return ret;
}

static
PMC* stub_get_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pmc_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pmc_keyed_str"));


    return ret;
}

static
void* stub_get_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    void* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pointer_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pointer_keyed"));


    return ret;
}

static
void* stub_get_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    void* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pointer_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pointer_keyed_int"));


    return ret;
}

static
void* stub_get_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    void* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_pointer_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "get_pointer_keyed_str"));


    return ret;
}

static
void stub_set_integer_native(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_integer_native(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_integer_native"));


    return;
}

static
void stub_set_integer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_integer_keyed(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_integer_keyed"));


    return;
}

static
void stub_set_integer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_integer_keyed_int(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_integer_keyed_int"));


    return;
}

static
void stub_set_integer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_integer_keyed_str(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_integer_keyed_str"));


    return;
}

static
void stub_set_number_native(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_number_native(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_number_native"));


    return;
}

static
void stub_set_number_keyed(PARROT_INTERP, PMC* pmc, PMC* key, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_number_keyed(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_number_keyed"));


    return;
}

static
void stub_set_number_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_number_keyed_int(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_number_keyed_int"));


    return;
}

static
void stub_set_number_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_number_keyed_str(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_number_keyed_str"));


    return;
}

static
void stub_set_string_native(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_string_native(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_string_native"));


    return;
}

static
void stub_assign_string_native(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->assign_string_native(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "assign_string_native"));


    return;
}

static
void stub_set_string_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_string_keyed(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_string_keyed"));


    return;
}

static
void stub_set_string_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_string_keyed_int(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_string_keyed_int"));


    return;
}

static
void stub_set_string_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_string_keyed_str(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_string_keyed_str"));


    return;
}

static
void stub_set_bool(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_bool(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_bool"));


    return;
}

static
void stub_set_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pmc(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pmc"));


    return;
}

static
void stub_assign_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->assign_pmc(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "assign_pmc"));


    return;
}

static
void stub_set_pmc_keyed(PARROT_INTERP, PMC* pmc, PMC* key, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pmc_keyed(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pmc_keyed"));


    return;
}

static
void stub_set_pmc_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pmc_keyed_int(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pmc_keyed_int"));


    return;
}

static
void stub_set_pmc_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pmc_keyed_str(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pmc_keyed_str"));


    return;
}

static
void stub_set_pointer(PARROT_INTERP, PMC* pmc, void* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pointer(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pointer"));


    return;
}

static
void stub_set_pointer_keyed(PARROT_INTERP, PMC* pmc, PMC* key, void* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pointer_keyed(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pointer_keyed"));


    return;
}

static
void stub_set_pointer_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key, void* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pointer_keyed_int(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pointer_keyed_int"));


    return;
}

static
void stub_set_pointer_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key, void* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_pointer_keyed_str(interp, pmc, key, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetch"),
                   CONST_STRING(supervisor, "set_pointer_keyed_str"));


    return;
}

static
void stub_push_integer(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->push_integer(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "push_integer"));


    return;
}

static
void stub_push_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->push_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "push_float"));


    return;
}

static
void stub_push_string(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->push_string(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "push_string"));


    return;
}

static
void stub_push_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->push_pmc(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "push_pmc"));


    return;
}

static
void stub_unshift_integer(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->unshift_integer(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "unshift_integer"));


    return;
}

static
void stub_unshift_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->unshift_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "unshift_float"));


    return;
}

static
void stub_unshift_string(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->unshift_string(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "unshift_string"));


    return;
}

static
void stub_unshift_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->unshift_pmc(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "unshift_pmc"));


    return;
}

static
void stub_splice(PARROT_INTERP, PMC* pmc, PMC* value, INTVAL offset, INTVAL count) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->splice(interp, pmc, value, offset, count);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, offset);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, count);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "fetchsize"),
                   CONST_STRING(supervisor, "splice"));


    return;
}

static
PMC* stub_add(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->add(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "add"));


    return ret;
}

static
PMC* stub_add_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->add_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "add_int"));


    return ret;
}

static
PMC* stub_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->add_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "add_float"));


    return ret;
}

static
void stub_i_add(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_add(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_add"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_add"));


    return;
}

static
void stub_i_add_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_add_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_add_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_add_int"));


    return;
}

static
void stub_i_add_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_add_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_add_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_add_float"));


    return;
}

static
PMC* stub_subtract(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->subtract(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "subtract"));


    return ret;
}

static
PMC* stub_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->subtract_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "subtract_int"));


    return ret;
}

static
PMC* stub_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->subtract_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "subtract_float"));


    return ret;
}

static
void stub_i_subtract(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_subtract(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_subtract"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_subtract"));


    return;
}

static
void stub_i_subtract_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_subtract_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_subtract_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_subtract_int"));


    return;
}

static
void stub_i_subtract_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_subtract_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_subtract_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_subtract_float"));


    return;
}

static
PMC* stub_multiply(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->multiply(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "multiply"));


    return ret;
}

static
PMC* stub_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->multiply_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "multiply_int"));


    return ret;
}

static
PMC* stub_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->multiply_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "multiply_float"));


    return ret;
}

static
void stub_i_multiply(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_multiply(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_multiply"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_multiply"));


    return;
}

static
void stub_i_multiply_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_multiply_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_multiply_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_multiply_int"));


    return;
}

static
void stub_i_multiply_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_multiply_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_multiply_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_multiply_float"));


    return;
}

static
PMC* stub_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->divide(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "divide"));


    return ret;
}

static
PMC* stub_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->divide_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "divide_int"));


    return ret;
}

static
PMC* stub_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->divide_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "divide_float"));


    return ret;
}

static
void stub_i_divide(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_divide(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_divide"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_divide"));


    return;
}

static
void stub_i_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_divide_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_divide_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_divide_int"));


    return;
}

static
void stub_i_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_divide_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_divide_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_divide_float"));


    return;
}

static
PMC* stub_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->floor_divide(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "floor_divide"));


    return ret;
}

static
PMC* stub_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->floor_divide_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "floor_divide_int"));


    return ret;
}

static
PMC* stub_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->floor_divide_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "floor_divide_float"));


    return ret;
}

static
void stub_i_floor_divide(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_floor_divide(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_floor_divide"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_floor_divide"));


    return;
}

static
void stub_i_floor_divide_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_floor_divide_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_floor_divide_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_floor_divide_int"));


    return;
}

static
void stub_i_floor_divide_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_floor_divide_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_floor_divide_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_floor_divide_float"));


    return;
}

static
PMC* stub_modulus(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->modulus(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "modulus"));


    return ret;
}

static
PMC* stub_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->modulus_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "modulus_int"));


    return ret;
}

static
PMC* stub_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->modulus_float(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "modulus_float"));


    return ret;
}

static
void stub_i_modulus(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_modulus(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_modulus"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_modulus"));


    return;
}

static
void stub_i_modulus_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_modulus_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_modulus_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_modulus_int"));


    return;
}

static
void stub_i_modulus_float(PARROT_INTERP, PMC* pmc, FLOATVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_modulus_float(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Float);
    VTABLE_set_number_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "i_modulus_float"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_modulus_float"));


    return;
}

static
PMC* stub_absolute(PARROT_INTERP, PMC* pmc, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->absolute(interp, pmc, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "absolute"));


    return ret;
}

static
PMC* stub_neg(PARROT_INTERP, PMC* pmc, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->neg(interp, pmc, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "math"),
                   CONST_STRING(supervisor, "neg"));


    return ret;
}

static
INTVAL stub_is_equal(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->is_equal(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "is_equal"));


    return ret;
}

static
INTVAL stub_is_equal_num(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->is_equal_num(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "is_equal_num"));


    return ret;
}

static
INTVAL stub_is_equal_string(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->is_equal_string(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "is_equal_string"));


    return ret;
}

static
INTVAL stub_is_same(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->is_same(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "is_same"));


    return ret;
}

static
INTVAL stub_cmp(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->cmp(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "cmp"));


    return ret;
}

static
INTVAL stub_cmp_num(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->cmp_num(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "cmp_num"));


    return ret;
}

static
INTVAL stub_cmp_string(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->cmp_string(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "cmp_string"));


    return ret;
}

static
PMC* stub_cmp_pmc(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->cmp_pmc(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "cmp_pmc"));


    return ret;
}

static
PMC* stub_logical_or(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->logical_or(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "logical_or"));


    return ret;
}

static
PMC* stub_logical_and(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->logical_and(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "logical_and"));


    return ret;
}

static
PMC* stub_logical_xor(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->logical_xor(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "logical_xor"));


    return ret;
}

static
PMC* stub_logical_not(PARROT_INTERP, PMC* pmc, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->logical_not(interp, pmc, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "cmp"),
                   CONST_STRING(supervisor, "logical_not"));


    return ret;
}

static
PMC* stub_concatenate(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->concatenate(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "concatenate"));


    return ret;
}

static
PMC* stub_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->concatenate_str(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "concatenate_str"));


    return ret;
}

static
void stub_i_concatenate(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_concatenate(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "i_concatenate"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_concatenate"));


    return;
}

static
void stub_i_concatenate_str(PARROT_INTERP, PMC* pmc, STRING* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_concatenate_str(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "i_concatenate_str"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_concatenate_str"));


    return;
}

static
PMC* stub_repeat(PARROT_INTERP, PMC* pmc, PMC* value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->repeat(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "repeat"));


    return ret;
}

static
PMC* stub_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->repeat_int(interp, pmc, value, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "repeat_int"));


    return ret;
}

static
void stub_i_repeat(PARROT_INTERP, PMC* pmc, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_repeat(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "i_repeat"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_repeat"));


    return;
}

static
void stub_i_repeat_int(PARROT_INTERP, PMC* pmc, INTVAL value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->i_repeat_int(interp, pmc, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, value);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "i_repeat_int"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "i_repeat_int"));


    return;
}

static
void stub_substr(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length, PMC* dest) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->substr(interp, pmc, offset, length, dest);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, offset);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, length);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, dest);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "substr"));


    return;
}

static
STRING* stub_substr_str(PARROT_INTERP, PMC* pmc, INTVAL offset, INTVAL length) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    STRING* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->substr_str(interp, pmc, offset, length);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, offset);
    VTABLE_push_pmc(supervisor, params, temp);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, length);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "string"),
                   CONST_STRING(supervisor, "substr_str"));


    return ret;
}

static
INTVAL stub_exists_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->exists_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "exists"),
                   CONST_STRING(supervisor, "exists_keyed"));


    return ret;
}

static
INTVAL stub_exists_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->exists_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "exists"),
                   CONST_STRING(supervisor, "exists_keyed_int"));


    return ret;
}

static
INTVAL stub_exists_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->exists_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "exists"),
                   CONST_STRING(supervisor, "exists_keyed_str"));


    return ret;
}

static
INTVAL stub_defined_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->defined_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "defined_keyed"));


    return ret;
}

static
INTVAL stub_defined_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->defined_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "defined_keyed_int"));


    return ret;
}

static
INTVAL stub_defined_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->defined_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "defined_keyed_str"));


    return ret;
}

static
void stub_delete_keyed(PARROT_INTERP, PMC* pmc, PMC* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->delete_keyed(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "delete_keyed"));


    return;
}

static
void stub_delete_keyed_int(PARROT_INTERP, PMC* pmc, INTVAL key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->delete_keyed_int(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "delete_keyed_int"));


    return;
}

static
void stub_delete_keyed_str(PARROT_INTERP, PMC* pmc, STRING* key) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->delete_keyed_str(interp, pmc, key);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, key);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "delete_keyed_str"));


    return;
}

static
opcode_t* stub_invoke(PARROT_INTERP, PMC* pmc, void* next) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    opcode_t* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->invoke(interp, pmc, next);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, next);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "invoke"));


    return ret;
}

static
INTVAL stub_can(PARROT_INTERP, PMC* pmc, STRING* method) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->can(interp, pmc, method);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, method);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "can"));


    return ret;
}

static
INTVAL stub_does_pmc(PARROT_INTERP, PMC* pmc, PMC* role) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->does_pmc(interp, pmc, role);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, role);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "does_pmc"));


    return ret;
}

static
INTVAL stub_does(PARROT_INTERP, PMC* pmc, STRING* role) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->does(interp, pmc, role);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, role);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "does"));


    return ret;
}

static
INTVAL stub_isa_pmc(PARROT_INTERP, PMC* pmc, PMC* _class) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->isa_pmc(interp, pmc, _class);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, _class);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "isa_pmc"));


    return ret;
}

static
INTVAL stub_isa(PARROT_INTERP, PMC* pmc, STRING* _class) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    INTVAL ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->isa(interp, pmc, _class);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, _class);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "isa"));


    return ret;
}

static
PMC* stub_get_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_attr_str(interp, pmc, idx);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, idx);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "get_attr_str"));


    return ret;
}

static
PMC* stub_get_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->get_attr_keyed(interp, pmc, key, idx);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, idx);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "get_attr_keyed"));


    return ret;
}

static
void stub_set_attr_str(PARROT_INTERP, PMC* pmc, STRING* idx, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_attr_str(interp, pmc, idx, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, idx);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "set_attr_str"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "set_attr_str"));


    return;
}

static
void stub_set_attr_keyed(PARROT_INTERP, PMC* pmc, PMC* key, STRING* idx, PMC* value) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->set_attr_keyed(interp, pmc, key, idx, value);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, key);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, idx);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, value);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "set_attr_keyed"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "set_attr_keyed"));


    return;
}

static
void stub_add_parent(PARROT_INTERP, PMC* pmc, PMC* parent) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->add_parent(interp, pmc, parent);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, parent);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "add_parent"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "add_parent"));


    return;
}

static
void stub_remove_parent(PARROT_INTERP, PMC* pmc, PMC* parent) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->remove_parent(interp, pmc, parent);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, parent);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "remove_parent"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "remove_parent"));


    return;
}

static
void stub_add_role(PARROT_INTERP, PMC* pmc, PMC* role) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->add_role(interp, pmc, role);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, role);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "add_role"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "add_role"));


    return;
}

static
void stub_remove_role(PARROT_INTERP, PMC* pmc, PMC* role) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->remove_role(interp, pmc, role);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, role);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "remove_role"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "remove_role"));


    return;
}

static
void stub_add_attribute(PARROT_INTERP, PMC* pmc, STRING* name, PMC* type) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->add_attribute(interp, pmc, name, type);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, name);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, type);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "add_attribute"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "add_attribute"));


    return;
}

static
void stub_remove_attribute(PARROT_INTERP, PMC* pmc, STRING* name) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->remove_attribute(interp, pmc, name);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, name);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "remove_attribute"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "remove_attribute"));


    return;
}

static
void stub_add_method(PARROT_INTERP, PMC* pmc, STRING* method_name, PMC* sub_pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->add_method(interp, pmc, method_name, sub_pmc);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, method_name);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, sub_pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "add_method"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "add_method"));


    return;
}

static
void stub_remove_method(PARROT_INTERP, PMC* pmc, STRING* method_name) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->remove_method(interp, pmc, method_name);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, method_name);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "remove_method"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "remove_method"));


    return;
}

static
void stub_add_vtable_override(PARROT_INTERP, PMC* pmc, STRING* vtable_name, PMC* sub_pmc) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->add_vtable_override(interp, pmc, vtable_name, sub_pmc);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, vtable_name);
    VTABLE_push_pmc(supervisor, params, temp);
    VTABLE_push_pmc(supervisor, params, sub_pmc);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "add_vtable_override"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "add_vtable_override"));


    return;
}

static
void stub_remove_vtable_override(PARROT_INTERP, PMC* pmc, STRING* vtable_name) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->remove_vtable_override(interp, pmc, vtable_name);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, vtable_name);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "remove_vtable_override"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "remove_vtable_override"));


    return;
}

static
PMC* stub_inspect_str(PARROT_INTERP, PMC* pmc, STRING* what) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);
    PMC* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    ret = orig_vtable->inspect_str(interp, pmc, what);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_String);
    VTABLE_set_string_native(supervisor, temp, what);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "inspect_str"));


    return ret;
}

static
void stub_freeze(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->freeze(interp, pmc, info);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, info);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "freeze"));


    return;
}

static
void stub_thaw(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->thaw(interp, pmc, info);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, info);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "thaw"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "thaw"));


    return;
}

static
void stub_thawfinish(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->thawfinish(interp, pmc, info);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, info);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "thawfinish"));
    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "write"),
                   CONST_STRING(supervisor, "thawfinish"));


    return;
}

static
void stub_visit(PARROT_INTERP, PMC* pmc, PMC* info) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->visit(interp, pmc, info);

    VTABLE_push_pmc(supervisor, params, pmc);
    VTABLE_push_pmc(supervisor, params, info);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "visit"));


    return;
}

static
void stub_init_int(PARROT_INTERP, PMC* pmc, INTVAL initializer) {
    PMC *instr_vt, *data;
    _vtable *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params = Parrot_pmc_new(interp, enum_class_ResizablePMCArray);

    instr_vt = (PMC *) parrot_hash_get(interp, Instrument_Vtable_Entries, pmc->vtable);

    GETATTR_InstrumentVtable_original_vtable(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    orig_vtable->init_int(interp, pmc, initializer);

    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Integer);
    VTABLE_set_integer_native(supervisor, temp, initializer);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "init_int"));


    return;
}


/* END vtable stubs */

/*

=back

=head1 SEE ALSO

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
