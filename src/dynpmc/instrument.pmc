/*
Copyright (C) 2010, Parrot Foundation.
$Id$

=head1 NAME

src/dynpmc/instrument.pmc - Interface to hook into a child interpreter.

=head1 DESCRIPTION

C<Instrument> is a PMC class that allows dynamic execution introspection
to be done on a child interpreter.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/imcc.h"
#include "parrot/runcore_api.h"
#include "parrot/embed.h"
#include "parrot/opsenum.h"

/*
 * Structures for the linked list data type.
 * TODO: Await merge to trunk of bacek's list. Then we use that instead.
 */

typedef struct probe_node_t {
    struct probe_node_t *next, *prev;
    PMC                 *list_obj;
} probe_node_t;

typedef struct probe_list_t {
    probe_node_t *head, *tail;
} probe_list_t;

/*
 * Extend the runcore_t struct to include a reference
 *  to the supervisor interpreter.
 */

typedef struct Instrument_runcore_t {
    STRING                  *name;
    int                      id;
    oplib_init_f             opinit;
    runcore_runops_fn_type   runops;
    runcore_destroy_fn_type  destroy;
    runcore_prepare_fn_type  prepare_run;
    INTVAL                   flags;

    /* End of common members */
    INTVAL                    has_ended;
    Parrot_Interp             supervisor_interp;
    PMC                      *supervisor_pmc;
    probe_list_t            **op_hooks;
    probe_list_t             *op_catchall;
    PMC                      *old_dynlibs;
    PMC                      *instr_op;
} Instrument_runcore_t;

/* Runcore Function Prototypes */
static void      Instrument_runcore_init(PARROT_INTERP, Parrot_Interp supervisor, PMC *instrument);
static opcode_t *Instrument_runcore_runops(PARROT_INTERP, Parrot_runcore_t *runcore, opcode_t *pc);
static void      Instrument_init_probes(Parrot_Interp supervisor, Parrot_Interp supervised);

/* Helper prototype */
static probe_list_t *Instrument_get_active_probes(opcode_t *pc, PARROT_INTERP);
static probe_list_t *Instrument_fire_probes(probe_list_t *list, opcode_t *pc, PARROT_INTERP);
static void          raise_dynlib_event(PARROT_INTERP, PMC *lib);

/* dynlib detection */
static void fixup_vtables(Parrot_Interp src, Parrot_Interp dest);
static void normalise_op_tables(Parrot_Interp src, Parrot_Interp dest);
static void detect_loadlib(PARROT_INTERP);

/* Linked List operations */
static probe_list_t *probe_list_create_list(PARROT_INTERP);
static probe_node_t *probe_list_create_node(PARROT_INTERP);
static void          probe_list_delete_list(PARROT_INTERP, probe_list_t *list);
static void          probe_list_delete_node(PARROT_INTERP, probe_node_t *node);
static void          probe_list_push(PARROT_INTERP, probe_list_t *list, PMC *item);
static PMC          *probe_list_pop(PARROT_INTERP, probe_list_t *list);
static PMC          *probe_list_remove(PARROT_INTERP, probe_list_t *list, probe_node_t *node);
static probe_node_t *probe_list_find(PARROT_INTERP, probe_list_t *list, PMC *val);

pmclass Instrument auto_attrs dynpmc provides hash group instrument_group {
    ATTR Parrot_Interp  supervised;     /* The interpreter running the code */
    ATTR PMC           *probes;         /* A list of probes registered. */
    ATTR PMC           *evt_dispatcher; /* Reference the the EventDispatcher object. */
    ATTR PMC           *instrument_gc;  /* Reference to the InstrumentGC object. */
    ATTR PMC           *instrument_classes; /* Registry to hold instances of InstrumentVtable. */

/*

=item C<void init()>

Initializes the pmc and creates a child interpreter.

=cut

*/

    VTABLE void init() {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        PMC *evt_key1, *evt_key2, *nothing, *supervised_pmc;
        INTVAL evt_class_type, gc_class_type;

        /* Obtain the class type of Instrument::EventDispatcher. */
        evt_key1 = key_new_cstring(INTERP, "Instrument");
        evt_key2 = key_new_cstring(INTERP, "EventDispatcher");
        key_append(INTERP, evt_key1, evt_key2);

        evt_class_type = Parrot_pmc_get_type(INTERP, evt_key1);

        /* Obtain the class type of InstrumentGC. */
        gc_class_type = Parrot_pmc_get_type_str(INTERP, CONST_STRING(INTERP, "InstrumentGC"));

        /* Initialise the attributes. */
        attr->supervised         = Parrot_new(INTERP);
        attr->probes             = Parrot_pmc_new(INTERP, enum_class_Hash);
        attr->evt_dispatcher     = Parrot_pmc_new(INTERP, evt_class_type);
        attr->instrument_classes = Parrot_pmc_new(INTERP, enum_class_Hash);

        /* Initialise the event dispatcher */
        (PMC *nothing) = PCCINVOKE(INTERP, attr->evt_dispatcher, "_self_init");

        /* Initialize the runcore for the child interpreter */
        Instrument_runcore_init(attr->supervised, INTERP, SELF);

        /* Initialize the scheduler for the child interpreter */
        attr->supervised->scheduler = Parrot_pmc_new(interp, enum_class_Scheduler);
        attr->supervised->scheduler = VTABLE_share_ro(interp, attr->supervised->scheduler);

        /* Prepare the child interpreter's op table for instrumentation */
        Instrument_init_probes(INTERP, attr->supervised);

        /* Prepare for GC instrumentation. */
        supervised_pmc       = VTABLE_get_pmc_keyed_int(attr->supervised,
                                                        attr->supervised->iglobals,
                                                        IGLOBALS_INTERPRETER);
        attr->instrument_gc  = Parrot_pmc_new_init(INTERP, gc_class_type, supervised_pmc);

        /* Set self to destroy manually */
        PObj_custom_mark_destroy_SETALL(SELF);
    }

/*

=item C<void destroy()>

Cleans up after the PMC.

=cut

*/

    VTABLE void destroy() {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        Instrument_runcore_t *core = (Instrument_runcore_t *) attr->supervised->run_core;
        UINTVAL i;

        /* Delete the linked list entries. */
        if (core->op_catchall != NULL) {
            probe_list_delete_list(INTERP, core->op_catchall);
        }
        if (core->op_hooks != NULL) {
            for (i = 0; i < attr->supervised->op_count; i++) {
                if (core->op_hooks[i] != NULL) {
                    probe_list_delete_list(INTERP, core->op_hooks[i]);
                }
            }

            mem_gc_free(INTERP, core->op_hooks);
        }

        /* Delete the supervised interpreter */
        Parrot_destroy(attr->supervised);
    }

/*

=item C<void mark()>

Marks internal data structures as live to the gc.

=cut

*/

    VTABLE void mark() {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        Instrument_runcore_t *core = (Instrument_runcore_t *) attr->supervised->run_core;

        /* Mark attributes as alive */
        Parrot_gc_mark_PMC_alive_fun(INTERP, attr->probes);
        Parrot_gc_mark_PMC_alive_fun(INTERP, attr->evt_dispatcher);
        Parrot_gc_mark_PMC_alive_fun(INTERP, attr->instrument_gc);
        Parrot_gc_mark_PMC_alive_fun(INTERP, core->old_dynlibs);
        Parrot_gc_mark_PMC_alive_fun(INTERP, core->instr_op);
        Parrot_gc_mark_PMC_alive_fun(INTERP, attr->instrument_classes);
    }

/*

=item C<void get_pmc_keyed(PMC *key)>

Get the property with the key.

Keys:
probes          : returns the hash of probes currently registered.
eventdispatcher : returns the event dispatcher instance.
gc              : returns the InstrumentGC instance.

Unknown keys are sent to the supervised interpreter.

=cut

*/

    VTABLE PMC *get_pmc_keyed(PMC *key) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        PMC *nextkey, *supervised_pmc;
        STRING *item = key_string(INTERP, key);
        STRING *name;

        /* probes: return the hash of probes */
        name = CONST_STRING(INTERP, "probes");
        if (Parrot_str_equal(INTERP, name, item)) {
            return attr->probes;
        }

        /* eventdispatcher: returns the event dispatcher instance */
        name = CONST_STRING(INTERP, "eventdispatcher");
        if (Parrot_str_equal(INTERP, name, item)) {
            return attr->evt_dispatcher;
        }

        /* gc: returns the InstrumentGC instance. */
        name = CONST_STRING(INTERP, "gc");
        if (Parrot_str_equal(INTERP, name, item)) {
            return attr->instrument_gc;
        }

        /* push to the supervised interpreter. */
        supervised_pmc = VTABLE_get_pmc_keyed_int(attr->supervised,
                                                  attr->supervised->iglobals,
                                                  (INTVAL) IGLOBALS_INTERPRETER);
        return VTABLE_get_pmc_keyed(INTERP, supervised_pmc, key);
    }

/*

=item C<void run(STRING file, PMC *args)>

Executes the given file, 'file', in the child interpreter,
passing the arguments in the form of the array 'args' to the
program in 'file'.

=cut

*/

    METHOD run(STRING file, PMC *args) {
        int argc = 0, status;
        char * default_argv[] = {NULL};
        char ** argv = default_argv;
        char * file_c;
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        PMC *probe_iter;
        int counter = 0;

        /* If args is not null, does array and has a size > 0, convert it
           into a cstring array to pass to imcc.
         */
        if (!Parrot_pmc_is_null(INTERP, args)
        &&   VTABLE_does(INTERP, args, CONST_STRING(INTERP, "array"))
        &&   VTABLE_get_integer(INTERP, args) > 0) {

            /* Get the number of argument values */
            int count = VTABLE_get_integer(INTERP, args);

            /* Allocate enough memory for the argv pointer array */
            argv = (char **) mem_gc_allocate_n_zeroed_typed(INTERP, count, char *);

            /* Populate the argv array, updating argc in the process */
            for (argc = 0; argc < count; argc++) {
                STRING *cur;

                cur = VTABLE_get_string_keyed_int(INTERP, args, argc);
                argv[argc] = Parrot_str_to_cstring(INTERP, cur);
            }
        }

        /* Fixup the vtables */
        fixup_vtables(INTERP, attr->supervised);

        /* Begin Execution */
        file_c = Parrot_str_to_cstring(attr->supervised, file);
        status = imcc_run(attr->supervised,
                    file_c,
                    argc, (const char **) argv);
        if (status) {
            imcc_run_pbc(attr->supervised,
                         attr->supervised->output_file,
                         argc, (const char **) argv);
        }
        Parrot_str_free_cstring(file_c);

        /* Finalize the instruments */
        probe_iter = VTABLE_get_iter(INTERP, attr->probes);
        while (VTABLE_get_bool(INTERP, probe_iter)) {
            PMC *key, *probe, *finalize_sub;

            /* For the current probe, get the finalize attribute. */
            key          = VTABLE_shift_pmc(INTERP, probe_iter);
            probe        = VTABLE_get_pmc_keyed(INTERP, attr->probes, key);
            finalize_sub = VTABLE_get_attr_str(INTERP, probe,
                                               CONST_STRING(INTERP, "$!finalize"));

            /* If it is set, call that sub. */
            if (!PMC_IS_NULL(finalize_sub)) {
                Parrot_ext_call(INTERP, finalize_sub, "->");
            }
        }

        /* We should free the cstrings allocated above if needed */
        if (argc > 0) {
            for (; argc > 0; argc--) {
                Parrot_str_free_cstring(argv[argc - 1]);
                argv[argc - 1] = NULL;
            }

            /* Free the memory allocated to hold the string pointers */
            mem_gc_free(INTERP, argv);
            argv = NULL;
        }
    }

/*

=item C<void attach(PMC *obj)>

With the passed in object, assume it is a class with the method 'enable'
and attribute 'instr_obj'. Set the '$!instr_obj' attribute to SELF and call the
'enable' method of the object for the object to commence attaching the hooks.

=cut

*/

    METHOD attach(PMC *obj) {
        PMC *enable_method, *id;
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);

        /* We do not care what type of object it is,
           as long as the object has the attributes $!instr_obj and $!identifier
           and the method enable. */

        /* Set the instrument reference attribute of the object,
           and call its enable method. */
        VTABLE_set_attr_str(INTERP, obj,
                            CONST_STRING(INTERP, "$!instr_obj"),
                            SELF);

        /* Find the enable method */
        enable_method = VTABLE_find_method(INTERP, obj, CONST_STRING(INTERP, "_on_attach"));
        if (PMC_IS_NULL(enable_method)) {
            /* Error! Could not find the enable method. */
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                        "Could not locate the method '_on_attach'.");
        }

        /* Call the method.
           The first parameter to a method is the object itself.
           The enable method will be calling insert_op_hook to register the hooks. */
        Parrot_ext_call(INTERP, enable_method, "P->", obj);

        /* Register the probe. */
        id = VTABLE_get_attr_str(INTERP, obj, CONST_STRING(INTERP, "$!identifier"));
        VTABLE_set_pmc_keyed(INTERP, attr->probes, id, obj);
    }

/*

=item C<void *insert_op_hooks(PMC *probe, INTVAL op_num)>

Insert a hook for the given op number.

=cut

*/

    METHOD insert_op_hook(PMC *probe, INTVAL op_num) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        Instrument_runcore_t *core = (Instrument_runcore_t *) attr->supervised->run_core;
        probe_list_t        **list = core->op_hooks;
        size_t               index = op_num;

        if (index >= attr->supervised->op_count) {
            /* Invalid op num */
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1, "Invalid op number %d.", index);
        }

        if (list[index] == NULL) {
            list[index] = probe_list_create_list(INTERP);
        }

        probe_list_push(INTERP, list[index], probe);
    }

/*

=item C<void *remove_op_hooks(PMC *probe, INTVAL op_num)>

Removes a hook for the given op number.

=cut

*/

    METHOD remove_op_hook(PMC *probe, INTVAL op_num) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        Instrument_runcore_t *core = (Instrument_runcore_t *) attr->supervised->run_core;
        probe_list_t        **list = core->op_hooks;
        probe_node_t         *node = NULL;
        size_t               index = op_num;

        if (index >= attr->supervised->op_count) {
            /* Invalid op num */
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1, "Invalid op number %d.", index);
        }

        if (list[index] != NULL) {
            node = probe_list_find(INTERP, list[index], probe);

            if (node != NULL) {
                probe_list_remove(INTERP, list[index], node);
            }
        }

        if (node == NULL) {
            /* Callback was not found. */
            PMC *id = VTABLE_get_attr_str(INTERP, probe, CONST_STRING(INTERP, "$!identifier"));
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                        "Probe '%Ss' not found in 'remove_op_hook'",
                                        VTABLE_get_string(INTERP, id));
        }
    }

/*
=item C<INTVAL count_op_hooks(INTVAL op_num)>

Returns the number of enabled op hooks for the given op number.

=cut
*/

    METHOD count_op_hooks(INTVAL op_num) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        Instrument_runcore_t *core = (Instrument_runcore_t *) attr->supervised->run_core;
        probe_list_t         *list = core->op_hooks[op_num];
        probe_node_t         *node = NULL;
        INTVAL               count = 0;

        node = (list != NULL) ? list->head : NULL;
        while (node != NULL) {
            count++;
            node = node->next;
        }

        RETURN(INTVAL count);
    }

/*
=item C<void *insert_op_catchall(PMC *probe)>

Register a catchall op callback

=cut
*/

    METHOD insert_op_catchall(PMC *probe) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        Instrument_runcore_t *core = (Instrument_runcore_t *) attr->supervised->run_core;
        probe_list_t  *list = core->op_catchall;

        probe_list_push(INTERP, list, probe);
    }

/*
=item C<void *remove_op_catchall(PMC *probe)>

Deregister a catchall op callback

=cut
*/

    METHOD remove_op_catchall(PMC *probe) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        Instrument_runcore_t *core = (Instrument_runcore_t *) attr->supervised->run_core;
        probe_list_t  *list = core->op_catchall;
        probe_node_t  *node = NULL;

        node = probe_list_find(INTERP, list, probe);

        if (node == NULL) {
            /* Callback was not found. */
            PMC *id = VTABLE_get_attr_str(INTERP, probe, CONST_STRING(INTERP, "$!identifier"));
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                        "Probe '%S' not found in 'remove_op_catchall'",
                                        VTABLE_get_string(INTERP, id));
        }

        probe_list_remove(INTERP, list, node);
    }

/*
=item C<INTVAL count_op_catchalls()>

Returns the number of enabled op catchall probes.

=cut
*/

    METHOD count_op_catchalls() {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        Instrument_runcore_t *core = (Instrument_runcore_t *) attr->supervised->run_core;
        probe_list_t         *list = core->op_catchall;
        probe_node_t         *node = NULL;
        INTVAL               count = 0;

        node = list->head;
        while (node != NULL) {
            count++;
            node = node->next;
        }

        RETURN(INTVAL count);
    }

/*
=item C<PMC* instrument_class(STRING *classname)>

Returns the InstrumentVtable instance associated with the given classname.
Creates a new InstrumentVtable instance if there is none currently associated.

=cut
*/

    METHOD instrument_class(STRING *classname) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        INTVAL  class_type;
        PMC    *class_instr;

        /* Lookup the classname in the InstrumentClass registry.
           If the entry doesn't exist, create an entry for it. */
        if (VTABLE_exists_keyed_str(INTERP, attr->instrument_classes, classname)) {
            class_instr = VTABLE_get_pmc_keyed_str(INTERP, attr->instrument_classes, classname);
        }
        else {
            class_type  = Parrot_pmc_get_type_str(INTERP, CONST_STRING(INTERP, "InstrumentClass"));
            class_instr = Parrot_pmc_new_init(INTERP, class_type, SELF);

            () = PCCINVOKE(INTERP, class_instr, "attach_to_class", STRING *classname);

            VTABLE_set_pmc_keyed_str(INTERP, attr->instrument_classes, classname, class_instr);
        }

        RETURN(PMC *class_instr);
    }

    METHOD instrument_object(PMC *classname) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        INTVAL  class_type;
        PMC    *class_instr;

        class_type  = Parrot_pmc_get_type_str(INTERP, CONST_STRING(INTERP, "InstrumentObject"));
        class_instr = Parrot_pmc_new_init(INTERP, class_type, SELF);

        () = PCCINVOKE(INTERP, class_instr, "attach_to_object", PMC *classname);

        RETURN(PMC *class_instr);
    }

}

/*
 * Runcore Function Implementations
 */

/*
 * This is the simplified custom runops function.
 * This is based on the PARROT_FAST_RUNCORE.
 */

static
opcode_t *
Instrument_runcore_runops(PARROT_INTERP, Parrot_runcore_t *runcore, opcode_t *pc) {
    Instrument_runcore_t *core = (Instrument_runcore_t *) runcore;
    Parrot_Interp supervisor = core->supervisor_interp;
    Parrot_runloop exc_handler;

    /* Detect any dynlib loading, for example during load_bytecode. */
    detect_loadlib(interp);

    /* Refresh the probes. */
    {
        PMC *iter, *probes;
        STRING *enable, *disable, *attr_enabled;

        enable  = CONST_STRING(supervisor, "enable");
        disable = CONST_STRING(supervisor, "disable");
        attr_enabled = CONST_STRING(supervisor, "$!is_enabled");

        GETATTR_Instrument_probes(supervisor, core->supervisor_pmc, probes);
        iter = VTABLE_get_iter(supervisor, probes);

        while (VTABLE_get_bool(supervisor, iter)) {
            PMC *key, *obj, *enabled;
            key = VTABLE_shift_pmc(supervisor, iter);
            obj = VTABLE_get_pmc_keyed(supervisor, probes, key);

            /* If this probe is disabled, ignore. */
            enabled = VTABLE_get_attr_str(supervisor, obj, attr_enabled);
            if (!VTABLE_get_integer(supervisor, enabled)) {
                continue;
            }

            Parrot_pcc_invoke_method_from_c_args(supervisor, obj, disable, "->");
            Parrot_pcc_invoke_method_from_c_args(supervisor, obj, enable,  "->");
        }
    }

    /* Setup an exception handler to handle exits and unhandled exceptions. */
    if (setjmp(exc_handler.resume)) {
        /* Check for exit or unhandled exception. */
        Parrot_Context_info info;
        INTVAL ret = Parrot_Context_get_info(interp, CURRENT_CONTEXT(interp), &info);

        if (*pc == enum_ops_exit_i || *pc == enum_ops_exit_ic) {
            /* Exit called. */
            Parrot_io_eprintf(supervisor, "Exit called in file \"%Ss\" line %d.\n",
                             info.file, info.line);
        }
        else {
            /* Unhandled exception found. */
            INTVAL type = VTABLE_get_integer_keyed_str(interp, exc_handler.exception,
                                                         CONST_STRING(interp, "type"));
            STRING *message = VTABLE_get_string(interp, exc_handler.exception);
            Parrot_io_eprintf(supervisor,
                            "Unhandled exception of type (%d) thrown in file \"%Ss\" line %d,\n"
                            "with message \"%Ss\".\n",
                            type, info.file, info.line, message);
        }

         /* Set the flag to exit all runloops. */
         core->has_ended = 1;

        return pc;
    }

    Parrot_ex_add_c_handler(interp, &exc_handler);

    while (pc && !(core->has_ended)) {
        probe_list_t *callbacks, *recalls, *ignore;
        opcode_t *pc_copy = pc;
        Parrot_pcc_set_pc(interp, CURRENT_CONTEXT(interp), pc);

        /* Get the list of callbacks to call and execute the op. */
        callbacks = Instrument_get_active_probes(pc, interp);
        recalls   = Instrument_fire_probes(callbacks, pc, interp);
        DO_OP(pc, interp);
        ignore    = Instrument_fire_probes(recalls, pc_copy, interp);
        probe_list_delete_list(supervisor, ignore);

        /* Todo: Move this to a probe. This detects loadlib opcodes. */
        if (*pc_copy == enum_ops_loadlib_p_s
         || *pc_copy == enum_ops_loadlib_p_sc
         || *pc_copy == enum_ops_loadlib_p_s_p
         || *pc_copy == enum_ops_loadlib_p_sc_p
         || *pc_copy == enum_ops_loadlib_p_s_pc
         || *pc_copy == enum_ops_loadlib_p_sc_pc) {
            detect_loadlib(interp);
        }

        /* Force events */
        Parrot_cx_handle_tasks(interp, interp->scheduler);
        Parrot_cx_handle_tasks(supervisor, supervisor->scheduler);
    }

    return pc;
}

/*
 * This is the initializer for the runcore.
 * Sets up runcore_t.
 */

static
void
Instrument_runcore_init(PARROT_INTERP, Parrot_Interp supervisor, PMC *instrument) {
    Instrument_runcore_t * const coredata =
        mem_gc_allocate_zeroed_typed(interp, Instrument_runcore_t);
    PMC *dynlibs, *interp_pmc;
    INTVAL instr_op_type;

    /* Get the pmc type of InstrumentOp. */
    interp_pmc    = VTABLE_get_pmc_keyed_int(interp, interp->iglobals, IGLOBALS_INTERPRETER);
    instr_op_type = Parrot_pmc_get_type_str(supervisor, CONST_STRING(supervisor, "InstrumentOp"));

    /* Grab the dynlib hash. */
    dynlibs = VTABLE_get_pmc_keyed_int(interp, interp->iglobals, IGLOBALS_DYN_LIBS);

    /* Ensure the current loaded runcore is the slow core */
    Parrot_set_run_core(interp, PARROT_SLOW_CORE);

    /* Copy the runcore entry for the PARROT_SLOW_CORE,
       and then make modifications to it.
       Copy so that we get the opinit function pointer.
    */
    mem_copy_n_typed(coredata, interp->run_core, 1, Parrot_runcore_t);

    coredata->name               = string_from_literal(interp, "instrument");
    coredata->runops             = Instrument_runcore_runops;
    coredata->prepare_run        = NULL;
    coredata->destroy            = NULL;
    coredata->flags              = 0;
    coredata->supervisor_interp  = supervisor;
    coredata->supervisor_pmc     = instrument;
    coredata->op_hooks           = NULL;
    coredata->op_catchall        = NULL;
    coredata->old_dynlibs        = VTABLE_clone(supervisor, dynlibs);
    coredata->has_ended          = 0;
    coredata->instr_op           = Parrot_pmc_new_init(supervisor, instr_op_type, interp_pmc);

    PARROT_RUNCORE_FUNC_TABLE_SET((Parrot_runcore_t *)coredata);

    Parrot_runcore_register(interp, (Parrot_runcore_t *) coredata);

    /* Switch to this runcore. */
    Parrot_runcore_switch(interp, coredata->name);
}

/*
 * This is the initializer for the probe tables.
 * Probes are stored in the extended runcore_t.
 */

static void Instrument_init_probes(Parrot_Interp supervisor, Parrot_Interp supervised) {
    Instrument_runcore_t *core;
    INTVAL op_count;

    core     = (Instrument_runcore_t *) supervised->run_core;
    op_count = supervised->op_count;

    /* Create the probe list table */
    if (!core->op_hooks) {
        /* First time allocating. */
        core->op_hooks    = mem_gc_allocate_n_zeroed_typed(supervisor, op_count, probe_list_t *);
        core->op_catchall = probe_list_create_list(supervisor);
    }
    else {
        /* Reallocate. */
        INTVAL old_count  = supervisor->op_count;
        core->op_hooks    = mem_gc_realloc_n_typed_zeroed(supervisor, core->op_hooks,
                                                          op_count, old_count, probe_list_t *);
    }
}

/*
 * Returns a list of Probe objects to be called by Instrument_fire_probes.
 */

static probe_list_t * Instrument_get_active_probes(opcode_t *pc, PARROT_INTERP) {
    probe_list_t         *list;
    probe_node_t         *cur_node;
    Instrument_runcore_t *core;
    Parrot_Interp         supervisor;

    core       = (Instrument_runcore_t *) interp->run_core;
    supervisor = core->supervisor_interp;
    list       = probe_list_create_list(supervisor);

    /* Copy over the list entries for the catchalls
       and specific op probes into the list. */
    cur_node = core->op_catchall->head;
    while (cur_node != NULL) {
        probe_list_push(supervisor, list, cur_node->list_obj);
        cur_node = cur_node->next;
    }

    if (core->op_hooks[*pc] != NULL) {
        cur_node = core->op_hooks[*pc]->head;
        while (cur_node != NULL) {
            probe_list_push(supervisor, list, cur_node->list_obj);
            cur_node = cur_node->next;
        }
    }

    return list;
}

/*
 * Executes the hooks given in the list 'list'.
 * Each entry in this list can either be the Probe object or a RPA that
 *  has 2 elements, the Probe object and an invokable.
 * If the invokable returns a PMC that is also invokable, this return
 *  value then goes into the recall list to be called after the op is executed.
 */

static probe_list_t * Instrument_fire_probes(probe_list_t *list, opcode_t *pc, PARROT_INTERP) {
    Parrot_Interp         supervisor;
    PMC                  *instrument, *op_data;
    Instrument_runcore_t *core;
    probe_node_t         *cur_probe;
    probe_list_t         *recall_list;

    core        = (Instrument_runcore_t *) interp->run_core;
    supervisor  = core->supervisor_interp;
    instrument  = core->supervisor_pmc;
    op_data     = core->instr_op;
    recall_list = probe_list_create_list(supervisor);

    /* Update pc of InstrumentOp object. */
    VTABLE_set_pointer(supervisor, op_data, pc);

    /* Execute the probes in the list. */
    cur_probe = list->head;
    while (cur_probe != NULL) {
        PMC *callback;
        PMC *probe;

        /* Get the probe and list object. */
        if (VTABLE_does(supervisor, cur_probe->list_obj, CONST_STRING(supervisor, "array"))) {
            /* Obtain the probe and callback from the RPA. */
            probe    = VTABLE_get_pmc_keyed_int(supervisor, cur_probe->list_obj, 0);
            callback = VTABLE_get_pmc_keyed_int(supervisor, cur_probe->list_obj, 1);
        }
        else {
            /* Node contains the probe object. Obtain the callback from its attributes. */
            probe    = cur_probe->list_obj;
            callback = VTABLE_get_attr_str(supervisor, probe,
                                           CONST_STRING(supervisor, "$!callback"));
        }

        if (!PMC_IS_NULL(callback)) {
            /* Pass params: InstrumentOp, Instrument, Instrument::Probe.
               If a PMC is returned, only push it into the recall list if
               it is invokable. */
            PMC *recall = PMCNULL;
            Parrot_ext_call(supervisor, callback,
                            "PPP->P",
                            op_data, instrument, probe,
                            &recall);
            if (!PMC_IS_NULL(recall) && VTABLE_does(supervisor, recall,
                                                   CONST_STRING(supervisor, "invokable"))) {
                PMC *list_entry;

                list_entry = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
                VTABLE_push_pmc(supervisor, list_entry, cur_probe->list_obj);
                VTABLE_push_pmc(supervisor, list_entry, recall);

                probe_list_push(supervisor, recall_list, list_entry);
            }
        }

        /* Go on to next entry. */
        cur_probe = cur_probe->next;
    }

    /* Cleanup list and return. */
    probe_list_delete_list(supervisor, list);
    return recall_list;
}

/*
 * Functions implementing internal detection of newly loaded dynlibs.
 */

/*
 * Detect newly loaded dynlibs in the passed interp by comparing it
 * with a hash of previously known loaded dynlibs.
 */
static void detect_loadlib(PARROT_INTERP) {
    PMC *dynlibs, *old_dynlibs, *super_dynlibs;
    Instrument_runcore_t *core;
    Parrot_Interp supervisor;
    INTVAL old_count, new_count;

    core          = (Instrument_runcore_t *) interp->run_core;
    supervisor    = core->supervisor_interp;
    super_dynlibs = supervisor->iglobals;
    old_dynlibs   = core->old_dynlibs;
    dynlibs       = VTABLE_get_pmc_keyed_int(interp, interp->iglobals, IGLOBALS_DYN_LIBS);

    /* Check if any libraries were loaded. */
    old_count = VTABLE_get_integer(supervisor, old_dynlibs);
    new_count = VTABLE_get_integer(interp, dynlibs);

    if (old_count != new_count) {
        PMC *iter;

        /* Normalise the vtables of both interps due to singletons. */
        fixup_vtables(interp, supervisor);

        /* Before we normalise the op tables, we need to update the hooks table. */
        Instrument_init_probes(supervisor, interp);
        normalise_op_tables(interp, supervisor);

        /* Look for the new dynlibs and raise an event about them. */
        iter = VTABLE_get_iter(interp, dynlibs);
        while (VTABLE_get_bool(interp, iter)) {
            PMC *key;

            key = VTABLE_shift_pmc(interp, iter);

            if (!VTABLE_exists_keyed(supervisor, old_dynlibs, key)) {
                /* New lib detected. */
                PMC *lib, *task, *task_hash, *task_data;

                lib = VTABLE_get_pmc_keyed(interp, dynlibs, key);

                raise_dynlib_event(supervisor, lib);

                /* Add lib to the old dynlib hash */
                VTABLE_set_pmc_keyed(supervisor, old_dynlibs, key, lib);
            }
        }
    }

    /* Force handling of any pending tasks in super. */
    Parrot_cx_handle_tasks(supervisor, supervisor->scheduler);
}

/*
 * Normalise the vtables between the source and dest interpreters.
 */
static void fixup_vtables(Parrot_Interp src, Parrot_Interp dest) {
    INTVAL i;

    /* Extend dest's vtable. */
    if (dest->n_vtable_alloced < src->n_vtable_max) {
        INTVAL new_size;

        new_size = src->n_vtable_max + 16;

        dest->vtables = mem_gc_realloc_n_typed_zeroed(dest, dest->vtables,
                                                      new_size, dest->n_vtable_alloced,
                                                      VTABLE *);
        dest->n_vtable_alloced = new_size;
    }

    /* Copy over the new vtable entries. */
    for (i = dest->n_vtable_max; i < src->n_vtable_max; i++) {
        dest->vtables[i] = src->vtables[i];
    }

    dest->n_vtable_max = src->n_vtable_max;
}

/*
 * Normalise the op tables of the dest interpreter.
 */
static void normalise_op_tables(Parrot_Interp src, Parrot_Interp dest) {
    op_lib_t *core_lib;

    /* Reset dest's optables if needed. */
    core_lib = dest->run_core->opinit(dest, 1);
    if (dest->op_count != core_lib->op_count) {
        dest->op_count      = core_lib->op_count;
        dest->op_info_table = core_lib->op_info_table;
        dest->op_func_table = core_lib->op_func_table;

        /* Remove dest's evc_func_table */
        if (dest->evc_func_table != NULL) {
            mem_gc_free(dest, dest->evc_func_table);

            dest->evc_func_table  = NULL;
            dest->save_func_table = NULL;

            Parrot_setup_event_func_ptrs(dest);
        }
    }
}

/*
 * Raises an Internal::loadlib event.
 */
static void raise_dynlib_event(PARROT_INTERP, PMC *lib) {
    PMC *data, *task_hash, *task, *event;

    event = Parrot_pmc_new(interp, enum_class_ResizableStringArray);
    VTABLE_push_string(interp, event, CONST_STRING(interp, "Internal"));
    VTABLE_push_string(interp, event, CONST_STRING(interp, "loadlib"));
    VTABLE_push_string(interp, event, VTABLE_get_string(interp, lib));

    data = Parrot_pmc_new(interp, enum_class_Hash);
    VTABLE_set_string_keyed_str(interp, data,
                                CONST_STRING(interp, "library"),
                                VTABLE_get_string(interp, lib));
    VTABLE_set_pmc_keyed_str(interp, data,
                                CONST_STRING(interp, "event"),
                                event);

    task_hash = Parrot_pmc_new(interp, enum_class_Hash);
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "type"),
                                CONST_STRING(interp, "event"));
    VTABLE_set_string_keyed_str(interp, task_hash,
                                CONST_STRING(interp, "subtype"),
                                CONST_STRING(interp,
                                             "Instrument"));
    VTABLE_set_pmc_keyed_str(interp, task_hash,
                             CONST_STRING(interp, "data"),
                             data);

    task = Parrot_pmc_new_init(interp, enum_class_Task, task_hash);
    Parrot_cx_schedule_task(interp, task);
}


/*
 * Functions implementing the linked list for the probes.
 */

/*
 * Creates a new list.
 */
static probe_list_t *probe_list_create_list(PARROT_INTERP) {
    probe_list_t *list;

    list = mem_gc_allocate_zeroed_typed(interp, probe_list_t);

    list->head = NULL;
    list->tail = NULL;

    return list;
}

/*
 * Creates a new list node.
 */
static probe_node_t *probe_list_create_node(PARROT_INTERP) {
    probe_node_t *node;

    node = mem_gc_allocate_zeroed_typed(interp, probe_node_t);

    node->next     = NULL;
    node->prev     = NULL;
    node->list_obj = NULL;

    return node;
}

/*
 * Deletes the list.
 */
static void probe_list_delete_list(PARROT_INTERP, probe_list_t *list) {
    probe_node_t *node, *next;

    node = list->head;
    while (node != NULL) {
        next = node->next;
        probe_list_delete_node(interp, node);
        node = next;
    }

    mem_gc_free(interp, list);
}

/*
 * Deletes the node.
 */
static void probe_list_delete_node(PARROT_INTERP, probe_node_t *node) {
    mem_gc_free(interp, node);
}

/*
 * Pushes item to the end of the list.
 */
static void probe_list_push(PARROT_INTERP, probe_list_t *list, PMC *item) {
    probe_node_t *node = probe_list_create_node(interp);
    node->list_obj     = item;

    if (list->head == NULL) {
        list->head = list->tail = node;
    }
    else {
        node->prev       = list->tail;
        node->next       = NULL;
        list->tail->next = node;
        list->tail       = node;
    }
}

/*
 * Removes item at the end of the list.
 */
static PMC * probe_list_pop(PARROT_INTERP, probe_list_t *list) {
    PMC *item = PMCNULL;
    probe_node_t *node = list->tail;

    if (node != NULL) {
        if (node == list->head) {
            list->head = list->tail = NULL;
        }
        else {
            list->tail       = node->prev;
            list->tail->next = NULL;
        }

        item = node->list_obj;

        probe_list_delete_node(interp, node);
    }

    return item;
}

/*
 * Removes the given node. Used with probe_list_find.
 * Returns the item in that node.
 */
static PMC * probe_list_remove(PARROT_INTERP, probe_list_t *list, probe_node_t *node) {
    PMC *item;

    if (node == list->head) { list->head = node->next; }
    if (node == list->tail) { list->tail = node->prev; }

    if (node->prev != NULL) { node->prev->next = node->next; }
    if (node->next != NULL) { node->next->prev = node->prev; }

    item = node->list_obj;

    probe_list_delete_node(interp, node);

    return item;
}

/*
 * Locates item within the list and returns the node.
 */
static probe_node_t *probe_list_find(PARROT_INTERP, probe_list_t *list, PMC *val) {
    probe_node_t *cur_node = list->head;

    while (cur_node != NULL) {
        if (cur_node->list_obj == val) { return cur_node; }

        cur_node = cur_node->next;
    }

    return NULL;
}

/*
=back

=head1 SEE ALS0

=cut
*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
