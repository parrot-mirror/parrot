/*
Copyright (C) 2010, Parrot Foundation.
$Id$

=head1 NAME

src/dynpmc/instrument.pmc - Interface to hook into a child interpreter.

=head1 DESCRIPTION

C<Instrument> is a PMC class that allows dynamic execution introspection
to be done on a child interpreter.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/imcc.h"
#include "parrot/runcore_api.h"
#include "parrot/embed.h"

/*
 * Extend the runcore_t struct to include a reference
 *  to the supervisor interpreter.
 */
typedef struct Instrument_runcore_t {
    STRING                  *name;
    int                      id;
    oplib_init_f             opinit;
    runcore_runops_fn_type   runops;
    runcore_destroy_fn_type  destroy;
    runcore_prepare_fn_type  prepare_run;
    INTVAL                   flags;
    
    /* End of common members */
    PMC                     *supervisor;
} Instrument_runcore_t;

/* Define the enumeration for op lookups */
typedef enum {
    OP_LOOKUP   = 0,
    OP_INFO     = 1,
    OP_FULLNAME = 2,
    OP_NAME     = 3,
    OP_ARGS     = 4,
    OP_COUNT    = 5
} Instrument_op_query_t;

/* Runcore Function Prototypes */
static void Instrument_runcore_init (PARROT_INTERP, PMC *supervisor);
static opcode_t * Instrument_runcore_runops(PARROT_INTERP, Parrot_runcore_t *runcore, opcode_t *pc);

pmclass Instrument auto_attrs dynpmc provides hash {
    ATTR Parrot_Interp  supervisor;  /* The interpreter that created this instance */
    ATTR Parrot_Interp  supervised;  /* The interpreter running the code */
    ATTR opcode_t      *cur_pc;
    ATTR PMC           *op_hooks;    /* A ResizablePMCArray for holding references to op hooks */
    ATTR PMC           *op_catchall; /* These callbacks are to be called on each op */
    ATTR PMC           *probes;      /* A list of probes registered. */

/*

=item C<void init()>

Initializes the pmc and creates a child interpreter.

=cut

*/

    VTABLE void init () {
        struct parrot_interp_t *in;
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        
        /* Create the child interpreter PMC */
        attr->supervisor  = INTERP;
        attr->supervised  = Parrot_new(attr->supervisor);
        attr->op_hooks    = Parrot_pmc_new(INTERP, enum_class_ResizablePMCArray);
        attr->op_catchall = Parrot_pmc_new(INTERP, enum_class_Hash);
        attr->probes      = Parrot_pmc_new(INTERP, enum_class_Hash);
        
        /* Initialize the runcore for the child interpreter */  
        Instrument_runcore_init(attr->supervised, SELF);
        
        /* Set self to destroy manually */
        PObj_custom_mark_destroy_SETALL(SELF);
    }

/*

=item C<void destroy()>

Cleans up after the PMC.

=cut

*/

    VTABLE void destroy () {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        
        /* Delete the supervised interpreter */
        Parrot_destroy(attr->supervised);
        
        /* Set the references to null */
        /* TODO: Is there a better way to delete them? */
        attr->supervisor  = NULL;
        attr->supervised  = NULL;
        attr->op_hooks    = NULL;
        attr->op_catchall = NULL;
        attr->probes      = NULL;
    }

/*

=item C<void mark()>

Marks internal data structures as live to the gc.

=cut

*/

    VTABLE void mark () {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
    
        /* Mark attributes as alive */
        Parrot_gc_mark_PMC_alive_fun(INTERP, attr->op_hooks);
        Parrot_gc_mark_PMC_alive_fun(INTERP, attr->op_catchall);
        Parrot_gc_mark_PMC_alive_fun(INTERP, attr->probes);
    }

/*

=item C<void * get_pointer()>

Returns a reference to the supervising interpreter,
meaning the interpreter that runs the instruments.

=cut

*/

    VTABLE void * get_pointer () {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        return attr->supervisor;
    }

/*

=item C<void set_pointer(void *pc_pointer)>

With the pc_pointer passed in, execute the current op at
the given address after firing all hooks that apply.

=cut

*/

    VTABLE void set_pointer (void *pc_pointer) {
        opcode_t *pc = (opcode_t *) pc_pointer;
        PMC *hooks, *hook_iter, *catchall_iter, *op_data;
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        INTVAL pc_relative, cur_op_param, op_params;
        
        attr->cur_pc = pc;
        
        /* Calculate the relative position of the pc. */
        pc_relative = pc - attr->supervised->code->base.data;
        
        /* Grab the opcode params */
        op_params = attr->supervised->op_info_table[*pc].op_count;
        op_data   = Parrot_pmc_new(INTERP, enum_class_ResizableIntegerArray);
        cur_op_param = 0;
        while(cur_op_param <= op_params) {
            VTABLE_push_integer(INTERP, op_data, pc[cur_op_param]);
            cur_op_param++;
        }
        
        /* Fire the catchall hooks first */
        catchall_iter = VTABLE_get_iter(INTERP, attr->op_catchall);
        while(VTABLE_get_bool(INTERP, catchall_iter)) {
            PMC *val, *key;
            
            key = VTABLE_shift_pmc(INTERP, catchall_iter);
            val = VTABLE_get_pmc_keyed(INTERP, attr->op_catchall, key);
            
            if(!PMC_IS_NULL(val)) {
                Parrot_ext_call(INTERP, val, "IPP->", pc_relative, op_data, SELF);
			}
        }
        
        /* Fire the specific probes */
        hooks     = VTABLE_get_pmc_keyed_int(INTERP, attr->op_hooks, *pc);
        if(!PMC_IS_NULL(hooks)) {
            hook_iter = VTABLE_get_iter(INTERP, hooks);
            while(VTABLE_get_bool(INTERP, hook_iter)) {
                PMC *val, *key;
                
                key = VTABLE_shift_pmc(INTERP, hook_iter);
                val = VTABLE_get_pmc_keyed(INTERP, hooks, key);
                
                if(!PMC_IS_NULL(val)) {
                    Parrot_ext_call(INTERP, val, "IPP->", pc_relative, op_data, SELF);
                }
            }
        }
        
        /* Done firing hooks */
        return;
    }

/*

=item C<void get_pmc_keyed(PMC *key)>

Get the property with the key.

Keys:
probes: returns the hash of probes currently registered.

Unknown keys are sent to the supervised interpreter.

=cut

*/

    VTABLE PMC *get_pmc_keyed(PMC *key) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        PMC *nextkey, *supervised_pmc;
        STRING *item = key_string(INTERP, key);
        STRING *name;

        /* probes: return the hash of probes */
        name = CONST_STRING(INTERP, "probes");
        if(Parrot_str_equal(INTERP, name, item)) {
            return attr->probes;
        }
        
        /* push to the supervised interpreter. */
        supervised_pmc = VTABLE_get_pmc_keyed_int(attr->supervised,
                                                  attr->supervised->iglobals,
                                                  (INTVAL) IGLOBALS_INTERPRETER);
        return VTABLE_get_pmc_keyed(INTERP, supervised_pmc, key);
    }

/*

=item C<void run(STRING file, PMC *args)>

Loads the given file and run it with the args given.

=cut

*/

    METHOD run (STRING file, PMC *args) {
        PMC *entry_point;
        int argc = 0, status;
        char * default_argv[] = {NULL};
        char ** argv = default_argv;
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        PMC *probe_iter;
        int counter = 0;
            
        /* If args is not null, is of type ResizableStringArray and has at
           least 1 element, process it so we can pass it to the child interpreter.
         */
        if(!Parrot_pmc_is_null(INTERP, args)
           && VTABLE_type(INTERP, args) == enum_class_ResizableStringArray
           && VTABLE_get_integer(INTERP, args) > 0) {
            /* There are some arguments to be passed to
               the child interpreter. We need to convert
               them from Parrot strings to c-strings so
               that we can pass it to imcc.
            */
            
            /* Get the number of argument values */
            int count = VTABLE_get_integer(INTERP, args);
            
            /* Allocate enough memory for the argv pointer array */
            argv = (char **) mem_gc_allocate_n_zeroed_typed(INTERP, count, char *);
            
            /* Populate the argv array, updating argc in the process */
            for(argc = 0; argc < count; argc++) {
                STRING *cur;
                
                cur = VTABLE_get_string_keyed_int(INTERP, args, argc);
                argv[argc] = Parrot_str_to_cstring(INTERP, cur);
            }
        }
        
        /* Begin Execution */
        status = imcc_run(attr->supervised,
                    Parrot_str_cstring(attr->supervised, file),
                    argc, (const char **) argv);
        if (status)
            imcc_run_pbc(attr->supervised,
                         attr->supervised->output_file,
                         argc,(const char **) argv);
        
        /* Finalize the instruments */
        probe_iter = VTABLE_get_iter(INTERP, attr->probes);
        while(VTABLE_get_bool(INTERP, probe_iter)) {
            PMC *key, *probe, *finalize_sub;
            
            /* For the current probe, get the finalize attribute. */
            key          = VTABLE_shift_pmc(INTERP, probe_iter);
            probe        = VTABLE_get_pmc_keyed(INTERP, attr->probes, key);
            finalize_sub = VTABLE_get_attr_str(INTERP, probe,
                                               CONST_STRING(INTERP, "$!finalize"));
            
            /* If it is set, call that sub. */
            if(!PMC_IS_NULL(finalize_sub)) {
                Parrot_ext_call(INTERP, finalize_sub, "->");
            }
        }
        
        /* We should free the cstrings allocated above if needed */
        if(argc > 0) {
            for(; argc > 0; argc--) {
                Parrot_str_free_cstring(argv[argc - 1]);
                argv[argc - 1] = NULL;
            }
            
            /* Free the memory allocated to hold the string pointers */
            mem_gc_free(INTERP, argv);
            argv = NULL;
        }
    }

/*

=item C<void attach(PMC *obj)>

With the passed in object, assume it is a class with the method 'enable'
and attribute 'instr_obj'. Set the 'instr_obj' to SELF and call the
'enable' method of the object for the object to commence attaching the hooks.

=cut

*/

    METHOD attach (PMC *obj) {
        PMC *enable_method, *id;
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
    
        /* We do not care what type of object it is,
           as long as the object has the attributes $!instr_obj and $!identifier
           and the method enable. */
        
        /* Set the instrument reference attribute of the object,
           and call its enable method. */
        VTABLE_set_attr_str(
            INTERP, obj,
            CONST_STRING(INTERP, "$!instr_obj"),
            SELF
        );
        
        /* Find the enable method */
        enable_method = VTABLE_find_method(INTERP, obj, CONST_STRING(INTERP, "enable"));
        if(PMC_IS_NULL(enable_method)) {
            /* Error! Could not find the enable method. */
            Parrot_ex_throw_from_c_args(
                INTERP, NULL, 1,
                "Could not locate the method 'enable'."
            );
        }
        
        /* Call the method.
           The first parameter to a method is the object itself.
           The enable method will be calling insert_hooks(HASH) to register the hooks. */
        Parrot_ext_call(INTERP, enable_method, "P->", obj);
        
        /* Register the probe. */
        id = VTABLE_get_attr_str(INTERP, obj, CONST_STRING(INTERP, "$!identifier"));
        VTABLE_set_pmc_keyed(INTERP, attr->probes, id, obj);
    }

/*

=item C<void *insert_op_hooks(PMC *id, INTVAL op_num, PMC *hook)>

Insert a hook for the given op number.

=cut

*/
    
    METHOD insert_op_hook (PMC *id, INTVAL op_num, PMC *hook) {
        PMC *op_num_hooks;
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        
        op_num_hooks = VTABLE_get_pmc_keyed_int(INTERP, attr->op_hooks, op_num);
        if(PMC_IS_NULL(op_num_hooks)) {
            op_num_hooks = Parrot_pmc_new(INTERP, enum_class_Hash);
            VTABLE_set_pmc_keyed_int(INTERP, attr->op_hooks, op_num, op_num_hooks);
        }
        
        VTABLE_set_pmc_keyed(INTERP, op_num_hooks, id, hook);
    }

/*

=item C<void *remove_op_hooks(PMC *id, INTVAL op_num)>

Removes a hook for the given op number.

=cut

*/
    
    METHOD remove_op_hook (PMC *id, INTVAL op_num) {
        PMC *op_num_hooks;
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        
        op_num_hooks = VTABLE_get_pmc_keyed_int(INTERP, attr->op_hooks, op_num);
        if(!PMC_IS_NULL(op_num_hooks)) {
            VTABLE_delete_keyed(INTERP, op_num_hooks, id);
        }
    }

/*
=item C<void *insert_op_catchall(PMC *id, PMC *callback)>

Register a catchall op callback

=cut
*/

    METHOD insert_op_catchall (PMC *id, PMC *callback) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        
        VTABLE_set_pmc_keyed(INTERP, attr->op_catchall, id, callback);
    }

/*
=item C<void *remove_op_catchall(PMC *id)>

Deregister a catchall op callback

=cut
*/

    METHOD remove_op_catchall (PMC *id) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        
        VTABLE_delete_keyed(INTERP, attr->op_catchall, id);
    }

/*
=item C<PMC *get_op_arg(INTVAL arg, INTVAL arg_type)>

Interprets arg according to arg_type and returns the value as a PMC.
Eg, get_op_arg(0, PARROT_ARG_I) => Returns the value in register I0.

arg_type is as defined in parrot/op.h

=cut
*/

    METHOD get_op_arg (INTVAL arg, INTVAL arg_type) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        PMC *ret, *cc, *key;
        arg_type_t type = (arg_type_t) arg_type;
        
        cc = CURRENT_CONTEXT(attr->supervised);
        
        switch(type) {
          case PARROT_ARG_IC:            
            /* Integer constants are stored as part of the opcode
               in the packfile */
            ret = Parrot_pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, ret, arg);
            
            break;
          case PARROT_ARG_I:
            ret = Parrot_pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, ret, *Parrot_pcc_get_INTVAL_reg(INTERP, cc, arg));

            break;
          case PARROT_ARG_NC:
            ret = Parrot_pmc_new(INTERP, enum_class_Float);
            VTABLE_set_number_native(INTERP, ret, Parrot_pcc_get_num_constant_func(INTERP, cc, arg));
            
            break;
          case PARROT_ARG_N:
            ret = Parrot_pmc_new(INTERP, enum_class_Float);
            VTABLE_set_number_native(INTERP, ret, *Parrot_pcc_get_FLOATVAL_reg(INTERP, cc, arg));

            break;
          case PARROT_ARG_PC:
            ret = Parrot_pcc_get_pmc_constant_func(INTERP, cc, arg);
            
            break;
          case PARROT_ARG_P:
            ret = *Parrot_pcc_get_PMC_reg(INTERP, cc, arg);
            
            break;
          case PARROT_ARG_SC:
            ret = Parrot_pmc_new(INTERP, enum_class_String);
            VTABLE_set_string_native(INTERP, ret, Parrot_pcc_get_string_constant_func(INTERP, cc, arg));
            
            break;
          case PARROT_ARG_S:
            ret = Parrot_pmc_new(INTERP, enum_class_String);
            VTABLE_set_string_native(INTERP, ret, *Parrot_pcc_get_STRING_reg(INTERP, cc, arg));

            break;
          case PARROT_ARG_K:
            /* Key is PMC */
            ret = *Parrot_pcc_get_PMC_reg(INTERP, cc, arg);
            
            break;
          case PARROT_ARG_KC:
            /* Key is String reg or String const */
            ret = (Parrot_pcc_get_constants(INTERP, cc)[arg])->u.key;

            break;
          case PARROT_ARG_KI:
            /* Key is integer reg */
            ret = Parrot_pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, ret, *Parrot_pcc_get_INTVAL_reg(INTERP, cc, arg));
            
            break;
          case PARROT_ARG_KIC:
            /* Key is integer constant */
            ret = Parrot_pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, ret, arg);
          
            break;
          default:
            Parrot_ex_throw_from_c_args(
                INTERP, NULL, 1,
                "Currently unhandled op arg type %d.", type
            );
        };
        
        RETURN(PMC *ret);
    }

    METHOD get_key_value (PMC *key) {
        Parrot_Instrument_attributes * const attr = PARROT_INSTRUMENT(SELF);
        STRING *key_str = key_string(attr->supervised, key);
        RETURN(STRING *key_str);
    }

}

/*
 * Runcore Function Implementations
 */

/*
 * This is the simplified custom runops function.
 * This is based on the PARROT_FAST_RUNCORE.
 */
static
opcode_t *
Instrument_runcore_runops(PARROT_INTERP, Parrot_runcore_t *runcore, opcode_t *pc)
{	
    Instrument_runcore_t *core = (Instrument_runcore_t *) runcore;
    
    PMC *pmc = core->supervisor;
    Parrot_Interp supervisor = (Parrot_Interp) VTABLE_get_pointer(interp, pmc);

    while (pc) {
		Parrot_pcc_set_pc(interp, CURRENT_CONTEXT(interp), pc);
		
		/* Fire the hooks */
		VTABLE_set_pointer(supervisor, pmc, pc);

        DO_OP(pc, interp);
    }
	
    return pc;
	
}

/*
 * This is the initializer for the runcore.
 * Sets up runcore_t.
 */
static
void
Instrument_runcore_init (PARROT_INTERP, PMC *supervisor) {
	Instrument_runcore_t * const coredata =
	    mem_gc_allocate_zeroed_typed(interp, Instrument_runcore_t);
	
	/* Ensure the current loaded runcore is the slow core */
	Parrot_set_run_core(interp, PARROT_SLOW_CORE);
	
	/* Copy the runcore entry for the PARROT_SLOW_CORE,
	   and then make modifications to it.
	   Copy so that we get the opinit function pointer.
	*/
	mem_copy_n_typed(coredata, interp->run_core, 1, Parrot_runcore_t);
	
	coredata->name			= string_from_literal(interp, "instrument");
	coredata->runops		= Instrument_runcore_runops;
	coredata->prepare_run	= NULL;
	coredata->destroy		= NULL;
	coredata->flags			= 0;
	coredata->supervisor   = supervisor;
	
	PARROT_RUNCORE_FUNC_TABLE_SET((Parrot_runcore_t *)coredata);
	
	Parrot_runcore_register(interp, (Parrot_runcore_t *) coredata);
	
	//Switch to this runcore.
	Parrot_runcore_switch(interp, coredata->name);
}

/*
=back

=head1 SEE ALS0

=cut
*/

/*
 * Local Variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
