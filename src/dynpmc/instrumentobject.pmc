/*
Copyright (C) 2010, Parrot Foundation.
$Id$

=head1 NAME

src/dynpmc/instrumentobject.pmc - Interface to instrument a class instance.

=head1 DESCRIPTION

C<InstrumentObject> allows any PMC instance to be instrumented on a
per object basis.

=head2 Methods

=over 4

=cut

*/

#include "pmc_instrument.h"

extern
void setup_vtable_individual_hashes(PARROT_INTERP, Hash *orig_hash, Hash *instr_hash,
                                    _vtable *vt_orig, _vtable *vt_instr);

pmclass InstrumentObject auto_attrs dynpmc group instrument_group extends InstrumentClass {

/*

=item C<void attach_to_class(STRING *classname)>

Overrides the PARENT's method and throws an exception as
we are instrumenting an object, not a class.

=cut

*/

    METHOD attach_to_class(STRING *classname) {
        /* Instrumenting an object, not a class. */
        Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                    "Attach %Ss to an object using 'attach_to_object' instead.",
                                   VTABLE_name(INTERP, SELF));
    }

/*

=item C<void attach_to_object(PMC *object)>

Prepares the object for instrumentation.

=cut

*/

    METHOD attach_to_object(PMC *object) {
        Parrot_InstrumentObject_attributes * const attr = PARROT_INSTRUMENTOBJECT(SELF);
        Parrot_Interp supervised;
        STRING *addr;

        GETATTR_Instrument_supervised(INTERP, attr->instrument, supervised);

        attr->class_name          = VTABLE_name(INTERP, object);
        attr->instrumented_struct = mem_gc_allocate_zeroed_typed(supervised, _vtable);
        attr->original_struct     = object->vtable;
        mem_copy_n_typed(attr->instrumented_struct, attr->original_struct, 1, _vtable);
        object->vtable = (_vtable *) attr->instrumented_struct;

        parrot_hash_put(INTERP, attr->registry, attr->instrumented_struct, SELF);

        setup_vtable_individual_hashes(INTERP, attr->name_original, attr->name_offset,
                                       (_vtable *) attr->original_struct,
                                       (_vtable *) attr->instrumented_struct);

        /* Update the event_prefix attribute. */
        (STRING *addr) = PCCINVOKE(INTERP, SELF, "get_address");
        VTABLE_push_string(INTERP, attr->event_prefix, CONST_STRING(INTERP, "Object"));
        VTABLE_push_string(INTERP, attr->event_prefix, addr);
    }

    METHOD get_address() {
        STRING *addr;
        addr = Parrot_sprintf_c(INTERP, "%p", SELF);
        RETURN(STRING *addr);
    }
}

static
opcode_t *
stub_object_invoke(PARROT_INTERP, PMC *pmc, opcode_t *dest) {
    PMC *instr_vt, *data;
    void *orig_vtable;
    Parrot_Interp supervisor;
    PMC *temp;
    PMC *params;
    opcode_t* ret;

    instr_vt = (PMC *) parrot_hash_get(interp, vtable_registry, pmc->vtable);

    GETATTR_InstrumentVtable_original_struct(interp, instr_vt, orig_vtable);
    GETATTR_InstrumentVtable_supervisor(interp, instr_vt, supervisor);

    params = Parrot_pmc_new(supervisor, enum_class_ResizablePMCArray);
    VTABLE_push_pmc(supervisor, params, pmc);
    temp = Parrot_pmc_new(supervisor, enum_class_Pointer);
    VTABLE_set_pointer(supervisor, temp, next);
    VTABLE_push_pmc(supervisor, params, temp);


    data = Parrot_pmc_new(supervisor, enum_class_Hash);
    VTABLE_set_pmc_keyed_str(supervisor, data,
        CONST_STRING(supervisor, "parameters"),
        params);

    raise_vtable_event(supervisor, interp, instr_vt, pmc, data,
                   CONST_STRING(supervisor, "main"),
                   CONST_STRING(supervisor, "invoke"));


    ret = ((_vtable *)orig_vtable)->invoke(interp, pmc, next);
    return ret;
}

/*

=back

*/


/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
