/*
Copyright (C) 2010, Parrot Foundation.
$Id$

=head1 NAME

src/dynpmc/instrumentclass.pmc - Interface to instrument a class's methods.

=head1 DESCRIPTION

C<InstrumentClass> extends InstrumentVtable and provides methods to
instrument a class's methods. Generally methods are invokables, so
to know when a method is called, simply instrumenting the invoke vtable
entry of the method is enough.

=head2 Methods

=over 4

=cut

*/

#include "pmc_instrument.h"
#include "pmc/pmc_class.h"

pmclass InstrumentClass auto_attrs dynpmc group instrument_group extends InstrumentVtable {
    ATTR PMC *instrumented_methods;

/*

=item C<void init_pmc(PMC *instrument)>

Perform a partial initialization. The remaining attributes are initialised
upon calling 'attach_to_class' in PARENT.

=cut

*/

    VTABLE void init_pmc(PMC *instrument) {
        Parrot_InstrumentClass_attributes * const attr = PARROT_INSTRUMENTCLASS(SELF);
        SUPER(instrument);

        attr->instrumented_methods = Parrot_pmc_new(INTERP, enum_class_Hash);
    }

/*

=item C<PMC* get_method_list()>

Returns a list of methods in the class that InstrumentClass is attached to.

=cut

*/

    METHOD get_method_list() {
        Parrot_InstrumentClass_attributes * const attr = PARROT_INSTRUMENTCLASS(SELF);
        PMC *_class;
        PMC *methods, *method_list;
        PMC *iter;
        Parrot_Interp supervised;

        GETATTR_Instrument_supervised(INTERP, attr->instrument, supervised);

        _class  = Parrot_oo_get_class_str(supervised, attr->class_name);
        methods = VTABLE_inspect_str(supervised, _class, CONST_STRING(INTERP, "methods"));

        method_list = Parrot_pmc_new(INTERP, enum_class_ResizableStringArray);
        iter        = VTABLE_get_iter(supervised, methods);

        while (VTABLE_get_bool(supervised, iter)) {
            PMC *key;

            key = VTABLE_shift_pmc(supervised, iter);
            VTABLE_push_pmc(INTERP, method_list, key);
        }

        RETURN(PMC *method_list);
    }

/*

=item C<void insert_method_hook(STRING *method)>

Instruments the method by the given name to raise an event when it
is called.

=cut

*/

    METHOD insert_method_hook(STRING *method) {
        Parrot_InstrumentClass_attributes * const attr = PARROT_INSTRUMENTCLASS(SELF);
        PMC *_class, *methods, *method_sub;
        PMC *instr_obj, *rename, *rename_hash;
        STRING *invoke;
        INTVAL count;
        Parrot_Interp supervised;

        invoke = CONST_STRING(INTERP, "invoke");

        GETATTR_Instrument_supervised(INTERP, attr->instrument, supervised);

        _class  = Parrot_oo_get_class_str(supervised, attr->class_name);
        GETATTR_Class_methods(supervised, _class, methods);
        method_sub     = VTABLE_get_pmc_keyed_str(supervised, methods, method);

        /* Ensure that method exists. */
        if (PMC_IS_NULL(method_sub)) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                        "Class %Ss does not have a method named %Ss.",
                                        attr->class_name, method);
        }

        /* Check the count for this method. */
        count = VTABLE_get_integer_keyed_str(INTERP, attr->instrumented_methods, method);
        if (count == 0) {
            /* Method was not instrumented before. */
            PMC *invokable, *event;
            INTVAL type;

            type     = Parrot_pmc_get_type_str(INTERP, CONST_STRING(INTERP, "InstrumentInvokable"));
            invokable= Parrot_pmc_new_init(INTERP, type, attr->instrument);

            event    = VTABLE_clone(INTERP, attr->event_prefix);
            VTABLE_push_string(INTERP, event, CONST_STRING(INTERP, "method"));
            VTABLE_push_string(INTERP, event, method);

            () = PCCINVOKE(INTERP, invokable, "set_event", PMC *event);

            VTABLE_set_pointer(INTERP, invokable, method_sub);

            VTABLE_set_pmc_keyed_str(supervised, methods, method, invokable);
        }

        /* Update count. */
        count++;
        VTABLE_set_integer_keyed_str(INTERP, attr->instrumented_methods, method, count);
    }

/*

=item C<void remove_method_hook(STRING *method)>

Removes the instrumentation of the given method.

=cut

*/

    METHOD remove_method_hook(STRING *method) {
        Parrot_InstrumentClass_attributes * const attr = PARROT_INSTRUMENTCLASS(SELF);
        PMC *_class, *methods, *method_sub;
        PMC *instr_obj, *rename_hash;
        STRING *invoke;
        INTVAL count;
        Parrot_Interp supervised;

        GETATTR_Instrument_supervised(INTERP, attr->instrument, supervised);

        _class  = Parrot_oo_get_class_str(supervised, attr->class_name);
        GETATTR_Class_methods(supervised, _class, methods);
        method_sub     = VTABLE_get_pmc_keyed_str(supervised, methods, method);

        /* Ensure that method exists. */
        if (PMC_IS_NULL(method_sub)) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                        "Class %Ss does not have a method named %Ss.",
                                        attr->class_name, method);
        }

        /* Check the count for this method. */
        count = VTABLE_get_integer_keyed_str(INTERP, attr->instrumented_methods, method);
        if (count == 0) {
            /* Not instrumented before. */
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                                                "%Ss : No hook for method '%Ss' to remove.",
                                                VTABLE_name(INTERP, SELF), method);
        }
        else if (count == 1) {
            /* Remove the instrumentation. */
            PMC *orig_method_sub;

            orig_method_sub = (PMC *) VTABLE_get_pointer(INTERP, method_sub);
            VTABLE_set_pmc_keyed_str(supervised, methods, method, orig_method_sub);
        }

        /* Update count. */
        count--;
        VTABLE_set_integer_keyed_str(INTERP, attr->instrumented_methods, method, count);
    }

/*

=item C<PMC* get_instrumented_method_list()>

Returns a list of methods that has active instrumentation.

=cut

*/

    METHOD get_instrumented_method_list() {
        Parrot_InstrumentClass_attributes * const attr = PARROT_INSTRUMENTCLASS(SELF);
        PMC *list, *iter;

        list = Parrot_pmc_new(INTERP, enum_class_ResizableStringArray);

        iter = VTABLE_get_iter(INTERP, attr->instrumented_methods);
        while (VTABLE_get_bool(INTERP, iter)) {
            PMC *key;
            INTVAL count;

            key = VTABLE_shift_pmc(INTERP, iter);
            count = VTABLE_get_integer_keyed(INTERP, attr->instrumented_methods, key);

            if (count > 0) {
                VTABLE_push_pmc(INTERP, list, key);
            }
        }

        RETURN(PMC *list);
    }
}

/*

=back

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
