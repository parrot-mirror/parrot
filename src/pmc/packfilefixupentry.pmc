/*
Copyright (C) 2006, The Perl Foundation.
$Id: sub.pmc 15165 2006-11-07 16:09:06Z tewk $

=head1 NAME

src/pmc/packfilefixupentry.pmc - Packfile Fixup Entry

=head1 DESCRIPTION

Holds and allows manipulatin of a Packfile fixup entry.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

/* Data used:
 *   PMC_struct_val ... Packfile_FixupEntry
 */
pmclass PackfileFixupEntry {
/*

=item C<void init()>

Initializes the packfile

=cut

*/
    void init () {
       /* Create and set up the FixupEntry structure. */
        struct Parrot_PackFile_FixupEntry * const fixup =
          mem_sys_allocate(sizeof(struct Parrot_PackFile_FixupEntry));
        if (!fixup) {
            PIO_eprintf(NULL, "PackFileFixupEntry_new: Unable to allocate!\n");
            return;
        }
        PMC_struct_val(SELF) = fixup;

        /* Need custom mark/destroy. */
        PObj_custom_mark_destroy_SETALL(SELF);
    }

/*

=item C<void destroy()>

Destroys the packfile.

=cut

*/
    void destroy () {
        struct Parrot_PackFile_FixupEntry *entry =
            (struct Parrot_PackFile_FixupEntry*)PMC_struct_val(SELF);
    if (entry) {
        mem_sys_free(entry);
    }
}

/*

=item C<void mark()>

Marks the packfile for GC purposes.

=cut

*/
    void mark () {
        struct Parrot_PackFile_FixupEntry *entry =
            (struct Parrot_PackFile_FixupEntry*)PMC_struct_val(SELF);
        if (entry) {
        }
    }

/*

=item C<STRING* pack()>

Packs this segment into a binary representation. Returns NULL on failure.

=cut

*/
    METHOD STRING* pack()
    {
        STRING* result;
        opcode_t *cursor;
        struct Parrot_PackFile_FixupEntry *entry =
            (struct Parrot_PackFile_FixupEntry*)PMC_struct_val(SELF);
        if (!entry) {
            PIO_eprintf(interpreter, "PackFile_FixupEntry_unpack: entry == NULL!\n");
            return 0;
        }

        result = string_make_empty(INTERP, enum_stringrep_one, 3 * sizeof(opcode_t));
        cursor = result->strstart;

        *cursor++ = (opcode_t) entry->type;
        switch (entry->type) {
            case enum_fixup_label:
            case enum_fixup_sub:
                *cursor++ = (opcode_t) entry->name_const_offset;
                *cursor++ = (opcode_t) entry->offset;
                break;
            case enum_fixup_none:
                break;
            default:
                internal_exception(1, "Unknown fixup type\n");
                return 0;
        }
        return result;
    }

/*

=item C<int unpack(STRING* image)>

Unpacks the given binary representation of the segment and sets this PMC to
hold it. Returns a non-zero value on success.

=cut

*/
    METHOD int unpack(STRING* image)
    {
        opcode_t *cursor = image->strstart;
        int size;
        int i;
        struct PackFile * pf;
        struct Parrot_PackFile_FixupEntry *entry =
            (struct Parrot_PackFile_FixupEntry*)PMC_struct_val(SELF);
        if (!entry) {
            PIO_eprintf(interpreter, "PackFile_FixupEntry_unpack: entry == NULL!\n");
            return 0;
        }

        //PackFile_FixupEntry_clear(interpreter, entry);

        entry->type = PF_fetch_opcode(pf, &cursor);
        switch (entry->type) {
            case enum_fixup_label:
            case enum_fixup_sub:
                entry->name_const_offset = PF_fetch_opcode(pf, &cursor);
                entry->offset = PF_fetch_opcode(pf, &cursor);
                break;
            case enum_fixup_none:
                break;
            default:
                PIO_eprintf(interpreter,
                        "PackFile_FixupEntry_unpack: Unknown fixup type %d!\n",
                        entry->type);
                return 0;
        }
        return 0;
    }
/*

=item C<INVVAL type()>

returns type

=cut

*/
    METHOD INTVAL type()
    {
        return ((Parrot_PackFile_FixupEntry*)PMC_struct_val(SELF))->type;
    }
/*

=item C<INTVAL name_const_offset()>

returns type

=cut

*/
    METHOD INTVAL name_const_offset()
    {
        return ((Parrot_PackFile_FixupEntry*)PMC_struct_val(SELF))->name_const_offset;
    }
/*

=item C<INTVAL offset()>

returns type

=cut

*/
    METHOD INTVAL offset()
    {
        return ((Parrot_PackFile_FixupEntry*)PMC_struct_val(SELF))->offset;
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
