/*
Copyright (C) 2008, The Perl Foundation.
$Id: $

=head1 NAME

src/pmc/filehandle.pmc - FileHandle PMC

=head1 DESCRIPTION

The FileHandle PMC performs I/O operations on a source or destination file.

=head2 Vtable Functions

=over 4

=cut

*/

#include "parrot/parrot.h"


pmclass FileHandle need_ext {
    ATTR INTVAL mode;                 /* Read/Write/etc.            */
    ATTR INTVAL flags;                /* Additional flags           */
    ATTR PIOHANDLE os_handle;         /* Low level OS descriptor    */
    ATTR PIOOFF_T file_size;          /* Current file size          */
    ATTR PIOOFF_T file_pos;           /* Current real file pointer  */
    ATTR PIOOFF_T last_pos;           /* Last file position         */
    ATTR size_t buffer_size;          /* Buffer size                */
    ATTR INTVAL buffer_flags;         /* Buffer flags               */
    ATTR unsigned char *buffer_start; /* Start of buffer            */
    ATTR unsigned char *buffer_end;   /* End of buffer              */
    ATTR unsigned char *buffer_next;  /* Current read/write pointer */

/*

=item C<void init()>

Initializes a newly created FileHandle object.

=cut

*/

    VTABLE void init() {
        Parrot_FileHandle_attributes *data_struct =
                mem_allocate_typed(Parrot_FileHandle_attributes);

        PMC_data(SELF)            = data_struct;
        data_struct->mode         = 0;
        data_struct->flags        = 0;
        data_struct->file_size    = 0;
        data_struct->file_pos     = piooffsetzero;
        data_struct->last_pos     = piooffsetzero;
        data_struct->buffer_flags = 0;
        data_struct->buffer_size  = 0;
        data_struct->buffer_start = NULL;
        data_struct->buffer_end   = NULL;
        data_struct->buffer_next  = NULL;

        /* Initialize the os_handle to the platform-specific value for closed. */
#ifdef PIO_OS_WIN32
        data_struct->os_handle    = (PIOHANDLE)INVALID_HANDLE_VALUE;
#endif
#ifdef PIO_OS_UNIX
        data_struct->os_handle    = (PIOHANDLE)-1;
#endif
#ifdef PIO_OS_STDIO
        data_struct->os_handle    = (PIOHANDLE)NULL;
#endif


        PObj_active_destroy_SET(SELF);
    }

/*

=item C<PMC *clone()>

Create a copy of the filehandle.

=cut

*/

    VTABLE PMC *clone() {
        Parrot_FileHandle_attributes * const old_struct  = PARROT_FILEHANDLE(SELF);
        PMC * const copy = Parrot_io_new_pmc(interp, old_struct->flags, old_struct->mode);
        Parrot_FileHandle_attributes * const data_struct = PARROT_FILEHANDLE(SELF);

        data_struct->os_handle    = Parrot_dup(old_struct->os_handle);

        return copy;
    }

/*

=item C<void destroy()>

Free structures.

=cut

*/
    VTABLE void destroy() {
        if (PARROT_FILEHANDLE(SELF)) {
            mem_sys_free(PARROT_FILEHANDLE(SELF));
            PMC_data(SELF) = NULL;
        }
    }


/*

=back

=head2 Methods

=over 4

=item C<METHOD open(STRING *path, STRING *mode :optional)>

Opens the file at the given path with the given mode. The invocant is modified
and becomes an open filehandle. A copy of the invocant is also returned by the
method (some subclasses may use this as the primary filehandle, rather than
modifying the invocant).

=cut

*/

    METHOD open(STRING *path, STRING *mode :optional, INTVAL got_mode :opt_flag) {
        PMC *filehandle;

        if (!Parrot_io_is_closed(INTERP, SELF))
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_PIO_ERROR,
                                "Filehandle is already open");

        if (got_mode)
            filehandle = Parrot_io_open(INTERP, SELF, path, mode);
        else
            filehandle = Parrot_io_open(INTERP, SELF, path, NULL);

        RETURN(PMC *filehandle);
    }

/*

=item C<METHOD close()>

Close the filehandle.

=cut

*/

    METHOD close() {

        Parrot_io_close(INTERP, SELF);
    }

/*

=back

=cut

*/

} /* end pmclass */

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
