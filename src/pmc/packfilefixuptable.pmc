/*
Copyright (C) 2001-2008, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/packfilefixuptable.pmc - PackfileFixupTable PMC

=head1 DESCRIPTION

This class implements a PackfileFixupTable object, a segment of the .pbc
data file storing an array of PackfileFixupEntry PMCs.

See packfile.pmc for the toplevel Packfile interface, see packfilesegment.pmc
for the list of common methods every packfile segment pmc must implement; see
PDD13 for the design spec.


=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass PackfileFixupTable extends PackfileSegment {
    /* RPA of entries */
    ATTR PMC *entries;

/*

=item C<init>

Create empty PackfileFixupTable.

=cut

*/

    VTABLE void init() {
        Parrot_PackfileFixupTable_attributes * attrs =
                mem_allocate_zeroed_typed(Parrot_PackfileFixupTable_attributes);

        attrs->entries = pmc_new(interp, enum_class_ResizablePMCArray);

        PObj_custom_mark_destroy_SETALL(SELF);
        PMC_data(SELF) = attrs;
    }

/*

=item C<void mark()>

Marks the object as live. 

=cut

*/

    VTABLE void mark() {
        Parrot_PackfileFixupTable_attributes * attrs =
                PARROT_PACKFILEFIXUPTABLE(SELF);

        if (attrs->entries)
            pobject_lives(interp, (PObj *)attrs->entries);
    }

/*

=item C<void destroy()>

Destroys the PMC and frees all allocated memory.

=cut

*/

    VTABLE void destroy() {
        Parrot_PackfileFixupTable_attributes * attrs =
                PARROT_PACKFILEFIXUPTABLE(SELF);

        if (attrs) {
            mem_sys_free(attrs);
            PMC_data(SELF) = NULL;
        }
    }



/*

=item C<set_pointer>

=cut

*/

    VTABLE void set_pointer(void * pointer) {
    }

/*

=item C<void *get_pointer()>
=cut

*/
    VTABLE void *get_pointer() {
        Parrot_PackfileFixupTable_attributes * attrs =
                PARROT_PACKFILEFIXUPTABLE(SELF);
        PackFile_FixupTable * pftable = 
                mem_allocate_zeroed_typed(PackFile_FixupTable);

        pftable->base.type = PF_FIXUP_SEG;

        /* TODO: Copy all entries */

        return pftable;
    }


/*

=item C<INTVAL elements()>

Get the number of elements in the array.

=cut

*/
    VTABLE INTVAL elements() {
        PackFile_FixupTable *pftable = PMC_data_typed(SELF, PackFile_FixupTable *);
        return pftable->fixup_count;
    }


/*

=item C<PMC *get_pmc_keyed_int(INTVAL index)>

Fetch the given PackfileFixupEntry PMC.

=cut

*/
    VTABLE PMC *get_pmc_keyed_int(INTVAL index)  {
        PackFile_FixupTable *pftable = PMC_data_typed(SELF, PackFile_FixupTable *);
        PMC *rv;
        if (index < 0 || index >= pftable->fixup_count)
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_OUT_OF_BOUNDS,
                    "Requested data out of range.");
        rv = pmc_new(interp, enum_class_PackfileFixupEntry);
        PMC_data(rv) = pftable->fixups[index];
        return rv;
    }


/*

=item C<void set_pmc_keyed_int(INTVAL index, PMC *value)>

Store a PackfileFixupEntry PMC to the given slot.

=cut

*/
    VTABLE void set_pmc_keyed_int(INTVAL index, PMC *value)  {
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_UNIMPLEMENTED, "Not implemented yet.");
    }


}
/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
