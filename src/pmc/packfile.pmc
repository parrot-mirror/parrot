/*
Copyright (C) 2001-2008, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/packfile.pmc - Packfile PMC

=head1 DESCRIPTION

This class implements a Packfile object, as specified in PDD13.  This object is
the top level parser and serializer for *.pbc files.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "pmc_packfiledirectory.h"

pmclass Packfile {

    /* Copy of packed string. PackFile doesn't own packed data */
    ATTR STRING             *packed;
    /* PackFile by it self */
    ATTR struct PackFile    *pf; 

/*

=item C<void init()>

Initialize the structure.  (Create a blank PackFile object.)

=cut

*/
    VTABLE void init() {
        Parrot_Packfile_attributes *attrs =
            mem_allocate_zeroed_typed(Parrot_Packfile_attributes);

        attrs->packed = Parrot_str_new_noinit(INTERP, enum_stringrep_one, 0);
        attrs->pf = PackFile_new(interp, 0);
        PMC_data(SELF) = attrs;

        PObj_custom_mark_destroy_SETALL(SELF);
    }


/*

=item C<void destroy()>

Destroys the PackFile object.

=cut

*/

    VTABLE void destroy() {
        Parrot_Packfile_attributes * attrs = PARROT_PACKFILE(SELF);
        PackFile_destroy(interp, attrs->pf);
        mem_sys_free(attrs);
    }

/*

=item C<void mark()>

Marks the Packfile as alive.

=cut

*/

    VTABLE void mark() {
        Parrot_Packfile_attributes * attrs = PARROT_PACKFILE(SELF);

        if (attrs->packed)
            pobject_lives(INTERP, (PObj *)attrs->packed);
    }
/*

=item C<STRING *get_string()>

Return raw serialized PBC file data.

=cut

*/
    VTABLE STRING *get_string() {
        Parrot_Packfile_attributes * attrs = PARROT_PACKFILE(SELF);
        opcode_t length = PackFile_pack_size(interp, attrs->pf) * sizeof (opcode_t);
        opcode_t *ptr = (opcode_t*)mem_sys_allocate(length);
        STRING *str;
        PackFile_pack(interp, attrs->pf, ptr);
        str = Parrot_str_new_init(interp, (const char*)ptr, length,
                PARROT_FIXED_8_ENCODING, PARROT_BINARY_CHARSET, 0);
        mem_sys_free(ptr);
        return str;
    }

/*

=item C<void set_string_native(STRING *str)>

Parse raw serialized PBC file data into the Packfile data structure.

=cut

Implementation note: taken from the bottom end of Parrot_pbc_read().
*/
    VTABLE void set_string_native(STRING *str) {
        Parrot_Packfile_attributes * attrs = PARROT_PACKFILE(SELF);
        const opcode_t *ptr;
        int length;
        
        /* Copy string to SELF to prevent collect it */
        attrs->packed = Parrot_str_copy(INTERP, str);

        ptr = (const opcode_t*)Parrot_string_cstring(interp, attrs->packed);
        length = Parrot_str_byte_length(interp, str);
        if (!PackFile_unpack(interp, attrs->pf, ptr, length))
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_MALFORMED_PACKFILE,
                                        "Can't unpack packfile.");

        /* Set :main routine */
        do_sub_pragmas(interp, attrs->pf->cur_cs, PBC_PBC, NULL);
    }


/*

=item C<INTVAL get_integer_keyed_str(STRING *key)>

Fetch an integer keyed value from the packfile object.  Valid keys are:

=over 4

=item wordsize

=item byteorder

=item fptype

=item version_major

=item version_minor

=item version_patch

=item bytecode_major

=item bytecode_minor

=item uuid_type

=item uuid_length

=back

=cut

*/
    VTABLE INTVAL get_integer_keyed_str(STRING *key) {
        PackFile *pf;
        GET_ATTR_pf(INTERP, SELF, pf);
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "wordsize")))
            return pf->header->wordsize;
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "byteorder")))
            return pf->header->byteorder;
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "fptype")))
            return pf->header->floattype;
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "version_major")))
            return pf->header->major;
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "version_minor")))
            return pf->header->minor;
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "version_patch")))
            return pf->header->patch;
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "bytecode_major")))
            return pf->header->bc_major;
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "bytecode_minor")))
            return pf->header->bc_minor;
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "uuid_type")))
            return pf->header->uuid_type;
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "uuid_length")))
            return pf->header->uuid_size;

        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_KEY_NOT_FOUND,
                       "Packfile: No such integer key \"%s\"",
                       Parrot_string_cstring(interp, key));
    }

/*

=item C<STRING *get_string_keyed_str(STRING *key)>

Fetch a string keyed value from the packfile object.  Valid keys are:

=over 4

=item uuid

=back

=cut

*/
    VTABLE STRING *get_string_keyed_str(STRING *key) {
        PackFile *pf;
        GET_ATTR_pf(INTERP, SELF, pf);
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "uuid")))
            return Parrot_str_new(interp, (char*)pf->header->uuid_data, pf->header->uuid_size);

        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_KEY_NOT_FOUND,
                       "Packfile: No such string key \"%s\"",
                       Parrot_string_cstring(interp, key));
    }


/*

=item C<INTVAL get_integer_keyed(PMC *key)>

Fetch a keyed integer value from the packfile object.  Dispatches to
get_integer_keyed_str.

=cut

*/
    VTABLE INTVAL get_integer_keyed(PMC *key) {
        STRING * const s = VTABLE_get_string(INTERP, key);
        return SELF.get_integer_keyed_str(s);
    }


/*

=item C<STRING *get_string_keyed(PMC *key)>

Fetch a keyed string value from the packfile object.  Dispatches to
get_string_keyed_str.

=cut

*/
    VTABLE STRING *get_string_keyed(PMC *key) {
        STRING * const s = VTABLE_get_string(INTERP, key);
        return SELF.get_string_keyed_str(s);
    }

/*

=item C<void set_integer_keyed_str(STRING *key, INTVAL value)>

Set an integer keyed value to the specified value.  Valid keys are:

=over 4

=item version_major

=item version_minor

=item version_patch

=item uuid_type

=back

=cut

*/
    VTABLE void set_integer_keyed_str(STRING *key, INTVAL value) {
        PackFile *pf;
        GET_ATTR_pf(INTERP, SELF, pf);
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "version_major"))) {
            pf->header->major = value;
            return;
        }
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "version_minor"))) {
            pf->header->minor = value;
            return;
        }
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "version_patch"))) {
            pf->header->patch = value;
            return;
        }
        if (!Parrot_str_compare(interp, key, CONST_STRING(interp, "uuid_type"))) {
            pf->header->uuid_type = value;
            return;
        }
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_KEY_NOT_FOUND,
                       "Packfile: No such integer key \"%s\"",
                       Parrot_string_cstring(interp, key));
    }


/*

=item C<void set_integer_keyed(PMC *key, INTVALval)>

Set a keyed integer value in the packfile object.  Dispatches to
set_integer_keyed_str.

=cut

*/
    VTABLE void set_integer_keyed(PMC *key, INTVAL val) {
        STRING * const s = VTABLE_get_string(INTERP, key);
        SELF.set_integer_keyed_str(s, val);
    }

/*

=item C<STRING * pack()>

Return raw serialized PBC file data. Synonym for get_string.

=cut

*/

    METHOD STRING *pack() {
        STRING * ret = SELF.get_string();
        RETURN(STRING * ret);
    }

/*

=item C<STRING * unpack()>

Parse raw serialized PBC file data into the Packfile data structure.
Synonym for set_string.

=cut

*/
    
    METHOD void unpack(STRING *str) {
        SELF.set_string_native(str);
    }

/*

=item C<PMC *get_directory()>

Fetch the PackfileDirectory PMC that represents the directory segment at the
start of the packfile.

=cut

*/
    METHOD get_directory() {
        Parrot_Packfile_attributes * attrs = PARROT_PACKFILE(SELF);
        PMC *dir = pmc_new(interp, enum_class_PackfileDirectory);
        PMC_data(dir) = &attrs->pf->directory;
        RETURN(PMC *dir);
    }


}
/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
