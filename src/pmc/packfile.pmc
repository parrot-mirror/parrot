/*
Copyright (C) 2006, The Perl Foundation.
$Id: $

=head1 NAME

src/pmc/packfile.pmc - Packfile

=head1 DESCRIPTION

This PMC represents a pack file.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

/* Data used:
 *   PMC_struct_val ... Parrot_PackFile
 */
pmclass Packfile need_ext {

/*

=item C<void init()>

Initializes the packfile

=cut

*/
    void init() {
        /* Create and set up the packfile structure. */
        struct Parrot_PackFile* pf =
            mem_sys_allocate_zeroed(sizeof(struct Parrot_PackFile*));
        if (!pf) {
            PIO_eprintf(NULL, "PackFile_new: Unable to allocate!\n");
            return;
        }
        PMC_struct_val(SELF) = pf;
        
        /* Allocate the header. */
        pf->header = mem_sys_allocate_zeroed(sizeof(struct Parrot_PackFile_Header*));
        if (!pf->header) {
            PIO_eprintf(NULL, "PackFile_new: Unable to allocate header!\n");
            SELF.destroy();
            return;
        }

        /* Set magic in header. */
        memcpy(pf->header->magic, "\xfe\x50\x42\x43\x0d\x0a\x1a\x0a", 8);
        
        /* Set sizes. */
        pf->header->wordsize = sizeof(opcode_t);
        pf->header->byteorder = PARROT_BIGENDIAN;
        if (NUMVAL_SIZE == 8)
            pf->header->floattype = 0;
        else /* if XXX */
            pf->header->floattype = 1;
        
        /* Set Parrot version. */
        pf->header->parrot_major = PARROT_MAJOR_VERSION;
        pf->header->parrot_minor = PARROT_MINOR_VERSION;
        pf->header->parrot_patch = PARROT_PATCH_VERSION;

        /* XXX Bytecode version to do. */
        pf->header->bytecode_major = 0;
        pf->header->bytecode_minor = 1;

        /* UUID - default to none. */
        pf->header->uuid_type = PARROT_UUID_TYPE_NONE;
        pf->header->uuid_length = 0;
        pf->header->uuid_value = NULL;
        
        /* Create a directory PMC. */
        pf->directory = pmc_new(interpreter, enum_class_PackfileDirectory);

        /* Need custom mark/destroy. */
        PObj_custom_mark_destroy_SETALL(SELF);
    }

/*

=item C<void destroy()>

Destroys the packfile.

=cut

*/
    void destroy () {
        struct Parrot_PackFile *pf = (struct Parrot_PackFile*)PMC_struct_val(SELF);
        if (pf) {
#ifdef PARROT_HAS_HEADER_SYSMMAN
            if (pf->is_mmap_ped)
                munmap((void*)pf->src, pf->size);
#endif
            if (pf->header)
                mem_sys_free(pf->header);
            mem_sys_free(pf);
            return;
        }
    }

/*
=item C<void mark()>

Marks the packfile for GC purposes.

=cut

*/
    void mark () {
        struct Parrot_PackFile *pf = (struct Parrot_PackFile*)PMC_struct_val(SELF);
        if (pf) {
            if (pf->directory)
                pobject_lives(interpreter, (PObj*)pf->directory);
        }
    }

/*
=item C<STRING* get_string()>

Packs the PackFile structure into a binary representatoin and returns
the string, ready for writing to a file.

=cut

*/
    STRING* get_string() {
        struct Parrot_PackFile *pf = (struct Parrot_PackFile*)PMC_struct_val(SELF);
        STRING* result = NULL;
        opcode_t* cursor;
        int header_length;
        STRING* dir_method_name;
        PMC* dir_meth;
        STRING *dir_packed;

        /* Allocate space for header. */
        header_length = PACKFILE_HEADER_BYTES + pf->header->uuid_length;
        header_length = header_length % 16 == 0 ? header_length :
            header_length + (16 - (header_length % 16));
        result = string_make_empty(INTERP, enum_stringrep_one, 
            header_length + 4 * sizeof(opcode_t));
        cursor = result->strstart;
        
        /* Pack the header. */
        pf->src = cursor;
        PackFile_Header_Pack(interpreter, cursor, pf);
        cursor = (opcode_t*)((char*)cursor + header_length);
        
        /* Store the directory format. */
        *cursor++ = PARROT_PF_DIR_FORMAT;
        *cursor++ = 0;
        *cursor++ = 0;
        *cursor++ = 0;

        /* Pack the directory itself, which also packs other stuff. */
        dir_method_name = CONST_STRING(INTERP, "pack");
        dir_meth = VTABLE_find_method(INTERP, pf->directory, dir_method_name);
        dir_packed = (STRING*)Parrot_call_method(INTERP, dir_meth, pf->directory,
            dir_method_name, "IJO");

        /* Append. */
        result = string_append(INTERP, result, dir_packed);
        
        /* Return packed data. */
        return result;
    }

/*
=item C<set_string_native(STRING* packed)>

Takes a string that contains a serialized PackFile and tries to unpack it
into the current PMC. If it fails, the state of the PMC will be invalidated.

=cut

*/
    void set_string_native(STRING* packed) {

    }

 /*
=item C<intval get_integer_keyed_str(STRING* field)>

Used to get data about fields in the header that have an integer value.

=cut

*/

    INTVAL get_integer_keyed_str(STRING* field) {
        struct Parrot_PackFile *pf = (struct Parrot_PackFile*)PMC_struct_val(SELF);

        if (string_equal(INTERP, field, CONST_STRING(INTERP, "wordsize")))
            return pf->header->wordsize;
        if (string_equal(INTERP, field, CONST_STRING(INTERP, "byteorder")))
            return pf->header->byteorder;
        if (string_equal(INTERP, field, CONST_STRING(INTERP, "floattype")))
            return pf->header->floattype;
        if (string_equal(INTERP, field, CONST_STRING(INTERP, "parrot_major")))
            return pf->header->parrot_major;
        if (string_equal(INTERP, field, CONST_STRING(INTERP, "parrot_minor")))
            return pf->header->parrot_minor;
        if (string_equal(INTERP, field, CONST_STRING(INTERP, "parrot_patch")))
            return pf->header->parrot_patch;
        if (string_equal(INTERP, field, CONST_STRING(INTERP, "bytecode_major")))
            return pf->header->bytecode_major;
        if (string_equal(INTERP, field, CONST_STRING(INTERP, "bytecode_minor")))
            return pf->header->bytecode_minor;
        if (string_equal(INTERP, field, CONST_STRING(INTERP, "uuid_type")))
            return pf->header->uuid_type;
        if (string_equal(INTERP, field, CONST_STRING(INTERP, "uuid_length")))
            return pf->header->uuid_length;
        else {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "No such field");
            return 0;
        }
    }   

/*
=item C<STRING* get_string_keyed_str(STRING* key)>

Used to get data about fields in the header that have a string value.

=cut
*/
    STRING* get_string_keyed_str(STRING* key) {
        struct Parrot_PackFile *pf = (struct Parrot_PackFile*)PMC_struct_val(SELF);

        if (string_equal(INTERP, key, CONST_STRING(INTERP, "")))
            return CONST_STRING(INTERP, "");
        else
            return string_from_cstring(INTERP, key, strlen(key));
    }
        
/*
=item C<void set_integer_keyed_str(STRING* key, INTVAL value)>

Used to set fields in the packfile header.  Some fields are not allowed to be written since they
are determined by the VM when serializing the packfile for storage on disk.

=cut
*/  

    void set_integer_keyed_str(STRING* key, INTVAL value) {
        struct Parrot_PackFile *pf = (struct Parrot_PackFile*)PMC_struct_val(SELF);

        if (string_equal(INTERP, key, CONST_STRING(INTERP, "uuid_type"))) {
            pf->header->uuid_type = value;
            return;
        }

        if (value < 0 || value >= 256) {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Version number out of bounds");
            return;
        }

        if (string_equal(INTERP, key, CONST_STRING(INTERP, "parrot_major"))) {
            pf->header->parrot_major = value;
            return;
        }
        if (string_equal(INTERP, key, CONST_STRING(INTERP, "parrot_minor"))) {
            pf->header->parrot_minor = value;
            return;
        }
        if (string_equal(INTERP, key, CONST_STRING(INTERP, "parrot_patch"))) {
            pf->header->parrot_patch = value;
            return;
        }
        else {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "No such field");
            return;
        }
    }

/*
=item C<PMC* get_directory()>

Returns the Packfile Directory PMC that represents the directory segment
at the start of the packfile.

=cut

*/
    METHOD PMC* get_directory() {
        struct Parrot_PackFile *pf = (struct Parrot_PackFile*)PMC_struct_val(SELF);

        if (pf->directory)
            return pf->directory;

        real_exception(INTERP, NULL, OUT_OF_BOUNDS, "No directory available");
        return NULL;
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
