/*
Copyright (C) 2006, The Perl Foundation.
$Id: $

=head1 NAME

src/pmc/packfiledirectory.pmc - Packfile Directory

=head1 DESCRIPTION

Holds and allows manipulation of a Packfile directory.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

/* Data used:
 *   PMC_struct_val ... Parrot_PackFile_Directory
 */
pmclass PackfileDirectory inherits PackfileSegment {
    
/*

=item C<void init()>

Initializes the packfile

=cut

*/
    void init() {
        /* Create and set up the directory structure. */
        struct Parrot_PackFile_Directory* dir =
            mem_sys_allocate_zeroed(sizeof(struct Parrot_PackFile_Directory*));
        if (!dir) {
            PIO_eprintf(NULL, "PackFileDirectory_new: Unable to allocate!\n");
            return;
        }
        PMC_struct_val(SELF) = dir;
        
        /* Parent is NULL to start off with and allocate new arrays of
         * segments and segment names. */
        dir->parent = NULL;
        dir->segments = pmc_new(interpreter, enum_class_ResizablePMCArray);
        dir->segment_names = pmc_new(interpreter, enum_class_ResizableStringArray);

        /* Need custom mark/destroy. */
        PObj_custom_mark_destroy_SETALL(SELF);
    }

/*

=item C<void destroy()>

Destroys the packfile.

=cut

*/
    void destroy () {
        struct Parrot_PackFile_Directory *dir = 
            (struct Parrot_PackFile_Directory*)PMC_struct_val(SELF);
        if (dir) {
            mem_sys_free(dir);
        }
    }

/*

=item C<void mark()>

Marks the packfile for GC purposes.

=cut

*/
    void mark () {
        struct Parrot_PackFile_Directory *dir = 
            (struct Parrot_PackFile_Directory*)PMC_struct_val(SELF);
        if (dir) {
            if (dir->parent)
                pobject_lives(interpreter, (PObj*)dir->parent);
            if (dir->segments)
                pobject_lives(interpreter, (PObj*)dir->segments);
            if (dir->segment_names)
                pobject_lives(interpreter, (PObj*)dir->segment_names);
        }
    }

/*

=item C<INTVAL elements()>

Gets the number of segments that the directory knows about.

=cut

*/
    INTVAL elements() {
        struct Parrot_PackFile_Directory *dir = 
            (struct Parrot_PackFile_Directory*)PMC_struct_val(SELF);
        return VTABLE_elements(INTERP, dir->segments);
    }

/*

=item C<PMC* get_pmc_keyed_int(INTVAL i)>

Get the segment at the given index.

=cut

*/
    PMC* get_pmc_keyed_int(INTVAL i) {
        struct Parrot_PackFile_Directory *dir = 
            (struct Parrot_PackFile_Directory*)PMC_struct_val(SELF);
        if (i < SELF.elements()) {
            return VTABLE_get_pmc_keyed_int(INTERP, dir->segments, i);
        }
        else {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "No such segment");
            return NULL;
        }
    }

/*

=item C<STRING* get_string_keyed_int(INTVAL i)>

Get the name of the segment at the given index.

=cut

*/
    STRING* get_string_keyed_int(INTVAL i) {
        struct Parrot_PackFile_Directory *dir = 
            (struct Parrot_PackFile_Directory*)PMC_struct_val(SELF);
        if (i < SELF.elements()) {
            return VTABLE_get_string_keyed_int(INTERP, dir->segment_names, i);
        }
        else {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "No such segment");
            return NULL;
        }
    }

/*

=item C<PMC* get_pmc_keyed_str(STRING *name)>

Gets the segment with the given name.

=cut

*/
    PMC* get_pmc_keyed_str(STRING *name) {
        struct Parrot_PackFile_Directory *dir = 
            (struct Parrot_PackFile_Directory*)PMC_struct_val(SELF);
        int i;
        PMC* found = NULL;
        for (i = 0; i < SELF.elements(); i++) {
            STRING* test = SELF.get_string_keyed_int(i);
            if (string_equal(INTERP, test, name)) {
                found = SELF.get_pmc_keyed_int(i);
                break;
            }
        }
        if (found) {
            return found;
        }
        else {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "No such segment");
            return NULL;
        }
    }

/*

=item C<void set_pmc_keyed_string(STRING *key, PMC *segment)>

Add a segment with the given name.

=cut

*/
    void set_pmc_keyed_string(STRING *key, PMC *segment) {
        struct Parrot_PackFile_Directory *dir = 
            (struct Parrot_PackFile_Directory*)PMC_struct_val(SELF);

        /* Add to the segments array and names array. */
        VTABLE_push_pmc(INTERP, dir->segments, segment);
        VTABLE_push_string(INTERP, dir->segment_names, key);
    }

/*

=item C<STRING* pack()>

Packs this segment into a binary representation. Returns NULL on failure.

=cut

*/
    METHOD STRING* pack()
    {
        return NULL;
    }

/*

=item C<int unpack(STRING* image)>

Unpacks the given binary representation of the segment and sets this PMC to
hold it. Returns a non-zero value on success.

=cut

*/
    METHOD int unpack(STRING* image)
    {
        return 0;
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
