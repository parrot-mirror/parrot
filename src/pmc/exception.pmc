/*
Copyright (C) 2001-2008, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/exception.pmc - Exception PMC

=head1 DESCRIPTION

This is the exception base class. An exception object has the following
attributes:

=over 4

=item C<message>

Textual representation of the exception.

=item C<severity>

The severity of the exception, (see F<include/parrot/exceptions.h>,
F<except_severity.pasm>).

=item C<type>

The type of the exception.

=item C<exit_code>

The exit code of the exception. (Added temporarily, to be removed.)

=item C<payload>

Additional data for the exception.

=back

When an exception handler is called, the exception object is passed as
as the first argument, the message as the second argument of the call.
These arguments can be retrieved with the C<get_results> opcode.

=cut

*/

#include "parrot/parrot.h"

pmclass Exception {

    ATTR INTVAL    id;         /* The task ID in the scheduler. */
    ATTR FLOATVAL  birthtime;  /* The creation time stamp of the exception. */
    ATTR STRING   *message;    /* The exception message. */
    ATTR PMC      *payload;    /* The payload for the exception. */
    ATTR INTVAL    severity;   /* The severity of the exception. */
    ATTR INTVAL    type;       /* The type of the exception. */
    ATTR INTVAL    exit_code;  /* The exit code of the exception. */
    ATTR PMC      *stacktrace; /* The stacktrace of an exception. */

/*

=head2 Vtable Functions

=over 4

=item C<void init()>

Initializes the exception with default values.

=cut

*/

    VTABLE void init() {
        Parrot_Exception * const core_struct =
            mem_allocate_zeroed_typed(Parrot_Exception);

        /* Set flags for custom DOD mark and destroy. */
        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);

        /* Set up the core struct and default values for the exception object. */
        PMC_data(SELF)          = core_struct;
        core_struct->message    = CONST_STRING(interp, "");
        core_struct->payload    = PMCNULL;
        core_struct->stacktrace = PMCNULL;
    }

/*

=item C<void mark()>

Mark any active exception data as live.

=cut

*/

    VTABLE void mark() {
        Parrot_Exception * const core_struct = PARROT_EXCEPTION(SELF);
        if (core_struct->message)
            pobject_lives(interp, (PObj *)core_struct->message);
        if (core_struct->payload)
            pobject_lives(interp, (PObj *)core_struct->payload);
        if (core_struct->stacktrace)
            pobject_lives(interp, (PObj *)core_struct->stacktrace);
    }

/*

=item C<void destroy()>

Destroys the exception.

=cut

*/

    VTABLE void destroy() {
        Parrot_Exception * const core_struct = PARROT_EXCEPTION(SELF);

        if (core_struct)
            mem_sys_free(core_struct);
    }

/*

=item C<STRING *get_string()>

Return the exception message.

=cut

*/

    VTABLE STRING *get_string() {
        STRING *message;
        GET_ATTR_message(interp, SELF, message);
        return message;
    }

/*

=item C<INTVAL get_integer()>

Returns the id of the exception.

=cut

*/

    VTABLE INTVAL get_integer() {
        Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);
        return exception->id;
    }

/*

=item C<STRING *get_string_keyed(PMC *key)>

Returns the Parrot string value for C<*key>. The only current recognized
C<key> is "message".

=cut

*/

    VTABLE STRING *get_string_keyed(PMC *key) {
        STRING *s = key_string(INTERP, key);
        STRING *message;

        if (string_equal(INTERP, s, CONST_STRING(INTERP, "message")) == 0) {
            GET_ATTR_message(interp, SELF, message);
        }

        return message;
    }

/*

=item C<INTVAL get_integer_keyed(PMC *key)>

Returns the integer value for C<*key>.

=cut

*/

    VTABLE INTVAL get_integer_keyed(PMC *key) {
        STRING *s      = key_string(INTERP, key);
        INTVAL  result = 0;

        if (string_equal(INTERP, s, CONST_STRING(INTERP, "type")) == 0) {
            GET_ATTR_type(interp, SELF, result);
        }
        else if (string_equal(INTERP, s, CONST_STRING(INTERP, "severity")) == 0) {
            GET_ATTR_severity(interp, SELF, result);
        }
        else if (string_equal(INTERP, s, CONST_STRING(INTERP, "exit_code")) == 0) {
            GET_ATTR_exit_code(interp, SELF, result);
        }

        return result;
    }

/*

=item C<INTVAL get_integer_keyed_str(STRING *key)>

Returns the integer value for C<*key>.

=cut

*/

    VTABLE INTVAL get_integer_keyed_str(STRING *key) {
        INTVAL result = 0;

        if (string_equal(INTERP, key, CONST_STRING(INTERP, "type")) == 0) {
            GET_ATTR_type(interp, SELF, result);
        }
        else if (string_equal(INTERP, key, CONST_STRING(INTERP, "severity")) == 0) {
            GET_ATTR_severity(interp, SELF, result);
        }
        else if (string_equal(INTERP, key, CONST_STRING(INTERP, "exit_code")) == 0) {
            GET_ATTR_exit_code(interp, SELF, result);
        }

        return result;
    }

/*

=item C<PMC *get_pmc_keyed(PMC *key)>

Returns the PMC value for C<*key>.

=cut

*/

    VTABLE PMC *get_pmc_keyed(PMC *key) {
        STRING *s = key_string(INTERP, key);
        return SELF.getprop(s);
    }


/*

=item C<void set_string_native(STRING *value)>

Sets the C<message> of the Exception.

=cut

*/

    VTABLE void set_string_native(STRING *value) {
        SET_ATTR_message(interp, SELF, value);
    }


/*

=item C<void set_integer_native(INTVAL *value)>

Sets the C<id> of the Exception.

=cut

*/

    VTABLE void set_integer_native(INTVAL value) {
        SET_ATTR_id(interp, SELF, value);
    }

/*

=item C<void set_number_native(FLOATVAL value)>

Sets the birthtime of the exception.

=cut

*/

    VTABLE void set_number_native(FLOATVAL value) {
        SET_ATTR_birthtime(interp, SELF, value);
    }


/*

=item C<void set_string_keyed(PMC *key, STRING *value)>

Sets the Parrot string value for C<*key>.

=cut

*/

    VTABLE void set_string_keyed(PMC *key, STRING *value) {
        STRING *s = key_string(INTERP, key);

        if (string_equal(INTERP, s, CONST_STRING(INTERP, "message")) == 0)
            SET_ATTR_message(interp, SELF, value);
    }

/*

=item C<void set_integer_keyed(PMC *key, INTVAL value)>

Sets the integer value for C<*key>.

=cut

*/

    VTABLE void set_integer_keyed(PMC *key, INTVAL value) {
        STRING *s = key_string(INTERP, key);

        if (string_equal(INTERP, s, CONST_STRING(INTERP, "type")) == 0) {
            SET_ATTR_type(interp, SELF, value);
        }
        else if (string_equal(INTERP, s, CONST_STRING(INTERP, "severity")) == 0) {
            SET_ATTR_severity(interp, SELF, value);
        }
        else if (string_equal(INTERP, s, CONST_STRING(INTERP, "exit_code")) == 0) {
            SET_ATTR_exit_code(interp, SELF, value);
        }
    }

/*

=item C<void set_integer_keyed_str(STRING *key, INTVAL value) >

Sets the integer value for C<*key>.

=cut

*/

    VTABLE void set_integer_keyed_str(STRING *key, INTVAL value) {
        if (string_equal(INTERP, key, CONST_STRING(INTERP, "type")) == 0) {
            SET_ATTR_type(interp, SELF, value);
        }
        else if (string_equal(INTERP, key, CONST_STRING(INTERP, "severity")) == 0) {
            SET_ATTR_severity(interp, SELF, value);
        }
        else if (string_equal(INTERP, key, CONST_STRING(INTERP, "exit_code")) == 0) {
            SET_ATTR_exit_code(interp, SELF, value);
        }
    }

/*

=item C<void set_pmc_keyed(PMC *key, PMC *value)>

Sets the PMC value for C<*key>.

=cut

*/

    VTABLE void set_pmc_keyed(PMC *key, PMC *value) {
        STRING *s = key_string(INTERP, key);
        SELF.setprop(s, value);
    }
/*

=item C<INTVAL is_equal(PMC *value)>

Compare the passed in Exception with SELF. Returns True if C<SELF> isa C<value>

=cut

*/
    VTABLE INTVAL is_equal(PMC *value) {
        /* RT #46689 check parents */
        if (value->vtable->base_type == enum_class_Exception
        ||  VTABLE_isa(INTERP, value, CONST_STRING(INTERP, "Exception")))
            return 1;

        return 0;
    }

/*

=item C<get_attr_str>

Retrieve an attribute value for the exception object.

=cut

*/
    VTABLE PMC *get_attr_str(STRING *name) {
        PMC *value = PMCNULL;

        if (string_equal(INTERP, name, CONST_STRING(INTERP, "type")) == 0) {
                INTVAL type;
                GET_ATTR_type(interp, SELF, type);
                value = pmc_new(interp, enum_class_Integer);
                VTABLE_set_integer_native(interp, value, type);
        }
        else if (string_equal(INTERP, name, CONST_STRING(INTERP, "severity")) == 0) {
                INTVAL severity;
                GET_ATTR_severity(interp, SELF, severity);
                value = pmc_new(interp, enum_class_Integer);
                VTABLE_set_integer_native(interp, value, severity);
        }
        else if (string_equal(INTERP, name, CONST_STRING(INTERP, "exit_code")) == 0) {
                INTVAL exit_code;
                GET_ATTR_exit_code(interp, SELF, exit_code);
                value = pmc_new(interp, enum_class_Integer);
                VTABLE_set_integer_native(interp, value, exit_code);
        }
        else if (string_equal(INTERP, name, CONST_STRING(INTERP, "message")) == 0) {
                STRING *message;
                GET_ATTR_message(interp, SELF, message);
                value = pmc_new(interp, enum_class_String);
                VTABLE_set_string_native(interp, value, message);
        }
        else if (string_equal(INTERP, name, CONST_STRING(INTERP, "payload")) == 0) {
                GET_ATTR_payload(interp, SELF, value);
        }
        else if (string_equal(INTERP, name, CONST_STRING(INTERP, "stacktrace")) == 0) {
                GET_ATTR_stacktrace(interp, SELF, value);
        }
        else {
            /* If unknown attribute name, throw an exception. */
            Parrot_ex_throw_from_c(interp, NULL, EXCEPTION_ATTRIB_NOT_FOUND,
                "No such attribute '%S'", name);
        }

        return value;
    }

/*

=item C<set_attr_str>

Set an attribute value for the exception object.

=cut

*/
    VTABLE void set_attr_str(STRING *name, PMC *value) {

        if (string_equal(INTERP, name, CONST_STRING(INTERP, "type")) == 0) {
            INTVAL type = VTABLE_get_integer(interp, value);
            SET_ATTR_type(interp, SELF, type);
        }
        else if (string_equal(INTERP, name, CONST_STRING(INTERP, "severity")) == 0) {
            INTVAL severity = VTABLE_get_integer(interp, value);
            SET_ATTR_severity(interp, SELF, severity);
        }
        else if (string_equal(INTERP, name, CONST_STRING(INTERP, "exit_code")) == 0) {
            INTVAL exit_code = VTABLE_get_integer(interp, value);
            SET_ATTR_exit_code(interp, SELF, exit_code);
        }
        else if (string_equal(INTERP, name, CONST_STRING(INTERP, "message")) == 0) {
            STRING *message = VTABLE_get_string(interp, value);
            SET_ATTR_message(interp, SELF, message);
        }
        else if (string_equal(INTERP, name, CONST_STRING(INTERP, "payload")) == 0) {
            SET_ATTR_payload(interp, SELF, value);
        }
        else if (string_equal(INTERP, name, CONST_STRING(INTERP, "stacktrace")) == 0) {
            SET_ATTR_stacktrace(interp, SELF, value);
        }
        else {
            /* If unknown attribute name, throw an exception. */
            Parrot_ex_throw_from_c(interp, NULL, EXCEPTION_ATTRIB_NOT_FOUND,
                "No such attribute '%S'", name);
        }

    }

/*

=item C<PMC *share_ro()>

Set this PMC as shared.

=cut

*/

    VTABLE PMC *share_ro() {
        PMC *shared_self;
        Parrot_Exception *shared_struct;

        if (PObj_is_PMC_shared_TEST(SELF))
            return SELF;

        shared_self = pt_shared_fixup(INTERP, SELF);
        shared_struct = PARROT_EXCEPTION(shared_self);

        if (!PMC_IS_NULL(shared_struct->payload))
            shared_struct->payload = pt_shared_fixup(INTERP, shared_struct->payload);

        if (!PMC_IS_NULL(shared_struct->stacktrace))
            shared_struct->stacktrace = pt_shared_fixup(INTERP, shared_struct->stacktrace);

        return shared_self;
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
