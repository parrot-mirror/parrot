/*
Copyright (C) 2001-2008, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/exception.pmc - Exception PMC

=head1 DESCRIPTION

This is the exception base class.

An exception object has these attributes:

=over 4

=item C<message>

Textual representation of the exception.

=item C<severity>

The severity of the exception, (see F<include/parrot/exceptions.h>,
F<except_severity.pasm>).

=item C<exit_status>

The exit code of the exception.

=item C<payload>

Additional data for the exception.

=back

Optional:

=over 4

=item 5 C<_C_file>

The C code file in which the exception was raised.

=item 6 C<_C_line>

The line of C code on which the exception was raised.

=item 7 C<_P_file>

The PASM/PIR/Perl file in which the exception was raised.

=item 8 C<_P_line>

The line of PASM/PIR/Perl code on which the exception was raised.

=item 9, 10 C<unused>

Any information attached by the HL. This shouldn't start with an
underscore (that is reserved for Parrot's internal usage. These are
stored as properties.

=back

When an exception handler is called, the exception object is passed as
as the first argument, the message as the second argument of the call.
These arguments can be retrieved with the C<get_results> opcode.

=cut

*/

#include "parrot/parrot.h"

/*

=head2 Methods

=over 4

=cut

*/

pmclass Exception extends ResizablePMCArray need_ext {
    ATTR STRING *message;
    ATTR PMC    *payload;
    ATTR INTVAL  severity;
    ATTR INTVAL  exit_code;

/*

=item C<void init()>

Initializes the exception with default values.

=cut

*/

    VTABLE void init() {
        Parrot_Exception * const exception =
            mem_allocate_zeroed_typed(Parrot_Exception);

        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);

        PMC_data(SELF)      = exception;
        exception->message  = CONST_STRING(interp, "");
        exception->severity = 0;
        exception->payload  = PMCNULL;
    }

/*

=item C<void mark()>

Mark any active exception data as live.

=cut

*/

    VTABLE void mark() {
        Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);

        if (exception->message)
            pobject_lives(interp, (PObj *)exception->message);
        if (exception->payload)
            pobject_lives(interp, (PObj *)exception->payload);
    }

/*

=item C<INTVAL get_integer()>

Returns the severity of the exception.

=cut

*/

    VTABLE INTVAL get_integer() {
        Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);
        return exception->severity;
    }

/*

=item C<STRING *get_string_keyed(PMC *key)>

Returns the Parrot string value for C<*key>. The only current recognized
C<key> is "_message".

=item C<STRING *get_string()>

Return the exception message.

=cut

*/

    VTABLE STRING *get_string_keyed(PMC *key) {
        STRING *s = key_string(INTERP, key);

        if (!string_compare(INTERP, s, CONST_STRING(INTERP, "_message"))) {
            Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);
            return exception->message;
        }

        return CONST_STRING(interp, "");
    }

    VTABLE STRING *get_string() {
        Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);
        return exception->message;
    }

/*

=item C<INTVAL get_integer_keyed(PMC *key)>

Returns the integer value for C<*key>.

=cut

*/

    VTABLE INTVAL get_integer_keyed(PMC *key) {
        STRING *s = key_string(INTERP, key);

        if (!string_compare(INTERP, s, CONST_STRING(INTERP, "_severity"))) {
            Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);
            return exception->severity;
        }

        if (!string_compare(INTERP, s, CONST_STRING(INTERP, "exit_code"))) {
            Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);
            return exception->exit_code;
        }

        return 0;
    }

/*

=item C<PMC *get_pmc_keyed(PMC *key)>

Returns the PMC value for C<*key>.

=cut

*/

    VTABLE PMC *get_pmc_keyed(PMC *key) {
        STRING *s = key_string(INTERP, key);
        return SELF.getprop(s);
    }


/*

=item C<void set_string_native(STRING *value)>

Sets the C<message> of the Exception.

=cut

*/

    VTABLE void set_string_native(STRING *value) {
        Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);
        exception->message                 = value;
    }


/*

=item C<void set_integer_native(INTVAL *value)>

Sets the C<severity> of the Exception.

=cut

*/

    VTABLE void set_integer_native(INTVAL value) {
        Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);
        exception->severity                = value;
    }


/*

=item C<void set_string_keyed(PMC *key, STRING *value)>

Sets the Parrot string value for C<*key>.

=cut

*/

    VTABLE void set_string_keyed(PMC *key, STRING *value) {
        STRING *s = key_string(INTERP, key);

        if (!string_compare(INTERP, s, CONST_STRING(INTERP, "_message"))) {
            Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);
            exception->message                 = value;
        }
    }

/*

=item C<void set_integer_keyed(PMC *key, INTVAL value)>

Sets the integer value for C<*key>.

=cut

*/

    VTABLE void set_integer_keyed(PMC *key, INTVAL value) {
        STRING *s = key_string(INTERP, key);

        if (!string_compare(INTERP, s, CONST_STRING(INTERP, "_severity"))) {
            Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);
            exception->severity                = value;
        }

        if (!string_compare(INTERP, s, CONST_STRING(INTERP, "exit_code"))) {
            Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);
            exception->exit_code               = value;
        }
    }

/*

=item C<void set_pmc_keyed(PMC *key, PMC *value)>

Sets the PMC value for C<*key>.

=cut

*/

    VTABLE void set_pmc_keyed(PMC *key, PMC *value) {
        STRING *s = key_string(INTERP, key);
        SELF.setprop(s, value);
    }
/*

=item C<INTVAL is_equal(PMC *value)>

Compare the passed in Exception with SELF. Returns True if C<SELF> isa C<value>

=cut

*/
    VTABLE INTVAL is_equal(PMC *value) {
        /* RT #46689 check parents */
        if (value->vtable->base_type == enum_class_Exception
        ||  VTABLE_isa(INTERP, value, CONST_STRING(INTERP, "Exception")))
            return 1;

        return 0;
    }

/*

=item C<get_attr_str>

Retrieve an attribute value for the exception object.

=cut

*/
    VTABLE PMC *get_attr_str(STRING *name) {
        Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);

        if (!string_compare(interp, name, CONST_STRING(interp, "message"))) {
            PMC *message_pmc = pmc_new(interp, enum_class_String);
            VTABLE_set_string_native(interp, message_pmc, exception->message);
            return message_pmc;
        }

        if (!string_compare(interp, name, CONST_STRING(interp, "severity"))) {
            PMC *severity_pmc = pmc_new(interp, enum_class_Integer);
            VTABLE_set_integer_native(interp, severity_pmc, exception->severity);
            return severity_pmc;
        }

        if (!string_compare(interp, name, CONST_STRING(interp, "exit_code"))) {
            PMC *exit_code_pmc = pmc_new(interp, enum_class_Integer);
            VTABLE_set_integer_native(interp, exit_code_pmc, exception->exit_code);
            return exit_code_pmc;
        }

        if (!string_compare(interp, name, CONST_STRING(interp, "payload")))
            return exception->payload;

        /* If lookup failed, exception. */
        real_exception(interp, NULL, ATTRIB_NOT_FOUND,
            "No such attribute '%S'", name);
    }

/*

=item C<set_attr_str>

Set an attribute value for the exception object.

=cut

*/
    VTABLE void set_attr_str(STRING *name, PMC *value) {
        Parrot_Exception * const exception = PARROT_EXCEPTION(SELF);

        if (!string_compare(interp, name, CONST_STRING(interp, "message"))) {
            exception->message = VTABLE_get_string(interp, value);
            return;
        }

        if (!string_compare(interp, name, CONST_STRING(interp, "severity"))) {
            exception->severity = VTABLE_get_integer(interp, value);
            return;
        }

        if (!string_compare(interp, name, CONST_STRING(interp, "exit_code"))) {
            exception->exit_code = VTABLE_get_integer(interp, value);
            return;
        }

        if (!string_compare(interp, name, CONST_STRING(interp, "payload"))) {
            exception->payload = value;
            return;
        }

        /* If lookup failed, exception. */
        real_exception(interp, NULL, ATTRIB_NOT_FOUND,
            "No such attribute '%S'", name);
    }
}

/*

=back

=head1 HISTORY

Initial revision by leo 2003.07.10.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
