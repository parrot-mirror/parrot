
/*
Copyright (C) 2006, The Perl Foundation.
$Id: $

=head1 NAME

src/pmc/packfileconstanttable.pmc - Packfile Constant Table

=head1 DESCRIPTION

Holds and allows manipulatin of a Packfile constant table.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"


/* 
Allocate memory to extend table to correct size for setting values outside of table's current size.
*/
static void extend_const_table(struct Parrot_PackFile_ConstTable *ct, INTVAL index){
    /* Trust that index is >0 and > current const_count. */
    ct->const_count = index;
    ct->constants = mem_sys_realloc(ct->constants, index * sizeof(struct Parrot_PackFile_Constant *));
}


/* Data used:
 *   PMC_struct_val ... Parrot_Packfile_ConstTable
 */
pmclass PackfileConstantTable inherits PackfileSegment {

/*

=item C<void init()>

Initializes the constant table.

=cut

*/
    void init() {
        /* Create and set up the constants table structure. */
        struct Parrot_PackFile_ConstTable* ct =
            mem_sys_allocate_zeroed(sizeof(struct Parrot_PackFile_ConstTable));
        if (!ct) {
            PIO_eprintf(NULL, "Parrot_PackFile_ConstTable init: Unable to allocate!\n");
            return;
        }
        PMC_struct_val(SELF) = ct;

        /* Set up the constants array to hold the one pointer. */
        ct->constants = mem_sys_allocate_zeroed(sizeof(void*));
        if (!ct->constants) {
            PIO_eprintf(NULL, "Parrot_PackFile_ConstTable init: Unable to allocate!\n");
            return;
        }

        /* Need custom mark/destroy. */
        PObj_custom_mark_destroy_SETALL(SELF);
    }

/*

=item C<void destroy()>

Destroys the constant table.

=cut

*/
    void destroy() {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);
        int i;
        if (!ct)
            return;

        /* Need to free all referenced constant structures. */
        for (i = 0; i < ct->const_count; i++)
            if (ct->constants[i])
                mem_sys_free(ct->constants[i]);
        
        /* Now free the list of constants pointers and the table itself. */
        free(ct->constants);
        free(ct);
    }

/*

=item C<void mark()>

Marks any constants that are being held.

=cut

*/
    void mark() {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);
        int i;
        if (!ct)
            return;

        /* Need to mark any referenced PMCs and STRINGs. */
        for (i = 0; i < ct->const_count; i++) {
            if (ct->constants[i]) {
                if (ct->constants[i]->type == PARROT_PFC_PMC ||
                    ct->constants[i]->type == PARROT_PFC_KEY ||
                    ct->constants[i]->type == PARROT_PFC_STRING) {
                    if (ct->constants[i]->u.key)
                        pobject_lives(INTERP, (PObj*)ct->constants[i]->u.key);
                }    
            }
        }
    }

/*

=item C<STRING* pack()>

Packs this segment into a binary representation. Returns NULL on failure.

=cut

*/
    METHOD STRING* pack()
    {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);
        size_t length;
        STRING* result;
        opcode_t* image;
        
        /* Compute the length. */
        length = PackFile_ConstTable_pack_size(INTERP, ct);

        /* Make a string of the right length and pack into it. */
        result = string_make_empty(INTERP, enum_stringrep_one, 1 + length * sizeof(opcode_t));
        image = result->strstart;
        image = PF_store_opcode(image, 1 + length); /* Segment length. */
        PackFile_ConstTable_pack(INTERP, ct, image);

        /* Return resultant string. */
        return result;
    }

/*

=item C<INTVAL unpack(STRING* image)>

Unpacks the given binary representation of the segment and sets this PMC to
hold it. Returns a non-zero value on success.

=cut

*/
    METHOD INTVAL unpack(STRING* image)
    {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);
        opcode_t* packed;

        /* Get at the underlying string data. */
        packed = (opcode_t*)image->strstart;

        /* Skip over the length. XXX check */
        packed++;

        /* Do the unpack. */
        return PackFile_ConstTable_unpack(INTERP, ct, packed);
    }

/*

=item C<INTVAL elements()>

Returns the number of constants contained in the table.

=cut

*/

    INTVAL elements() {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);
        
        if (ct->const_count)
            return (INTVAL)ct->const_count;
        else
            return 0;
    }


/*

=item C<FLOATVAL get_number_keyed_int(INTVAL index)>

Gets the value of the number constant at the specified index in the constants table.  If
the constant in that position in the table is not a number, an exception will be thrown.

=cut

*/

    FLOATVAL get_number_keyed_int(INTVAL index) {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);
        
        if (ct->const_count) {
            if (index >= 0 && index < (INTVAL)ct->const_count) {
                if (ct->constants[index]->type == PARROT_PFC_NUMBER)
                    return ct->constants[index]->u.number;
                else {
                    real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Not a number");
                    return 0;
                }
            }
            else {
                real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Not in range");
                return 0;
            }
        }
        else {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "No items in list");
            return 0;
        }
    }

/*

=item C<STRING* get_string_keyed_int(INTVAL index)>

Gets the value of the string constant at the specified index in the constants table.  If
the constant in that position in the table is not a string, an exception will be thrown.

=cut

*/

    STRING* get_string_keyed_int(INTVAL index) {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);
        
        if (ct->const_count) {
            if (index >= 0 && index < (INTVAL)ct->const_count) {
                if (ct->constants[index]->type == PARROT_PFC_STRING)
                    return ct->constants[index]->u.string;
                else {
                    real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Not a string");
                    return 0;
                }
            }
            else {
                real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Not in range");
                return 0;
            }
        }
        else {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "No items in list");
            return 0;
        }
    }

/*

=item C<PMC* get_pmc_keyed_int(INTVAL index)>

Gets the value of the PMC or key constant at the specified index in the constants table.  If
the constant in that position in the table is not a PMC or key, an exception will be thrown.

=cut

*/

    PMC* get_pmc_keyed_int(INTVAL index) {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);
        
        if (ct->const_count) {
            if (index >= 0 && index < (INTVAL)ct->const_count) {
                if (ct->constants[index]->type == PARROT_PFC_PMC || ct->constants[index]->type == PARROT_PFC_KEY)
                    return ct->constants[index]->u.key;
                else {
                    real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Not a PMC or key");
                    return 0;
                }
            }
            else {
                real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Not in range");
                return 0;
            }
        }
        else {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "No items in list");
            return 0;
        }
    }


/*

=item C<void set_number_keyed_int(INTVAL index, FLOATVAL value)>

Sets the value of the number constant at the specified index in the constants table.  If
the constant in that position in the table is not a number, an exception will be thrown.
If it does not exist, the table will be extended.

=cut

*/

    void set_number_keyed_int(INTVAL index, FLOATVAL value) {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);

        if (index < 0) { 
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Index less than zero");
            return;
        }
        if (!ct->const_count || (INTVAL)ct->const_count < index) {
            extend_const_table(ct, index);
        }
        else if (ct->constants[index]->type != PARROT_PFC_NUMBER && ct->constants[index]->type !=PARROT_PFC_NONE) {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Not a number");
            return;
        }
        ct->constants[index]->type = PARROT_PFC_NUMBER;
        ct->constants[index]->u.number = value;
        
    }

/*

=item C<void set_string_keyed_int(INTVAL index, STRING* value)>

Sets the value of the string constant at the specified index in the constants table.  If
the constant in that position in the table is not a string, an exception will be thrown.
If it does not exist, the table will be extended.

=cut

*/

    set_string_keyed_int(INTVAL index) {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);
        
        if (index < 0) { 
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Index less than zero");
            return;
        }
        if (!ct->const_count || (INTVAL)ct->const_count < index) {
            extend_const_table(ct, index);
        }
        else if (ct->constants[index]->type != PARROT_PFC_STRING && ct->constants[index]->type !=PARROT_PFC_NONE) {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Not a string");
            return;
        }
        ct->constants[index]->type = PARROT_PFC_STRING;
        ct->constants[index]->u.string = value;
    }

/*

=item C<void set_pmc_keyed_int(INTVAL index, PMC* value)>

Sets the value of the PMC or key constant at the specified index in the constants table.  If
the constant in that position in the table is not a PMC or key, an exception will be thrown.
If it does not exist, the table will be extended.

=cut

*/

    void set_pmc_keyed_int(INTVAL index, PMC* value) {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);
        
        if (index < 0) { 
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Index less than zero");
            return;
        }
        if (!ct->const_count || (INTVAL)ct->const_count < index) {
            extend_const_table(ct, index);
        }
        else if (ct->constants[index]->type != PARROT_PFC_PMC && ct->constants[index]->type !=PARROT_PFC_NONE) {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Not a PMC key");
            return;
        }
        ct->constants[index]->type = PARROT_PFC_PMC;
        ct->constants[index]->u.key = value;

    }

/*
=item C<INTVAL get_type(INTVAL index)>

Returns an integer value denoting the type of the constant at the specified index.

=cut

*/

    METHOD INTVAL get_type(INTVAL index) {
        struct Parrot_PackFile_ConstTable *ct = (struct Parrot_PackFile_ConstTable*)PMC_struct_val(SELF);

        if (ct->const_count) {
            if (index >= 0 && index < (INTVAL)ct->const_count) 
                return ct->constants[index]->type;
            else {
                real_exception(INTERP, NULL, OUT_OF_BOUNDS, "Not in range");
                return 0;
            }
        }
        else {
            real_exception(INTERP, NULL, OUT_OF_BOUNDS, "No items in list");
            return 0;
        }

    }

}
/*

=back

=cut

*/


/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
