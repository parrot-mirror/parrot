grammar POST::Grammar is TGE::Grammar;

transform root (PAST::Block) :language('PIR') {
    .local pmc blockpast
    blockpast = get_hll_global ['POST'], '@?BLOCK'
    unless null blockpast goto have_blockpast
    blockpast = new 'ResizablePMCArray'
    set_hll_global ['POST'], '@?BLOCK', blockpast
  have_blockpast:
    .local pmc post
    post = tree.'get'('post', node)
    $I0 = isa post, 'POST::Sub'
    if $I0 goto end
    $S0 = post.'unique'('__anon_')
    $P0 = get_hll_global ['POST'], 'Sub'
    post = $P0.'new'(post, 'name'=>$S0)
  end:
    .return (post)
}


transform post (PAST::Block) :language('PIR') {
    ##  add current PAST::Block to @?BLOCK
    .local pmc blockpast
    blockpast = get_hll_global ['POST'], '@?BLOCK'
    unshift blockpast, node

    .local string name, pragma, blocktype
    name = node.'name'()
    if name != '' goto with_name
    name = node.unique('_block')
  with_name:
    pragma = node.'pragma'()
    blocktype = node.'blocktype'()
    .local pmc outerpost
    outerpost = get_hll_global ['POST'], '$?SUB'
    .local pmc post
    post = new 'POST::Sub'
    post.'init'('node'=>node, 'name'=>name, 'outer'=>outerpost, 'pragma'=>pragma, 'blocktype'=>blocktype)
    set_hll_global ['POST'], '$?SUB', post
    .local string compiler
    compiler = node.'compiler'()
    if compiler goto hll_block
  past_block:
    .local pmc iter
    iter = node.'iterator'()
    unless iter goto iter_end
  iter_loop:
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    post.'push'(cpost)
    if iter goto iter_loop
  iter_end:
    goto end

  hll_block:
    post.'compiler'(compiler)
    iter = node.'iterator'()
  hll_loop:
    unless iter goto end
    $P0 = shift iter
    post.'push'($P0)
    goto hll_loop

  end:
    set_hll_global ['POST'], '$?SUB', outerpost
    if blocktype != 'immediate' goto blocktype_end
    $P0 = get_hll_global ['POST'], 'Op'
    post = $P0.'new'(post, 'node'=>node, 'pirop'=>'call', 'arglist'=>post)

  blocktype_end:
    ##  pop current block from @?BLOCK
    $P99 = shift blockpast
    .return (post)
}


transform post (PAST::Stmts) :language('PIR') {
    .local pmc ops
    ops =  new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc iter
    iter = node.'iterator'()
    unless iter goto end
  iter_loop:
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    ops.'push'(cpost)
    if iter goto iter_loop
  iter_end:
  end:
    .return (ops)
}


transform post (PAST::Op) :language('PIR') {
    .return tree.'get'('pirop', node)
}


transform pirop (PAST::Op) :language('PIR') {
    .local string pirop
    pirop = node.'pirop'()
    .local pmc ops, post
    $P0 = get_hll_global ['POST'], 'Ops'
    ops = $P0.'new'('node'=>node)
    $P0 = get_hll_global ['POST'], 'Op'
    post = $P0.'new'('node'=>node, 'pirop'=>pirop)

    .local pmc iter
    iter = node.'iterator'()
  iter_loop:
    unless iter goto iter_end
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    #  code to evaluate operand
    ops.'push'(cpost)
    #  add operand argument to node
    post.'push'(cpost)
    #  see if operand is named
    $P0 = cpast.'named'()
    unless $P0 goto iter_loop
    $P0 = tree.'get'('post', $P0)
    cpost.'named'($P0)
    goto iter_loop
  iter_end:
    #  add pirop to ops
    ops.'push'(post)
    ops.'result'(post)
    .return (ops)
}


transform post (PAST::Val) :language('PIR') {
    .local pmc value
    value = node['value']
    $P0 = get_hll_global ['POST'], 'Val'
    .return $P0.'new'('node'=>node, 'value'=>value)
}
