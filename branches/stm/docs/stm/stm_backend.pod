=head1 NAME

Software transactional memory backend

=head1 ABSTRACT

Defines the interface backends for software transactional memory will follow.

=head1 DESCRIPTION

This document describes a software transactional memory interface which will
wrap arbitrary PMCs. As these are transactions, users must verify that their
commit succeeded and if it did not, retry. Note that this requires that
all actions performed during a transaction that are not STM reads and
writes be idempotent. This interface is meant to be used by C code and,
consequently, requires users to arrange for their own retrying loop.

If these functions are called when there is no active transaction, then they
will be equivalent to creating a transaction, calling the function in
question, and then ending the transaction (except when otherwise noted).

=head2 Types

=over 4

=item STM_PMC_handle

An opaque pointer type which will point to some sort PObj*.

=item STM_vtable

A table of functions for some implementation of STM. Includes an entry
for each of the implementation functions below, except STM_register and STM_unregister, 
with the leading 'STM_' removed.

=back

=head2 Functions

=over 4

=item void STM_register(STM_vtable *vtable)

Register an STM implementation which will use the provided vtable. Future
calls to the global functions will go as if through the vtable. The vtable
should not be changed after calling the function.  Should only be called
once. Below functions are not safe to use until it has been called.

=item STM_PMC_handle STM_alloc(Interp *interp, PMC *pmc)

Creates a handle through which a PMC may be accessed. C<pmc> is copied as
the starting value if it is non-null. Otherwise PMCNULL will be assumed.
Has no effect on current transactions.

=item void STM_start_transaction(Interp *interp)

Start a new (possibly nested) transaction.

=item PMC *STM_read(Interp *, STM_PMC_handle handle)

Read a PMC. The STM implementation trusts that you will not modify the
returned PMC.

=item PMC *STM_begin_update(Interp *, STM_PMC_handle handle)

Obtain some copy of the PMC for writing. Writes will not commit
immediately.  If this function is called while no transaction is active it
will return NULL and will not do anything else.

=item void STM_finish_update(Interp *, STM_PMC_handle handle, PMC *)

Finish writing a PMC obtained with C<STM_begin_update>. If the supplied C<PMC *> is
different from the copy given, it should still be used. It is an error to
call this function while no transaction is active.

=item void STM_write(Interp *, STM_PMC_handle handle, PMC *)

Replace the stored PMC with the provided version without reading or copying the current value.

=item int STM_commit(Interp *)

Commits a transaction. Returns a true value if the transaction was successful. If it
returns false, the transaction was aborted. Inner transactions are always
successful if the outer transaction is invalid.

=item void STM_abort(Interp *)

Abort a transaction, leaving the original values unchanged.

=item void STM_wait(Interp *)

Abort the transaction and wait for one of the values it is dependent on to change.
(Used to implement 'retry'.)

=item int STM_validate(Interp *)

Returns true if the current transaction is still valid (a commit 
would succeed), false otherwise. Always return true when there is
no active transaction.

=item void STM_mark_transaction(Interp *)

Mark everything referenced by the current transaction as living.

=item void STM_mark_pmc_handle(Interp *, STM_PMC_handle handle)

Mark everything referenced by the PMC handle as living.

=item int STM_transaction_depth(Interp *)

Returns how deeply nested in transactions we are or 0 if we are not inside
any transaction.

=head2 Nested transactions subtleties

To deal properly with nested transactions, a user of these functions should
call C<STM_validate(...)> after a nested transaction is aborted
unintentionally (STM_commit() returns false or after STM_wait() is called). If
STM_validate() returns false, then the enclosing transaction should be aborted
and retried. This check is necessary when the inner transaction is 
performing an explicit retry is dangerous because the inner transaction 
may be choosing to retry based on a now invalid value from the outer 
transaction. It is necessary after a failed commit because if the outer
transaction has been committed to using a certain version of some (now
changed) variable, then inner transaction must see that version, so an
implementation might never let the inner transaction commit.

After the outer transaction is aborted for this reason, one should
check the validity of any transactions enclosing it similarly since the
reason for the failure may really be at a higher-level transaction.

=back

=cut

__END__
Local Variables:
  fill-column:78
End:
vim: tw=78 wrap
