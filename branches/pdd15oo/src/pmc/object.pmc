/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/object.pmc - An instance of a class

=head1 DESCRIPTION

Implements an instance of a class.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/oo_private.h"

/* This finds the index of an attribute in an object's attribute store and
 * returns it. Returns -1 if the attribute does not exist. */
static INTVAL
get_attrib_index(PARROT_INTERP, PMC *self, STRING *name)
{
    Parrot_Class * const _class = PARROT_CLASS(self);
    int                  num_classes, i;

    /* First see if we can find it in the cache. */
    if (VTABLE_exists_keyed_str(interp, _class->attrib_cache, name))
        return VTABLE_get_integer_keyed_str(interp, _class->attrib_cache, name);

    /* No hit. We need to walk up the list of parents to try and find the
     * attribute. */
    num_classes = VTABLE_elements(interp, _class->all_parents);

    for (i = 0; i < num_classes; i++) {
        /* Get the class and its attribute metadata hash. */
        PMC * const cur_class = VTABLE_get_pmc_keyed_int(interp,
            _class->all_parents, i);

        /* Build a string representing the fully qualified attribute name. */
        STRING *fq_name = VTABLE_get_string(interp, cur_class);
        fq_name         = string_append(interp, fq_name, name);

        /* Look up. */
        if (VTABLE_exists_keyed_str(interp, _class->attrib_index, fq_name)) {
            /* Found it. Get value, cache it and we're done. */
            const INTVAL index = VTABLE_get_integer_keyed_str(interp,
                _class->attrib_index, fq_name);
            VTABLE_set_integer_keyed_str(interp, _class->attrib_cache, name,
                index);

            return index;
        }
    }

    return -1;
}

/* This variation bypasses the cache and finds the index of a particular
 * parent's attribute in an object's attribute store and returns it. Returns -1
 * if the attribute does not exist. */

static INTVAL
get_attrib_index_keyed(PARROT_INTERP, PMC *self, PMC *key, STRING *name)
{
    Parrot_Class * const _class = PARROT_CLASS(self);
    PMC *parent_class = PMCNULL;
    STRING *fq_name;

    parent_class = Parrot_oo_get_class(interp, key);

    /* Build a string representing the fully qualified attribute name. */
    fq_name = VTABLE_get_string(interp, parent_class);
    fq_name = string_append(interp, fq_name, name);

    /* Look up. */
    if (VTABLE_exists_keyed_str(interp, _class->attrib_index, fq_name)) {
        /* Found it. Get value and we're done. */
        const INTVAL index = VTABLE_get_integer_keyed_str(interp,
            _class->attrib_index, fq_name);
        return index;
    }

    return -1;
}

pmclass Object need_ext {

/*

=item C<void init()>

Raises an exception; you can only instantiate objects from a class.

=cut

*/

    void init() {
        real_exception(interp, NULL, INVALID_OPERATION,
                "Object must be created by a class.");
    }

/*


=item C<void init_pmc(PMC *class)>

Raises an exception; you can only instantiate objects from a class.

=cut

*/

    void init_pmc(PMC *worreva) {
        real_exception(interp, NULL, INVALID_OPERATION,
                "Object must be created by a class.");
    }

/*

=item C<void destroy()>

Free the object's underlying struct.

=cut

*/
    void destroy() {
        mem_sys_free(PMC_data(SELF));
    }

/*

=item C<STRING *name()>

Returns the fully qualified name of the object's class.

=cut

*/

    STRING *name() {
        PMC    * const _class     = VTABLE_get_class(interp, SELF);
        STRING * const class_name = VTABLE_get_string(interp, _class);

        return class_name;
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs.

=cut

*/
    void mark() {
        if (PARROT_OBJECT(SELF)) {
            Parrot_Object * const obj = PARROT_OBJECT(SELF);

            if (obj->_class)
                pobject_lives(interp, (PObj*)obj->_class);
            if (obj->attrib_store)
                pobject_lives(interp, (PObj*)obj->attrib_store);
        }
    }

/*

=item C<PMC *get_attr_str(STRING *name)>

Gets the value of an attribute for this object. Will find the first attribute
of the given name walking up the inheritance tree.

=cut

*/
    PMC *get_attr_str(STRING *name) {
        Parrot_Object * const obj = PARROT_OBJECT(SELF);

        /* Look up the index. */
        const INTVAL index = get_attrib_index(interp, obj->_class, name);

        /* If lookup failed, exception. */
        if (index == -1)
            real_exception(interp, NULL, ATTRIB_NOT_FOUND,
                "No such attribute '%S'", name);

        return VTABLE_get_pmc_keyed_int(interp, obj->attrib_store, index);
    }

/*

=item C<PMC *get_attr_keyed(PMC *key, STRING *name)>

Gets the value of an attribute for this object. Will only look for attributes
defined in the parent identified by the given key.

=cut

*/
    PMC *get_attr_keyed(PMC *key, STRING *name) {
        Parrot_Object * const obj = PARROT_OBJECT(SELF);

        /* Look up the index. */
        const INTVAL index = get_attrib_index_keyed(interp, obj->_class, key, name);

        /* If lookup failed, exception. */
        if (index == -1)
            real_exception(interp, NULL, ATTRIB_NOT_FOUND,
                "No such attribute '%S' in class '%S'", name,
                VTABLE_get_string(interp, key));

        return VTABLE_get_pmc_keyed_int(interp, obj->attrib_store, index);
    }

/*

=item C<void set_attr_str(STRING *name, PMC *value)>

Sets the value of an attribute for this object. Will set the first attribute
of the given name walking up the inheritance tree.

=cut

*/
    void set_attr_str(STRING *name, PMC *value) {
        Parrot_Object * const obj = PARROT_OBJECT(SELF);
        const INTVAL index        = get_attrib_index(interp, obj->_class, name);

        /* If lookup failed, exception. */
        if (index == -1)
            real_exception(interp, NULL, ATTRIB_NOT_FOUND,
                "No such attribute '%S'", name);

        VTABLE_set_pmc_keyed_int(interp, obj->attrib_store, index, value);
    }

/*

=item C<void set_attr_keyed(PMC *key, STRING *name, PMC *value)>

Sets the value of an attribute for this object. Will only set attributes
defined in the parent identified by the given key.

=cut

*/
    void set_attr_keyed(PMC *key, STRING *name, PMC *value) {
        Parrot_Object * const obj = PARROT_OBJECT(SELF);
        const INTVAL index        = get_attrib_index_keyed(interp, obj->_class, key, name);

        /* If lookup failed, exception. */
        if (index == -1)
            real_exception(interp, NULL, ATTRIB_NOT_FOUND,
                "No such attribute '%S' in class '%S'", name,
                VTABLE_get_string(interp, key));

        VTABLE_set_pmc_keyed_int(interp, obj->attrib_store, index, value);
    }

/*

=item C<PMC *find_method(STRING *name)>

Queries this object's class to find the method with the given name.

=cut

*/
    PMC *find_method(STRING *name) {
        Parrot_Object * const obj    = PARROT_OBJECT(SELF);
        Parrot_Class  * const _class = PARROT_CLASS(obj->_class);
        PMC           *method        = PMCNULL;

        /* Walk and search. One day, we'll use the cache first. */
        const int num_classes        = VTABLE_elements(interp,
                                                      _class->all_parents);
        const int all_in_universe    = !CLASS_has_alien_parents_TEST(obj->_class);
        int       alien_parents_pos  = VTABLE_elements(interp,
                                                      _class->attrib_metadata);
        int i;

        for (i = 0; i < num_classes; i++) {
            /* Get the class. */
            PMC * const cur_class =
                VTABLE_get_pmc_keyed_int(interp, _class->all_parents, i);

            /* If it's from this universe or the class doesn't inherit from
             * anything outside of it... */
            if (all_in_universe || VTABLE_isa(interp, cur_class, CONST_STRING(interp, "Class"))) {
                const Parrot_Class * const class_info = PARROT_CLASS(cur_class);
                if (VTABLE_exists_keyed_str(interp, class_info->methods, name)) {
                    /* Found it! */
                    method = VTABLE_get_pmc_keyed_str(interp, class_info->methods, name);
                    break;
                }
            }
            else {
                /* Delegate the lookup to the class. */
                PMC * const del_class = VTABLE_get_pmc_keyed_int(interp, obj->attrib_store,
                    alien_parents_pos);
                method = VTABLE_find_method(interp, del_class, name);

                if (!PMC_IS_NULL(method)) {
                    /* Found it. However, if we just hand this back and it's
                     * an NCI and we call it, we will get the wrong invocant
                     * passed. Therefore, we need to close the NCI and make it
                     * into a BoundNCI. */
                    if (method->vtable->base_type == enum_class_NCI) {
                        method         = VTABLE_clone(interp, method);
                        method->vtable = interp->vtables[enum_class_Bound_NCI];
                        VTABLE_set_pmc(interp, method, del_class);
                    }

                    /* Found a method, so we're done. */
                    break;
                }

                alien_parents_pos++;
            }
        }

        return method;
    }

/*

=item C<PMC *get_class()>

Get the class PMC representing the class that this object is an instance of.

=cut

*/
    PMC *get_class() {
        return PARROT_OBJECT(SELF)->_class;
    }

/*

=item C<INTVAL can(STRING *method_name)>

Returns 0 if the class does not have a method with the given name and a
non-zero value if it does.

=cut

*/
    INTVAL can(STRING *method_name) {
        /* Just use find_method and see it if finds anything. */
        const PMC * const method = VTABLE_find_method(interp, SELF, method_name);
        return !PMC_IS_NULL(method);
    }

/*

=item C<INTVAL isa_pmc(PMC *classname)>

Returns whether the object's class is or inherits from C<*classname>.

=cut

*/

    INTVAL isa_pmc(PMC *lookup) {
        if (PMC_IS_NULL(lookup))
            return 0;

        if (SUPER(lookup))
            return 1;

        /* Dispatch isa to the object's class */
        return VTABLE_isa_pmc(interp, VTABLE_get_class(interp, SELF), lookup);
    }

/*

=item C<INTVAL isa(STRING *classname)>

Returns whether the class is or inherits from C<*classname>.

=cut

*/
    INTVAL isa(STRING *classname) {
        PMC   *_class;

        if (SUPER(classname))
            return 1;

        _class = VTABLE_get_class(interp, SELF);
        return VTABLE_isa(interp, _class, classname);
    }


/*

=item C<INTVAL type()>

Returns the integer type of the object's class.

=cut

*/

    INTVAL type() {
        PMC *class = VTABLE_get_class(interp, SELF);
        return VTABLE_type(interp, class);
    }

}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
